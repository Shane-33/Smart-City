/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */
const t=(()=>{const t=Intl.supportedValuesOf("timeZone");return[...new Set([...t,"Etc/GMT+1","Etc/GMT+10","Etc/GMT+11","Etc/GMT+12","Etc/GMT+2","Etc/GMT+3","Etc/GMT+4","Etc/GMT+5","Etc/GMT+6","Etc/GMT+7","Etc/GMT+8","Etc/GMT+9","Etc/GMT-1","Etc/GMT-10","Etc/GMT-11","Etc/GMT-12","Etc/GMT-13","Etc/GMT-14","Etc/GMT-2","Etc/GMT-3","Etc/GMT-4","Etc/GMT-5","Etc/GMT-6","Etc/GMT-7","Etc/GMT-8","Etc/GMT-9"])]})(),n={startDate:(new Date).toISOString(),groupDateRange:365,debug:!1},e=new Set(["Europe","Asia","America","America/Argentina","Africa","Australia","Pacific","Atlantic","Antarctica","Arctic","Indian"]),c=t=>{if(t.includes("Istanbul"))return"Europe";const n=t.lastIndexOf("/");return-1===n?t:t.slice(0,n)},r=t=>e.has(t),o=(t,n,e)=>t.length===n.length&&t.every(((t,c)=>e.same(t,n[c]))),a=(t,n=5)=>{const e=t.filter((({label:t})=>r(c(t))));return 0===e.length?[0]:function(t,n=5){const e=t.length;if(e<=n)return t;const c=Math.min(e-2,n-2),r=(e-1)/(c+1);return[t[0],...Array.from({length:c},((n,e)=>t[Math.round((e+1)*r)])),t[e-1]]}(e.map((n=>t.indexOf(n))),n)};async function i(e){const{debug:i,groupDateRange:s,hooks:E,startDate:l,dateEngine:u}={...n,...e},M=[];if(!u)throw new Error("dateEngine is required");const T=t.map((t=>({label:t})));E?.onBeforeTimeZoneMetadataCreate?.(T);const G=((t,n,e,o,a=!1)=>{const i=new Map;a&&console.log(`Initializing data starting ${n} with ${e} days in the future, comparing ${t.length} timezones`);const s=((t,n,e)=>{const c=[];let r=e.create(t);for(let t=0;t<=n;t++)r=e.increase(r),c.push(e.formatToIsoDateString(r));return c})(n,e,o);return t.map((t=>{const n=t.label,e=c(n),a=s.map((t=>{const e=`${t}-${n}`;let c=i.get(e);return c||(c=o.isoToTimeZone(t,n),i.set(e,c),c)}));return{...t,continent:e,isRegularContinent:r(e),dates:a}}))})(T,l,s,u,i);E?.onTimeZoneMetadataCreate?.(G);for(const t of G){const{label:n,continent:e,dates:c}=t;if(t.visited)continue;t.visited=!0;const r={labelTzIndices:void 0,tzs:[{label:n}]};E?.onGroupCreate?.(r,t);for(const t of G.filter((t=>!t.visited))){const{label:n,continent:a,isRegularContinent:i,dates:s}=t;if((e===a||!i)&&o(c,s,u)){const e={label:n};r.tzs.push(e),E?.onGroupTimeZoneAdd?.(r,e,t),t.visited=!0}}M.push(r),E?.onGroupAdd?.(r)}const f=M.map((t=>{E?.onBeforeFinalGroupCreate?.(t),t.tzs=t.tzs.sort(((t,n)=>t.label.localeCompare(n.label)));const n={labelTzIndices:a(t.tzs,7),tzs:t.tzs.map((t=>t.label))};return E?.onFinalGroupCreate?.(n,t),n})).sort(((t,n)=>n.tzs.length-t.tzs.length));if(i){const n=t.map((t=>f.some((n=>n.tzs.includes(t)))?null:t)).filter(Boolean);if(n.length>0)throw new Error(`There are ${n.length} missing timezones: ${n.toString()}`)}return E?.onFinalGroupingCreate?E.onFinalGroupingCreate(f):f}export{i as groupTimeZones}