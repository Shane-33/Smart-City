/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */
import { r as registerInstance, c as createEvent, h, a as getElement } from './index-5581518c.js';
import { l as focusElementInGroup, t as toAriaBoolean } from './dom-bb94e253.js';
import { c as connectInteractive, d as disconnectInteractive, u as updateHostInteraction } from './interactive-69ec9d65.js';
import { c as createObserver } from './observers-7bce645e.js';
import { a as setComponentLoaded, s as setUpLoadableComponent, c as componentFocusable } from './loadable-e0edfe27.js';
import './guid-b69b57e2.js';
import './resources-53455208.js';
import './browser-2f0866ce.js';

const chipGroupCss = ":host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-ui-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:flex}.container{display:flex;inline-size:100%;flex-wrap:wrap;gap:0.5rem}::slotted(calcite-chip){flex:none}:host([scale=s]) .container{gap:0.25rem}:host([scale=l]) .container{gap:0.75rem}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}:host([hidden]){display:none}[hidden]{display:none}";

const ChipGroup = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.calciteChipGroupSelect = createEvent(this, "calciteChipGroupSelect", 6);
    this.mutationObserver = createObserver("mutation", () => this.updateItems());
    this.items = [];
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.updateItems = (event) => {
      const target = event ? event.target : this.slotRefEl;
      this.items = target
        ?.assignedElements({ flatten: true })
        .filter((el) => el?.matches("calcite-chip"));
      this.items?.forEach((el) => {
        el.interactive = true;
        el.scale = this.scale;
        el.selectionMode = this.selectionMode;
      });
      this.setSelectedItems(false);
    };
    this.setSelectedItems = (emit, elToMatch) => {
      if (elToMatch) {
        this.items?.forEach((el) => {
          const matchingEl = elToMatch === el;
          switch (this.selectionMode) {
            case "multiple":
              if (matchingEl) {
                el.selected = !el.selected;
              }
              break;
            case "single":
              el.selected = matchingEl ? !el.selected : false;
              break;
            case "single-persist":
              el.selected = !!matchingEl;
              break;
          }
        });
      }
      this.selectedItems = this.items?.filter((el) => el.selected);
      if (emit) {
        this.calciteChipGroupSelect.emit();
      }
    };
    this.disabled = false;
    this.label = undefined;
    this.scale = "m";
    this.selectionMode = "none";
    this.selectedItems = [];
  }
  onSelectionModeChange() {
    this.updateItems();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    connectInteractive(this);
    this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
  }
  componentDidRender() {
    disconnectInteractive(this);
    updateHostInteraction(this);
  }
  componentDidLoad() {
    setComponentLoaded(this);
  }
  disconnectedCallback() {
    this.mutationObserver?.disconnect();
  }
  async componentWillLoad() {
    setUpLoadableComponent(this);
  }
  //--------------------------------------------------------------------------
  //
  //  Event Listeners
  //
  //--------------------------------------------------------------------------
  calciteInternalChipKeyEventListener(event) {
    if (event.composedPath().includes(this.el)) {
      const interactiveItems = this.items?.filter((el) => !el.disabled);
      switch (event.detail.key) {
        case "ArrowRight":
          focusElementInGroup(interactiveItems, event.detail.target, "next");
          break;
        case "ArrowLeft":
          focusElementInGroup(interactiveItems, event.detail.target, "previous");
          break;
        case "Home":
          focusElementInGroup(interactiveItems, event.detail.target, "first");
          break;
        case "End":
          focusElementInGroup(interactiveItems, event.detail.target, "last");
          break;
      }
    }
  }
  calciteChipCloseListener(event) {
    const item = event.target;
    if (this.items?.includes(item)) {
      if (this.items?.indexOf(item) > 0) {
        focusElementInGroup(this.items, item, "previous");
      }
      else if (this.items?.indexOf(item) === 0) {
        focusElementInGroup(this.items, item, "next");
      }
      else {
        focusElementInGroup(this.items, item, "first");
      }
    }
    this.items = this.items?.filter((el) => el !== item);
  }
  calciteChipSelectListener(event) {
    if (event.composedPath().includes(this.el)) {
      this.setSelectedItems(true, event.target);
    }
  }
  // --------------------------------------------------------------------------
  //
  //  Public Methods
  //
  // --------------------------------------------------------------------------
  /**
   * Sets focus on the component's first focusable element.
   */
  async setFocus() {
    await componentFocusable(this);
    if (!this.disabled) {
      return (this.selectedItems[0] || this.items[0])?.setFocus();
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const role = this.selectionMode === "none" || this.selectionMode === "multiple" ? "group" : "radiogroup";
    return (h("div", { "aria-disabled": toAriaBoolean(this.disabled), "aria-label": this.label, class: "container", role: role }, h("slot", { onSlotchange: this.updateItems, ref: (el) => (this.slotRefEl = el) })));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "selectionMode": ["onSelectionModeChange"]
  }; }
};
ChipGroup.style = chipGroupCss;

export { ChipGroup as calcite_chip_group };
