/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{clock as t}from"./clock.js";import e from"./Error.js";import{once as r}from"./events.js";import n from"./Logger.js";import{removeMaybe as o}from"./maybe.js";async function i(t,e){const r=t.slice(),n=await Promise.all(t.map(((t,r)=>e(t,r))));return r.filter(((t,e)=>n[e]))}function u(t="Aborted"){return new e("AbortError",t)}function s(t,e="Aborted"){if(c(t))throw u(e)}function l(t){return null!=t?"aborted"in t?t:t.signal:t}function c(t){const e=l(t);return null!=e&&e.aborted}function a(t){if(b(t))throw t}function f(t){if(!b(t))throw t}function m(t,e){const n=l(t);if(null!=n){if(!n.aborted)return r(n,"abort",(()=>e()));e()}}function w(t,e){const n=l(t);if(null!=n)return s(n),r(n,"abort",(()=>e(u())))}function h(t,e){return null==l(e)?t:new Promise(((r,n)=>{let i=m(e,(()=>n(u())));const s=()=>{i=o(i)};t.then(s,s),t.then(r,n)}))}function p(t,r,n){return Promise.race([t,A(r).then((()=>{throw new e("timeout",`Did not resolve within ${r} milliseconds (${n??"timeout"})`)}))])}function b(t){return"AbortError"===t?.name}async function d(t){try{return await t}catch(e){if(!b(e))throw e;return}}async function y(t,e=n.getLogger("esri")){try{return await t}catch(r){b(r)||e.error(r)}}async function v(t){if(!t)return;if("function"!=typeof t.forEach){const e=Object.keys(t),r=e.map((e=>t[e])),n=await v(r),o={};return e.map(((t,e)=>o[t]=n[e])),o}const e=t;return Promise.allSettled(e).then((t=>Array.from(e,((e,r)=>{const n=t[r];return"fulfilled"===n.status?{promise:e,value:n.value}:{promise:e,error:n.reason}}))))}async function j(t){return(await v(t)).filter((t=>!!t.value)).map((t=>t.value))}async function P(t){return(await Promise.allSettled(t)).filter((t=>"fulfilled"===t.status)).map((t=>t.value))}async function g(t){return(await Promise.allSettled(t)).filter((t=>"rejected"===t.status)).map((t=>t.reason))}function A(t,e=void 0,r){const n=new AbortController;return m(r,(()=>n.abort())),new Promise(((r,o)=>{let i=setTimeout((()=>{i=0,r(e)}),t);m(n,(()=>{i&&(clearTimeout(i),o(u()))}))}))}function T(t,r,n,o){const i=n&&"abort"in n?n:null;null!=o||i||(o=n);let u=setTimeout((()=>{u=0,i?.abort()}),r);const s=()=>o||new e("promiseUtils:timeout","The wrapped promise did not resolve within "+r+" ms");return t.then((t=>{if(0===u)throw s();return clearTimeout(u),t}),(t=>{throw clearTimeout(u),0===u?s():t}))}function E(t){return t&&"function"==typeof t.then}function S(t){return E(t)?t:Promise.resolve(t)}function k(t,e=-1){let r,n,o,i,s=null;const l=(...c)=>{if(r){n=c,i&&i.reject(u()),i=C();const t=i.promise;if(s){const t=s;s=null,t.abort()}return t}if(o=i||C(),i=null,e>0){const n=new AbortController;r=S(t(...c,n.signal));const o=r;A(e).then((()=>{r===o&&(i?n.abort():s=n)}))}else r=1,r=S(t(...c));const a=()=>{const t=n;n=o=r=s=null,null!=t&&l(...t)},f=r,m=o;return f.then(a,a),f.then(m.resolve,m.reject),m.promise};return l}function C(){let e,r;const n=new Promise(((t,n)=>{e=t,r=n})),o=t=>{e(t)};return o.resolve=t=>e(t),o.reject=t=>r(t),o.timeout=(e,r)=>t.setTimeout((()=>o.reject(r)),e),o.promise=n,o}function L(t,e){return t.then(e,e)}function $(t,e){e.then(t.resolve,t.reject)}async function x(t){await Promise.resolve(),s(t)}export{A as after,g as allSettledErrors,P as allSettledValues,L as always,u as createAbortError,C as createResolver,k as debounce,v as eachAlways,j as eachAlwaysValues,i as filter,d as ignoreAbortErrors,b as isAbortError,c as isAborted,E as isPromiseLike,y as logOnError,m as onAbort,w as onAbortOrThrow,$ as settleWithPromise,a as throwIfAbortError,s as throwIfAborted,f as throwIfNotAbortError,T as timeout,x as waitTick,S as when,h as whenOrAbort,p as whenOrTimeout};
