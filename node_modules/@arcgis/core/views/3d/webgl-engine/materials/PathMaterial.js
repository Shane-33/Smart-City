/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{fromValues as t}from"../../../../geometry/support/aaBoundingBox.js";import{newLayout as r}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as i}from"../core/shaderLibrary/ShaderOutput.js";import{NormalsDoubleSidedMode as a}from"../core/shaderLibrary/shading/Normals.glsl.js";import s from"../lib/GLMaterial.js";import{Material as o}from"../lib/Material.js";import{isPathGeometry as n}from"../lib/PathGeometry.js";import{RenderSlot as h}from"../lib/RenderSlot.js";import{VertexAttribute as u}from"../lib/VertexAttribute.js";import{DefaultBufferWriter as c}from"./DefaultBufferWriter.js";import{vertexAttributeLocations as l,PathTechniqueConfiguration as d,PathTechnique as p,PathPassParameters as m}from"./PathTechnique.js";import{intersectAabbInvDir as f}from"./internal/MaterialUtil.js";class b extends o{constructor(e){super(e,new S),this.supportsEdges=!0,this._vertexAttributeLocations=l,this._configuration=new d,this._vertexBufferLayout=b.getVertexBufferLayout()}getConfiguration(e,t){return this._configuration.output=e,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.hasOccludees=this.parameters.hasOccludees,e!==i.Color&&e!==i.Alpha||(this._configuration.doubleSidedMode=this.parameters.doubleSided&&"normal"===this.parameters.doubleSidedType?a.View:this.parameters.doubleSided&&"winding-order"===this.parameters.doubleSidedType?a.WindingOrder:a.None,this._configuration.receiveShadows=this.parameters.receiveShadows,this._configuration.receiveAmbientOcclusion=null!=t.ssao),this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}isVisibleForOutput(e){return e!==i.Shadow&&e!==i.ShadowExcludeHighlight&&e!==i.ShadowHighlight||this.parameters.castShadows}isVisible(){return super.isVisible()&&this.parameters.opacity>0}intersect(r,i,a,s,o,h){const u=r;if(!n(u))return;const c=u.path,l=[this.parameters.size[0],this.parameters.size[1]];if(this.parameters.vvSize){const{offset:t,factor:r,minSize:i,maxSize:a}=this.parameters.vvSize,s=c.sizeAttributeValue;l[0]*=e(t[0]+s*r[0],i[0],a[0]),l[1]*=e(t[2]+s*r[2],i[2],a[2])}const d=Math.max(l[0],l[1]),p=r.boundingInfo;if(null==p)return void this._intersectTriangles(c,l,s,o,h);const m=t(p.bbMin[0]-d,p.bbMin[1]-d,p.bbMin[2]-d,p.bbMax[0]+d,p.bbMax[1]+d,p.bbMax[2]+d),b=[o[0]-s[0],o[1]-s[1],o[2]-s[2]],g=Math.sqrt(b[0]*b[0]+b[1]*b[1]+b[2]*b[2]),S=[g/b[0],g/b[1],g/b[2]];f(m,s,S,a.tolerance)&&this._intersectTriangles(c,l,s,o,h)}_intersectTriangles(e,t,r,i,a){e.baked.size&&e.baked.size[0]===t[0]&&e.baked.size[1]===t[1]||e.baked.bake(t),e.baked.intersect(r,i,a)}createBufferWriter(){return new c(this._vertexBufferLayout)}produces(e,t){switch(t){case i.Shadow:case i.ShadowHighlight:case i.ShadowExcludeHighlight:if(!this.parameters.castShadows)return!1;case i.Color:case i.Alpha:case i.Depth:case i.Normal:case i.Highlight:case i.ObjectAndLayerIdColor:return e===(this.parameters.transparent?h.TRANSPARENT_MATERIAL:h.OPAQUE_MATERIAL)||e===h.DRAPED_MATERIAL;default:return!1}}createGLMaterial(e){return new g(e)}static getVertexBufferLayout(){return r().vec3f(u.POSITION).vec4f(u.PROFILERIGHT).vec4f(u.PROFILEUP).vec4f(u.PROFILEVERTEXANDNORMAL).vec4f(u.FEATUREVALUE)}}class g extends s{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}_updateShadowState(e){null!=this.technique&&e.shadowMap.enabled===this.technique.configuration.receiveShadows||this._material.setParameters({receiveShadows:e.shadowMap.enabled})}beginSlot(e){return this._output!==i.Color&&this._output!==i.Alpha||(this._updateShadowState(e),this._updateOccludeeState(e)),this.ensureTechnique(p,e)}}class S extends m{constructor(){super(...arguments),this.doubleSided=!1,this.doubleSidedType="normal",this.receiveShadows=!1,this.castShadows=!0,this.hasSlicePlane=!1,this.transparent=!1,this.hasOccludees=!1}}export{b as PathMaterial,S as PathMaterialParameters};
