/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{s as t,n as e,f as r,b as s,o,e as n}from"../../../../chunks/vec3.js";import{c as i}from"../../../../chunks/vec3f64.js";import{f as a}from"../../../../chunks/vec4f64.js";import{newLayout as c}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as u}from"../core/shaderLibrary/ShaderOutput.js";import f from"../lib/GLMaterial.js";import{Material as p,MaterialParameters as l}from"../lib/Material.js";import{RenderSlot as h}from"../lib/RenderSlot.js";import{VertexAttribute as m}from"../lib/VertexAttribute.js";import{MeasurementArrowTechniqueConfiguration as d,MeasurementArrowTechnique as g}from"../shaders/MeasurementArrowTechnique.js";class O extends p{constructor(t){super(t,new b),this._configuration=new d}getConfiguration(t,e){return this._configuration.polygonOffsetEnabled=this.parameters.polygonOffset,this._configuration.transparent=this._transparent,this._configuration.transparencyPassType=e.transparencyPassType,this._configuration}intersect(){}produces(t,e){if(e===u.Color||e===u.Alpha){return t===(this._transparent?h.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:h.OPAQUE_MATERIAL)}return!1}createGLMaterial(t){return new A(t)}createBufferWriter(){return new y}get _transparent(){const{parameters:t}=this;return t.outlineColor[3]<1||t.stripeEvenColor[3]<1||t.stripeOddColor[3]<1}}class A extends f{beginSlot(t){return this.ensureTechnique(g,t)}}class b extends l{constructor(){super(...arguments),this.width=32,this.outlineSize=.2,this.outlineColor=a(1,.5,0,1),this.stripeEvenColor=a(1,1,1,1),this.stripeOddColor=a(1,.5,0,1),this.stripeLength=1,this.polygonOffset=!1}}const T=c().vec3f(m.POSITION).vec3f(m.NORMAL).vec2f(m.UV0).f32(m.AUXPOS1),_=i(),v=i(),I=i(),L=i(),j=i();class y{constructor(){this.vertexBufferLayout=T}elementCount(t){return 2*(t.attributes.get(m.POSITION).indices.length/2+1)}write(i,a,c,u,f){const{data:p,indices:l}=c.attributes.get(m.POSITION),h=c.attributes.get(m.NORMAL).data,d=p.length/3;l&&l.length!==2*(d-1)&&console.warn("MeasurementArrowMaterial does not support indices");const g=_,O=v,A=I,b=L,T=j,y=u.position,E=u.normal,M=u.uv0;let S=0;for(let m=0;m<d;++m){const c=3*m;if(t(g,p[c],p[c+1],p[c+2]),m<d-1){const o=3*(m+1);t(O,p[o],p[o+1],p[o+2]),t(T,h[o],h[o+1],h[o+2]),e(T,T),r(A,O,g),e(A,A),s(b,T,A),e(b,b)}const u=o(g,O);i&&a&&(n(g,g,i),n(O,O,i),n(b,b,a));const l=f+2*m,_=l+1;y.setVec(l,g),y.setVec(_,g),E.setVec(l,b),E.setVec(_,b),M.set(l,0,S),M.set(l,1,-1),M.set(_,0,S),M.set(_,1,1),m<d-1&&(S+=u)}const w=u.auxpos1;for(let t=0;t<2*d;++t)w.set(f+t,S)}}export{O as MeasurementArrowMaterial,b as Parameters};
