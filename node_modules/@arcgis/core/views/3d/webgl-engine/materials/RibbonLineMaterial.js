/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import e from"../../../../core/Logger.js";import{clamp as t}from"../../../../core/mathUtils.js";import{createRenderScreenPointArray3 as r}from"../../../../core/screenUtils.js";import{j as s}from"../../../../chunks/vec2.js";import{s as i,f as a,j as n,i as o,g as l,c as u,l as c,o as h,e as p}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec3f64.js";import{O as m}from"../../../../chunks/vec4f64.js";import{PlaneIndex as T}from"../../../../geometry/support/frustum.js";import{create as d,distance2 as _,fromPoints as E,closestLineSegmentPoint as A}from"../../../../geometry/support/lineSegment.js";import{create as R,fromPoints as I,signedDistance as S,normal as g}from"../../../../geometry/support/plane.js";import{newLayout as O}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as b}from"../core/shaderLibrary/ShaderOutput.js";import v from"../lib/GLMaterial.js";import{Material as L,RenderOccludedFlag as P}from"../lib/Material.js";import{RenderSlot as N}from"../lib/RenderSlot.js";import{isTranslationMatrix as C}from"../lib/Util.js";import{VertexAttribute as y}from"../lib/VertexAttribute.js";import{VisualVariablePassParameters as j}from"./VisualVariablePassParameters.js";import{LineMarkerAnchor as U}from"../shaders/LineMarkerTechniqueConfiguration.js";import{r as D}from"../../../../chunks/RibbonLine.glsl.js";import{vertexAttributeLocations as F,RibbonLineTechnique as w}from"../shaders/RibbonLineTechnique.js";import{RibbonLineTechniqueConfiguration as B,CapType as J}from"../shaders/RibbonLineTechniqueConfiguration.js";var M;!function(e){e[e.LEFT_JOIN_START=-2]="LEFT_JOIN_START",e[e.LEFT_JOIN_END=-1]="LEFT_JOIN_END",e[e.LEFT_CAP_START=-4]="LEFT_CAP_START",e[e.LEFT_CAP_END=-5]="LEFT_CAP_END",e[e.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",e[e.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",e[e.RIGHT_CAP_START=4]="RIGHT_CAP_START",e[e.RIGHT_CAP_END=5]="RIGHT_CAP_END"}(M||(M={}));class x extends L{constructor(e){super(e,new z),this._configuration=new B,this._vertexAttributeLocations=F}getConfiguration(e,t){this._configuration.output=e,this._configuration.draped=t.slot===N.DRAPED_MATERIAL;const r=null!=this.parameters.stipplePattern&&e!==b.Highlight;return this._configuration.stippleEnabled=r,this._configuration.stippleOffColorEnabled=r&&null!=this.parameters.stippleOffColor,this._configuration.stipplePreferContinuous=r&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins="round"===this.parameters.join,this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=null!=this.parameters.markerParameters&&V(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&null!=this.parameters.innerColor,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===P.OccludeAndTransparentStencil,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(e,r,s,i,a,n){if(!s.options.selectionMode)return;const o=e.attributes.get(y.POSITION).data,l=e.attributes.get(y.SIZE);let u=this.parameters.width;if(this.parameters.vvSize){const r=e.attributes.get(y.SIZEFEATUREATTRIBUTE).data[0];u*=t(this.parameters.vvSize.offset[0]+r*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else l&&(u*=l.data[0]);const c=i[0],h=i[1],p=(u/2+4)*e.screenToWorldRatio;let f=Number.MAX_VALUE,m=0;for(let T=0;T<o.length-5;T+=3){const e=o[T],r=o[T+1],s=c-e,i=h-r,a=o[T+3]-e,n=o[T+4]-r,l=t((a*s+n*i)/(a*a+n*n),0,1),u=a*l-s,p=n*l-i,d=u*u+p*p;d<f&&(f=d,m=T/3)}f<p*p&&a(n.dist,n.normal,m,!1)}intersect(r,p,f,m,d,R){if(!f.options.selectionMode||!r.visible)return;if(!C(p))return void e.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const O=r.attributes,b=O.get(y.POSITION).data;let v=this.parameters.width;if(this.parameters.vvSize){const e=O.get(y.SIZEFEATUREATTRIBUTE).data[0];v*=t(this.parameters.vvSize.offset[0]+e*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else O.has(y.SIZE)&&(v*=O.get(y.SIZE).data[0]);const L=f.camera,P=Q;s(P,f.point);const N=v*L.pixelRatio/2+4*L.pixelRatio;i(oe[0],P[0]-N,P[1]+N,0),i(oe[1],P[0]+N,P[1]+N,0),i(oe[2],P[0]+N,P[1]-N,0),i(oe[3],P[0]-N,P[1]-N,0);for(let e=0;e<4;e++)if(!L.unprojectFromRenderScreen(oe[e],le[e]))return;I(L.eye,le[0],le[1],ue),I(L.eye,le[1],le[2],ce),I(L.eye,le[2],le[3],he),I(L.eye,le[3],le[0],pe);let j=Number.MAX_VALUE,U=0;const D=Z(this.parameters,O)?b.length-2:b.length-5;for(let e=0;e<D;e+=3){W[0]=b[e]+p[12],W[1]=b[e+1]+p[13],W[2]=b[e+2]+p[14];const t=(e+3)%b.length;if(Y[0]=b[t]+p[12],Y[1]=b[t+1]+p[13],Y[2]=b[t+2]+p[14],S(ue,W)<0&&S(ue,Y)<0||S(ce,W)<0&&S(ce,Y)<0||S(he,W)<0&&S(he,Y)<0||S(pe,W)<0&&S(pe,Y)<0)continue;if(L.projectToRenderScreen(W,K),L.projectToRenderScreen(Y,$),K[2]<0&&$[2]>0){a(X,W,Y);const e=L.frustum,t=-S(e[T.NEAR],W)/n(X,g(e[T.NEAR]));o(X,X,t),l(W,W,X),L.projectToRenderScreen(W,K)}else if(K[2]>0&&$[2]<0){a(X,Y,W);const e=L.frustum,t=-S(e[T.NEAR],Y)/n(X,g(e[T.NEAR]));o(X,X,t),l(Y,Y,X),L.projectToRenderScreen(Y,$)}else if(K[2]<0&&$[2]<0)continue;K[2]=0,$[2]=0;const r=_(E(K,$,re),P);r<j&&(j=r,u(ee,W),u(te,Y),U=e/3)}const F=f.rayBegin,w=f.rayEnd;if(j<N*N){let e=Number.MAX_VALUE;if(A(E(ee,te,re),E(F,w,se),q)){a(q,q,F);const t=c(q);o(q,q,1/t),e=t/h(F,w)}R(e,q,U,!1)}}get _layout(){const e=O().vec3f(y.POSITION).f32(y.SUBDIVISIONFACTOR).vec2f(y.UV0).vec3f(y.AUXPOS1).vec3f(y.AUXPOS2);return this.parameters.vvSize?e.f32(y.SIZEFEATUREATTRIBUTE):e.f32(y.SIZE),this.parameters.vvColor?e.f32(y.COLORFEATUREATTRIBUTE):e.vec4f(y.COLOR),this.parameters.vvOpacity&&e.f32(y.OPACITYFEATUREATTRIBUTE),has("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(y.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new H(this._layout,this.parameters)}produces(e,t){if(t===b.Color||t===b.Alpha||t===b.Highlight||t===b.Depth||t===b.ObjectAndLayerIdColor){if(e===N.DRAPED_MATERIAL)return!0;if(this.parameters.renderOccluded===P.OccludeAndTransparentStencil)return e===N.OPAQUE_MATERIAL||e===N.OCCLUDER_MATERIAL||e===N.TRANSPARENT_OCCLUDER_MATERIAL;if(t===b.Color||t===b.Alpha){return e===(this.parameters.writeDepth?N.TRANSPARENT_MATERIAL:N.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL)}return e===N.OPAQUE_MATERIAL}return!1}createGLMaterial(e){return new G(e)}validateParameters(e){"miter"!==e.join&&(e.miterLimit=0),null!=e.markerParameters&&(e.markerScale=e.markerParameters.width/e.width)}}class G extends v{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==b.Color&&this._output!==b.Alpha||this._updateOccludeeState(e);const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters({stippleTexture:this._stippleTextureRepository.swap(t,this._stipplePattern)}),this._stipplePattern=t),this.ensureTechnique(w,e)}}class z extends j{constructor(){super(...arguments),this.width=0,this.color=m,this.join="miter",this.cap=J.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class H{constructor(e,t){this.vertexBufferLayout=e,this._parameters=t,this.numJoinSubdivisions=0;const r=t.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=r;break;case"round":this.numJoinSubdivisions=D+r}}_isClosed(e){return Z(this._parameters,e.attributes)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=2,r=e.attributes.get(y.POSITION).indices.length/2+1,s=this._isClosed(e);let i=s?2:2*t;return i+=((s?r:r-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),i+=2,this._parameters.wireframe&&(i=2+4*(i-2)),i}write(e,t,r,s,a){const n=ie,o=ae,l=ne,c=r.attributes.get(y.POSITION),f=c.indices,m=c.data.length/3,T=r.attributes.get(y.DISTANCETOSTART)?.data;f&&f.length!==2*(m-1)&&console.warn("RibbonLineMaterial does not support indices");let d=1,_=0;const E=this.vertexBufferLayout.fields.has(y.SIZEFEATUREATTRIBUTE);E?_=r.attributes.get(y.SIZEFEATUREATTRIBUTE).data[0]:r.attributes.has(y.SIZE)&&(d=r.attributes.get(y.SIZE).data[0]);let A=[1,1,1,1],R=0;const I=this.vertexBufferLayout.fields.has(y.COLORFEATUREATTRIBUTE);I?R=r.attributes.get(y.COLORFEATUREATTRIBUTE).data[0]:r.attributes.has(y.COLOR)&&(A=r.attributes.get(y.COLOR).data);const S=has("enable-feature:objectAndLayerId-rendering")?r.objectAndLayerIdColor:null;let g=0;const O=this.vertexBufferLayout.fields.has(y.OPACITYFEATUREATTRIBUTE);O&&(g=r.attributes.get(y.OPACITYFEATUREATTRIBUTE).data[0]);const b=new Float32Array(s.buffer),v=has("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,L=this.vertexBufferLayout.stride/4;let P=a*L;const N=P;let C=0;const j=T?(e,t,r)=>C=T[r]:(e,t,r)=>C+=h(e,t),U=has("enable-feature:objectAndLayerId-rendering"),D=(e,t,r,s,i,a,n)=>{if(b[P++]=t[0],b[P++]=t[1],b[P++]=t[2],b[P++]=s,b[P++]=n,b[P++]=i,b[P++]=e[0],b[P++]=e[1],b[P++]=e[2],b[P++]=r[0],b[P++]=r[1],b[P++]=r[2],b[P++]=E?_:d,I)b[P++]=R;else{const e=Math.min(4*a,A.length-4);b[P++]=A[e],b[P++]=A[e+1],b[P++]=A[e+2],b[P++]=A[e+3]}O&&(b[P++]=g),U&&(null!=S&&(v[4*P]=S[0],v[4*P+1]=S[1],v[4*P+2]=S[2],v[4*P+3]=S[3]),P++)};P+=L,i(o,c.data[0],c.data[1],c.data[2]),e&&p(o,o,e);const F=this._isClosed(r);if(F){const t=c.data.length-3;i(n,c.data[t],c.data[t+1],c.data[t+2]),e&&p(n,n,e)}else i(l,c.data[3],c.data[4],c.data[5]),e&&p(l,l,e),D(o,o,l,1,M.LEFT_CAP_START,0,0),D(o,o,l,1,M.RIGHT_CAP_START,0,0),u(n,o),u(o,l);const w=F?0:1,B=F?m:m-1;for(let h=w;h<B;h++){const t=(h+1)%m*3;i(l,c.data[t],c.data[t+1],c.data[t+2]),e&&p(l,l,e),j(n,o,h),D(n,o,l,0,M.LEFT_JOIN_END,h,C),D(n,o,l,0,M.RIGHT_JOIN_END,h,C);const r=this.numJoinSubdivisions;for(let e=0;e<r;++e){const t=(e+1)/(r+1);D(n,o,l,t,M.LEFT_JOIN_END,h,C),D(n,o,l,t,M.RIGHT_JOIN_END,h,C)}D(n,o,l,1,M.LEFT_JOIN_START,h,C),D(n,o,l,1,M.RIGHT_JOIN_START,h,C),u(n,o),u(o,l)}F?(i(l,c.data[3],c.data[4],c.data[5]),e&&p(l,l,e),C=j(n,o,B),D(n,o,l,0,M.LEFT_JOIN_END,w,C),D(n,o,l,0,M.RIGHT_JOIN_END,w,C)):(C=j(n,o,B),D(n,o,o,0,M.LEFT_CAP_END,B,C),D(n,o,o,0,M.RIGHT_CAP_END,B,C)),k(b,N+L,b,N,L);P=k(b,P-L,b,P,L),this._parameters.wireframe&&this._addWireframeVertices(s,N,P,L)}_addWireframeVertices(e,t,r,s){const i=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT),a=new Float32Array(e.buffer,t*Float32Array.BYTES_PER_ELEMENT,r-t);let n=0;const o=e=>n=k(a,e,i,n,s);for(let l=0;l<a.length-1;l+=2*s)o(l),o(l+2*s),o(l+1*s),o(l+2*s),o(l+1*s),o(l+3*s)}}function k(e,t,r,s,i){for(let a=0;a<i;a++)r[s++]=e[t++];return s}function Z(e,t){if(!e.isClosed)return!1;return t.get(y.POSITION).indices.length>2}function V(e){return e.anchor===U.Tip&&e.hideOnShortSegments&&"begin-end"===e.placement&&e.worldSpace}const W=f(),Y=f(),X=f(),q=f(),Q=f(),K=r(),$=r(),ee=f(),te=f(),re=d(),se=d(),ie=f(),ae=f(),ne=f(),oe=[r(),r(),r(),r()],le=[f(),f(),f(),f()],ue=R(),ce=R(),he=R(),pe=R();export{z as Parameters,x as RibbonLineMaterial};
