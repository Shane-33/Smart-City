/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{maxElevationOffset as o}from"../../../collections/Component/Material/shader/ComponentData.glsl.js";import{DoublePrecision as e}from"../../../core/shaderLibrary/util/DoublePrecision.glsl.js";import{RgbaFloatEncoding as r}from"../../../core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{Float3DrawUniform as t}from"../../../core/shaderModules/Float3DrawUniform.js";import{Float3PassUniform as a}from"../../../core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as n}from"../../../core/shaderModules/FloatPassUniform.js";import{glsl as l}from"../../../core/shaderModules/interfaces.js";import{Matrix3DrawUniform as d}from"../../../core/shaderModules/Matrix3DrawUniform.js";import{Matrix3PassUniform as m}from"../../../core/shaderModules/Matrix3PassUniform.js";import{Matrix4PassUniform as s}from"../../../core/shaderModules/Matrix4PassUniform.js";import{Texture2DDrawUniform as i}from"../../../core/shaderModules/Texture2DDrawUniform.js";import{VertexAttribute as c}from"../../../lib/VertexAttribute.js";function f(f,v){const u=f.vertex;u.include(r),u.uniforms.add(new n("distanceFalloffFactor",(o=>o.distanceFalloffFactor))),u.code.add(l`float distanceBasedPerspectiveFactor(float distance) {
return clamp(sqrt(distanceFalloffFactor / distance), 0.0, 1.0);
}`),u.uniforms.add(new i("componentDataTex",(o=>o.componentDataTexture))),f.attributes.add(c.COMPONENTINDEX,"float"),u.constants.add("componentColorFieldOffset","float",0),u.constants.add("componentOtherFieldOffset","float",1),u.constants.add("componentVerticalOffsetFieldOffset","float",2),u.constants.add("componentFieldCount","float",3),u.constants.add("lineWidthFractionFactor","float",8),u.constants.add("extensionLengthOffset","float",128),u.constants.add("verticalOffsetScale","float",2*o),u.code.add(l`vec2 _componentTextureCoords(float componentIndex, float fieldOffset) {
float fieldIndex = componentFieldCount * componentIndex + fieldOffset;
float texSize = float(textureSize(componentDataTex, 0).x);
float colIndex = mod(fieldIndex, texSize);
float rowIndex = floor(fieldIndex / texSize);
return vec2(colIndex, rowIndex) + 0.5;
}
struct ComponentData {
vec4 color;
float lineWidth;
float extensionLength;
float type;
float verticalOffset;
};
ComponentData readComponentData() {
vec2 colorIndex = _componentTextureCoords(componentIndex, componentColorFieldOffset);
vec2 otherIndex = _componentTextureCoords(componentIndex, componentOtherFieldOffset);
vec2 verticalOffsetIndex = _componentTextureCoords(componentIndex, componentVerticalOffsetFieldOffset);
vec4 colorValue = texelFetch(componentDataTex, ivec2(colorIndex), 0);
vec4 otherValue = texelFetch(componentDataTex, ivec2(otherIndex), 0);
float verticalOffset = (rgba2float(texelFetch(componentDataTex, ivec2(verticalOffsetIndex), 0)) - 0.5) * verticalOffsetScale;
return ComponentData(
vec4(colorValue.rgb, colorValue.a * otherValue.w),
otherValue.x * (255.0 / lineWidthFractionFactor),
otherValue.y * 255.0 - extensionLengthOffset,
-(otherValue.z * 255.0) + 0.5,
verticalOffset
);
}`),v.legacy?u.code.add(l`vec3 _modelToWorldNormal(vec3 normal) {
return (model * vec4(normal, 0.0)).xyz;
}
vec3 _modelToViewNormal(vec3 normal) {
return (localView * model * vec4(normal, 0.0)).xyz;
}`):(u.uniforms.add(new d("transformNormalGlobalFromModel",(o=>o.transformNormalGlobalFromModel))),u.code.add(l`vec3 _modelToWorldNormal(vec3 normal) {
return transformNormalGlobalFromModel * normal;
}`)),v.silhouette?(f.attributes.add(c.NORMALA,"vec3"),f.attributes.add(c.NORMALB,"vec3"),u.code.add(l`vec3 worldNormal() {
return _modelToWorldNormal(normalize(normalA + normalB));
}`)):(f.attributes.add(c.NORMAL,"vec3"),u.code.add(l`vec3 worldNormal() {
return _modelToWorldNormal(normal);
}`)),v.legacy?u.code.add(l`void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {
worldPos = (model * vec4(modelPos, 1.0)).xyz;
viewPos = (localView * vec4(worldPos, 1.0)).xyz;
}`):(u.include(e,v),u.uniforms.add(new m("transformViewFromCameraRelativeRS",(o=>o.transformViewFromCameraRelativeRS)),new d("transformWorldFromModelRS",(o=>o.transformWorldFromModelRS)),new t("transformWorldFromModelTL",(o=>o.transformWorldFromModelTL)),new t("transformWorldFromModelTH",(o=>o.transformWorldFromModelTH)),new a("transformWorldFromViewTL",(o=>o.transformWorldFromViewTL)),new a("transformWorldFromViewTH",(o=>o.transformWorldFromViewTH))),u.code.add(l`
      void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {
        vec3 rotatedModelPosition = transformWorldFromModelRS * modelPos;

        vec3 transformCameraRelativeFromModel = dpAdd(
          transformWorldFromModelTL,
          transformWorldFromModelTH,
          -transformWorldFromViewTL,
          -transformWorldFromViewTH
        );

        worldPos = transformCameraRelativeFromModel + rotatedModelPosition;

        if (verticalOffset != 0.0) {
          vec3 vUp = ${v.spherical?l`normalize(transformWorldFromModelTL + rotatedModelPosition);`:l`vec3(0.0, 0.0, 1.0);`}
          worldPos += verticalOffset * vUp;
        }

        viewPos = transformViewFromCameraRelativeRS * worldPos;
      }
    `)),u.uniforms.add(new s("transformProjFromView",((o,e)=>e.camera.projectionMatrix))),u.code.add(l`vec4 projFromViewPosition(vec3 position) {
return transformProjFromView * vec4(position, 1.0);
}`),u.code.add(l`float calculateExtensionLength(float extensionLength, float lineLength) {
return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);
}`)}function v(o){return o.mode===x.SKETCH||o.mode===x.MIXED}function u(o){return o.mode===x.SOLID||o.mode===x.MIXED}var x,F;!function(o){o[o.SOLID=0]="SOLID",o[o.SKETCH=1]="SKETCH",o[o.MIXED=2]="MIXED",o[o.COUNT=3]="COUNT"}(x||(x={})),function(o){o[o.REGULAR=0]="REGULAR",o[o.SILHOUETTE=1]="SILHOUETTE"}(F||(F={}));export{F as EdgeSilhouette,f as EdgeUtil,x as EdgeUtilMode,v as usesSketchLogic,u as usesSolidLogic};
