/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{s as t,h as e,e as s,g as i,a as r,i as o}from"../../../../chunks/vec2.js";import{a}from"../../../../chunks/vec2f64.js";import{s as n,b as h}from"../../../../chunks/vec3.js";import{c as l}from"../../../../chunks/vec3f64.js";import{f as u}from"../../../../chunks/vec4f64.js";import{newFloatArray as c}from"../../../../geometry/support/FloatArray.js";import{getZeroIndexArray as v}from"../../../../geometry/support/Indices.js";import{Attribute as b,Vertices as p}from"./Attribute.js";import{compressNormal as m}from"./Normals.js";import{VertexAttribute as A}from"./VertexAttribute.js";import{intersectTriangles as d}from"../materials/internal/MaterialUtil.js";class x{constructor(t){this.builder=t}onPathChanged(t){this.builder.onPathChanged()}}class f extends x{constructor(t){super(t),this.vertexAttributeColor=u(255,255,255,255),this.size=new Array,this.vertexAttributePosition=c(3*this.builder.numVerticesTotal),this.vertexAttributeNormal=new Int16Array(2*this.builder.numVerticesTotal)}bakeVertexColors(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)}bake(a){this.size=a;const{numVerticesTotal:l,pathVertexData:u,path:c,positions:v,profileRightAxes:b,profileUpAxes:p,profileVertexAndNormals:A}=this.builder;for(let d=0;d<l;++d){let l=u[d];const x=0===l||l===c.vertices.length-1;l*=3;const f=V;let g=0,N=0;const R=4*d,j=n(w,b[R],b[R+1],b[R+2]),E=n(D,p[R],p[R+1],p[R+2]),k=t(P,A[R]*a[0],A[R+1]*a[1]);if(x)h(f,E,j),g=b[R+3]*a[0],N=p[R+3];else{const a=I,h=C;t(a,b[R+3],p[R+3]);const l=e(a);s(a,a);const u=i(k,a);if(Math.abs(u)>l){t(h,-a[1],a[0]);const e=i(k,h);r(a,a,l*Math.sign(u)),r(h,h,e),o(k,a,h)}n(f,0,0,0)}const T=n(O,j[0]*k[0]+E[0]*k[1],j[1]*k[0]+E[1]*k[1],j[2]*k[0]+E[2]*k[1]),y=3*d;this.vertexAttributePosition[y]=v[l]+T[0]+f[0]*g,this.vertexAttributePosition[y+1]=v[l+1]+T[1]+f[1]*g,this.vertexAttributePosition[y+2]=v[l+2]+T[2]+f[2]*g;const L=t(P,A[R+2],A[R+3]);m(this.vertexAttributeNormal,d,j[0]*L[0]+E[0]*L[1]+f[0]*N,j[1]*L[0]+E[1]*L[1]+f[1]*N,j[2]*L[0]+E[2]*L[1]+f[2]*N)}}createGeometryData(){const t=this.builder.vertexIndices.length,{normalIndices:e,vertexIndices:s}=this.builder;return[[A.POSITION,new b(this.vertexAttributePosition,s,3,!0)],[A.NORMALCOMPRESSED,new b(this.vertexAttributeNormal,e,2,!0)],[A.COLOR,new b(this.vertexAttributeColor,v(t),4)]]}onPathChanged(t){super.onPathChanged(t),this.bake(this.size)}intersect(t,e,s){const i=this.builder.vertexIndices,r=new p(this.vertexAttributePosition,3),o=i.length/3;d(t,e,0,o,i,r,void 0,void 0,s)}}class g extends x{constructor(t,e,s,i){super(t),this.sizeAttributeValue=e,this.colorAttributeValue=s,this.opacityAttributeValue=i,this.vvData=null,this.baked=new f(t),this.vvData=c(4*this.builder.path.vertices.length);for(let r=0;r<this.builder.path.vertices.length;++r){this.vvData[4*r]=e,this.vvData[4*r+1]=s,this.vvData[4*r+2]=i;const t=0===r||r===this.builder.path.vertices.length-1;this.vvData[4*r+3]=t?1:0}}createGeometryData(){const{positions:t,profileRightAxes:e,profileUpAxes:s,profileVertexAndNormals:i,pathVertexIndices:r,vertexIndices:o}=this.builder;return[[A.POSITION,new b(t,r,3,!0)],[A.PROFILERIGHT,new b(e,o,4,!0)],[A.PROFILEUP,new b(s,o,4,!0)],[A.PROFILEVERTEXANDNORMAL,new b(i,o,4,!0)],[A.FEATUREVALUE,new b(this.vvData,r,4,!0)]]}onPathChanged(t){super.onPathChanged(t);const e=t.getMutableAttribute(A.POSITION);e&&(e.data=this.builder.positions)}}const P=a(),I=a(),C=a(),O=l(),V=l(),w=l(),D=l();export{g as FastUpdatePathGeometry,x as PathGeometryData,f as StaticPathGeometry};
