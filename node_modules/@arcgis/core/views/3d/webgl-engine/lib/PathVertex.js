/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{acosClamped as t,reciprocalClamped as s}from"../../../../core/mathUtils.js";import{s as i}from"../../../../chunks/mat2.js";import{c as r}from"../../../../chunks/mat2f64.js";import{s as h,q as e}from"../../../../chunks/vec2.js";import{U as a,a as n}from"../../../../chunks/vec2f64.js";import{c as o,g,n as m,i as f,j as c,f as u,b as p,E as v}from"../../../../chunks/vec3.js";import{c as l}from"../../../../chunks/vec3f64.js";import{Frame2D as M}from"./PathExtruder.js";import{UpVectorAlignment as R}from"./PathGeometry.js";class j{constructor(){this.vLeft=l(),this.vRight=l(),this.vMinSiblingLength=0,this.frame=new M}setFrameFromUpVector(t){o(this.frame.up,t),g(I,this.vLeft,this.vRight),m(I,I),f(y,this.frame.up,c(I,this.frame.up)),u(D,I,y),m(D,D),p(this.frame.right,D,this.frame.up)}get foldingAngle(){return Math.PI-this.rotationAngle}}class L extends j{get rotationFrameUp(){return this.frame.up}get rotationRight(){return a}get rotationAngle(){f(P,this.frame.up,c(this.frame.up,this.vLeft)),u(P,this.vLeft,P),v(P,P),m(P,P),f(w,this.frame.up,c(this.frame.up,this.vRight)),u(w,this.vRight,w),m(w,w),p(F,this.rotationFrameUp,this.vLeft);return Math.sign(c(F,this.vRight))*(Math.PI-t(c(P,w)))}get maxStretchDistance(){return Math.abs(this.vMinSiblingLength/Math.cos(.5*this.foldingAngle))}applyMiterStretch(t,i){const r=this.rotationAngle;if(Math.abs(r)<=0)return i;const e=s(Math.cos(.5*r));return h(t,(e-1+1)*i[0],i[1])}}class b extends j{get rotationFrameUp(){const t=Math.sign(c(this.frame.right,this.vRight));return p(S,this.vRight,this.vLeft),f(S,S,t),m(S,S)}get rotationRight(){const t=this.rotationFrameUp,s=c(t,this.frame.up),i=c(t,this.frame.right);return f(k,this.frame.up,-i),f(x,this.frame.right,s),g(k,k,x),m(k,k),A(U,this.frame,k),U}get rotationAngle(){const s=Math.sign(c(this.frame.right,this.vRight));return v(F,this.vLeft),-s*(Math.PI-t(c(F,this.vRight)))}get maxStretchDistance(){return Math.abs(this.vMinSiblingLength*s(Math.cos(.5*this.foldingAngle)))}applyMiterStretch(t,r){const h=this.rotationAngle;if(0===Math.abs(h))return r;const a=s(Math.cos(.5*h)),n=this.rotationRight,o=i(E,1+(a-1)*n[0]*n[0],(a-1)*n[0]*n[1],(a-1)*n[0]*n[1],1+(a-1)*n[1]*n[1]);return e(t,r,o)}}function A(t,s,i){h(t,c(i,s.right),c(i,s.up))}function d(t){switch(t){case R.World:return new L;case R.Path:return new b}}const S=l(),U=n(),k=l(),x=l(),F=l(),P=l(),w=l(),y=l(),I=l(),D=l(),E=r();export{j as PathVertex,d as newPathVertex};
