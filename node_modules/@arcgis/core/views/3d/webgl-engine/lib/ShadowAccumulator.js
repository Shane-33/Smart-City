/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import{equals as i}from"../../../../core/arrayUtils.js";import{smoothstep as r}from"../../../../core/mathUtils.js";import{disposeMaybe as s,releaseMaybe as o}from"../../../../core/maybe.js";import{watch as a,syncAndInitial as n,sync as h}from"../../../../core/reactiveUtils.js";import{property as c}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/has.js";import{subclass as _}from"../../../../core/accessorSupport/decorators/subclass.js";import{G as u,c as l}from"../../../../chunks/vec3.js";import{c as m}from"../../../../chunks/vec3f64.js";import{ReadShadowMapPassParameters as d}from"../core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{BindParameters as p}from"./BindParameters.js";import{zero as g}from"./depthRange.js";import{createQuadVAO as f}from"./glUtil3D.js";import{ShadowCastRenderer as b,shadowCastDisabledElevationThreshold as v,shadowCastDisableElevationMax as w,shadowCastDisableElevationMin as A}from"./ShadowCastRenderer.js";import{ShadowMap as y}from"./ShadowMap.js";import{S as R}from"../../../../chunks/ShadowCastAccumulate.glsl.js";import{ShadowCastAccumulateTechnique as C}from"../shaders/ShadowCastAccumulateTechnique.js";import{TaskPriority as S}from"../../../support/Scheduler.js";import{PixelFormat as D,PixelType as F,SizedPixelFormat as j,TextureWrapMode as P,ClearBufferBit as T}from"../../../webgl/enums.js";import{FramebufferObject as x}from"../../../webgl/FramebufferObject.js";import{TextureDescriptor as E}from"../../../webgl/TextureDescriptor.js";import{vertexCount as q}from"../../../webgl/Util.js";let M=class extends t{constructor(e,t,i,r,s,o){super({}),this.fbos=e,this._stage=i,this._prepareForShadowMapPass=r,this._renderToShadowMap=s,this._requestRender=o,this._progress=0,this._sampleCount=0,this._passParameters=new d,this._cachedLightDirections=[],this._depthRange=g,this._previewing=!1,this._cameraForcedForScreenshot=!1,this._shadowAccumulatorKey="shadowAccumulator",this._rctx=e.rctx,this._bindParameters=new p(new y(e,i.viewingMode),null),this._bindParameters.shadowMap.enabled=!0,this._vao=f(this._rctx),this._accumulationRenderer=new b(t,this._rctx,this,o);const c=this._stage.view.resourceController.scheduler;this.addHandles([c.registerTask(S.SHADOW_ACCUMULATOR,this),a((()=>i.renderView),(e=>{this.removeHandles(O),null!=e&&this.addHandles(e.events.on("force-camera-for-screenshot",(()=>this._cameraForcedForScreenshot=!0)),O)}),n),a((()=>this._previewing),(()=>this._requestRenderIfEnabled()),h)],this._shadowAccumulatorKey)}normalizeCtorArgs(){return{}}dispose(){this._disable(),this.removeHandles(this._shadowAccumulatorKey),this._accumulationRenderer=s(this._accumulationRenderer),this._bindParameters.shadowMap.dispose(),this._fbo=s(this._fbo),this._vao=s(this._vao),this._accumulationTechniqueCached=o(this._accumulationTechniqueCached),this._cachedLightDirections.length=0,this._sampleCount=0}get computedSamples(){return this._progress}get shadowCastTexture(){return this._fbo?.colorTexture}get isAccumulating(){return this._isPreviewing||this._isRefining}get _accumulationTechnique(){if(null==this._accumulationTechniqueCached){const e={rctx:this._rctx,viewingMode:this._stage.viewingMode};this._accumulationTechniqueCached=new C(e)}return this._accumulationTechniqueCached}get _isRefining(){return this._isActive&&!this._isDoneAccumulating&&!this._previewing}get _isPreviewing(){return this._isActive&&this._previewing}get _isActive(){return null!=this._fbo&&this._sampleCount>0}get canAccumulate(){return null!==this._bindParameters.linearDepth?.colorTexture&&this._depthRange!==g&&this._opacityFromElevation>v}get _isDoneAccumulating(){return this._progress>=this._sampleCount}get _lightDirections(){return this._cachedLightDirections}set _lightDirections(e){const t=this._cachedLightDirections;if(i(t,e,u))return;const r=Math.min(R,e.length);t.length=r,this._sampleCount=r;for(let i=0;i<r;++i)t[i]=l(t[i]??m(),e[i]);this._invalidate()}get _opacityFromElevation(){return this._accumulationRenderer.opacityFromElevation}set _opacityFromElevation(e){this._accumulationRenderer.opacityFromElevation=e}get running(){return this._isRefining&&this.canAccumulate&&this._progress>0}runTask(e){for(this._prepareForShadowMapPass(this._bindParameters);!e.done&&!this._isDoneAccumulating;)this._accumulateShadow(),e.madeProgress();this._requestRender()}renderAccumulation(e,t,i,r){if(this._depthRange=t,this._updateCamera(i),this._bindParameters.contentCamera=r,this._bindParameters.linearDepth=e,this._passParameters.origin=this._bindParameters.camera.center,this.notifyChange("canAccumulate"),!this.isAccumulating||!this.canAccumulate)return;(this._previewing||0===this._progress||this._cameraForcedForScreenshot)&&this._clear();const s=this._cameraForcedForScreenshot?this._sampleCount:Math.min(U,this._sampleCount-this._progress);for(let o=0;o<s;++o)this._accumulateShadow();this._cameraForcedForScreenshot=!1,this._requestRender()}render(e){this._accumulationRenderer.render(e)}setOptions(e){if(void 0!==e.enabled){const t=null!=this._fbo;e.enabled!==t&&(e.enabled?this._enable():this._disable())}void 0!==e.previewing&&(this._previewing=e.previewing),void 0!==e.lightDirections&&(this._lightDirections=e.lightDirections),this._accumulationRenderer.setOptions(e)}readAccumulatedShadow(e,t){return!this._isActive||!this._fbo||this._progress<1||e<0||e>=this._fbo.width||t<0||t>=this._fbo.height?0:(this._fbo.readPixels(e,t,1,1,D.RED,F.UNSIGNED_BYTE,L),L[0]/this._progress)}_enable(){this._progress=0;const e=new E;e.pixelFormat=D.RED,e.internalFormat=j.R8,e.wrapMode=P.CLAMP_TO_EDGE,this._fbo=new x(this._rctx,e)}_disable(){this._fbo=s(this._fbo)}_invalidate(){this._progress=0,this._requestRenderIfEnabled()}_clear(){this._rctx.bindFramebuffer(this._fbo),this._rctx.setClearColor(0,0,0,0),this._rctx.clearSafe(T.COLOR_BUFFER_BIT),this._progress=0}_accumulateShadow(){this._renderToShadowMap(this._bindParameters,this._lightDirections[this._progress++],this._depthRange);const e=this._accumulationTechnique;this._rctx.bindFramebuffer(this._fbo),this._rctx.bindTechnique(e,this._passParameters,this._bindParameters),this._rctx.bindVAO(this._vao),this._rctx.drawArrays(e.primitiveType,0,q(this._vao,"geometry"))}_updateCamera(e){!e.equals(this._bindParameters.camera)&&this._fbo&&(this._bindParameters.camera.copyFrom(e),this._fbo.resize(e.fullWidth,e.fullHeight),this._opacityFromElevation=1-r(A,w,e.relativeElevation))}_requestRenderIfEnabled(){this._fbo&&this._requestRender()}get test(){const e=this;return{lightDirections:this._lightDirections,get isDone(){return e._isDoneAccumulating},get isActive(){return e._isActive}}}};e([c()],M.prototype,"_progress",void 0),e([c()],M.prototype,"_sampleCount",void 0),e([c()],M.prototype,"_fbo",void 0),e([c()],M.prototype,"_depthRange",void 0),e([c()],M.prototype,"_previewing",void 0),e([c()],M.prototype,"_accumulationRenderer",void 0),e([c()],M.prototype,"_isRefining",null),e([c()],M.prototype,"_isActive",null),e([c()],M.prototype,"canAccumulate",null),e([c()],M.prototype,"_isDoneAccumulating",null),e([c()],M.prototype,"_opacityFromElevation",null),e([c()],M.prototype,"running",null),M=e([_("esri.views.3d.webgl-engine.lib.ShadowAccumulator")],M);const U=6,O="renderView",L=new Uint8Array(1);export{M as ShadowAccumulator};
