/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{h as t,m as e,y as i}from"../../../../chunks/mat4.js";import{I as s,a as r}from"../../../../chunks/mat4f64.js";import{p as o,e as n,o as a,s as h,g as m,h as c,c as l}from"../../../../chunks/vec3.js";import{f as d,c as u}from"../../../../chunks/vec3f64.js";import{c as g}from"../../../../chunks/sphere.js";import{maxScale as f}from"../../support/mathUtils.js";import{Object3DState as _}from"./basicInterfaces.js";import{ContentObject as b}from"./ContentObject.js";import{ContentObjectType as p}from"./ContentObjectType.js";import{Object3DStateID as v}from"./Object3DStateID.js";import{assert as y}from"./Util.js";import{affectsGeometry as j}from"./VertexAttribute.js";import{addObject3DStateID as S,removeObject3DStateID as x}from"../materials/renderers/utils.js";class V extends b{get geometries(){return this._geometries}get transformation(){return this._transformation??s}set transformation(e){this._transformation=t(this._transformation??r(),e),this._invalidateBoundingVolume(),this._emit("transformationChanged",this)}get shaderTransformation(){return this._shaderTransformation}set shaderTransformation(e){this._shaderTransformation=e?t(this._shaderTransformation??r(),e):null,this._invalidateBoundingVolume(),this._emit("shaderTransformationChanged",this)}get effectiveTransformation(){return this.shaderTransformation??this.transformation}constructor(t={}){super(),this.type=p.Object,this._shaderTransformation=null,this._parentLayer=null,this._visible=!0,this.castShadow=t.castShadow??!0,this.usesVerticalDistanceToGround=t.usesVerticalDistanceToGround??!1,this.graphicUid=t.graphicUid,this.layerUid=t.layerUid,t.isElevationSource&&(this.lastValidElevationBB=new O),this._geometries=t.geometries?Array.from(t.geometries):new Array}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(t){y(null==this._parentLayer||null==t,"Object3D can only be added to a single Layer"),this._parentLayer=t}addGeometry(t){t.visible=this._visible,this._geometries.push(t),this._emit("geometryAdded",{object:this,geometry:t}),this._invalidateBoundingVolume()}removeGeometry(t){const e=this._geometries.splice(t,1)[0];e&&(this._emit("geometryRemoved",{object:this,geometry:e}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttributeUpdated(t,e,i=!1){this._emit("attributesChanged",{object:this,geometry:t,attribute:e,sync:i}),j(e)&&this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(t){if(this._visible!==t){this._visible=t;for(const t of this._geometries)t.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const t=new v(_.MaskOccludee);for(const e of this._geometries)e.occludees=S(e.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const e of this._geometries)e.occludees=x(e.occludees,t);this._emit("occlusionChanged",this)}highlight(){const t=new v(_.Highlight);for(const e of this._geometries)e.highlights=S(e.highlights,t);return this._emit("highlightChanged",this),t}removeHighlight(t){for(const e of this._geometries)e.highlights=x(e.highlights,t);this._emit("highlightChanged",this)}getCombinedStaticTransformation(t,i){return e(i,this.transformation,t.transformation)}getCombinedShaderTransformation(t,i=r()){return e(i,this.effectiveTransformation,t.transformation)}get boundingVolumeWorldSpace(){return this._bvWorldSpace||(this._bvWorldSpace=this._bvWorldSpace||new A,this._validateBoundingVolume(this._bvWorldSpace,U.WorldSpace)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace||(this._bvObjectSpace=this._bvObjectSpace||new A,this._validateBoundingVolume(this._bvObjectSpace,U.ObjectSpace)),this._bvObjectSpace}_validateBoundingVolume(t,e){const i=e===U.ObjectSpace;for(const s of this._geometries){const e=s.boundingInfo;e&&M(e,t,i?s.transformation:this.getCombinedShaderTransformation(s))}o(t.bounds,t.min,t.max,.5);for(const s of this._geometries){const e=s.boundingInfo;if(null==e)continue;const r=i?s.transformation:this.getCombinedShaderTransformation(s),o=f(r);n(B,e.center,r);const h=a(B,t.bounds),m=e.radius*o;t.bounds[3]=Math.max(t.bounds[3],h+m)}}_invalidateBoundingVolume(){const t=this._bvWorldSpace?.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this._parentLayer&&t&&this._parentLayer.notifyObjectBBChanged(this,t)}_emit(t,e){this._parentLayer&&this._parentLayer.events.emit(t,e)}get test(){const t=this;return{hasGeometry:e=>t._geometries.includes(e),getGeometryIndex:e=>t._geometries.indexOf(e)}}}class O{constructor(){this.min=d(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=d(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class A extends O{constructor(){super(...arguments),this.bounds=g()}}function M(t,e,s){const r=t.bbMin,o=t.bbMax;if(i(s)){const t=h(L,s[12],s[13],s[14]);m(T,r,t),m(C,o,t);for(let i=0;i<3;++i)e.min[i]=Math.min(e.min[i],T[i]),e.max[i]=Math.max(e.max[i],C[i])}else if(n(T,r,s),c(r,o))for(let i=0;i<3;++i)e.min[i]=Math.min(e.min[i],T[i]),e.max[i]=Math.max(e.max[i],T[i]);else{n(C,o,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],T[t],C[t]),e.max[t]=Math.max(e.max[t],T[t],C[t]);for(let t=0;t<3;++t){l(T,r),l(C,o),T[t]=o[t],C[t]=r[t],n(T,T,s),n(C,C,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],T[t],C[t]),e.max[t]=Math.max(e.max[t],T[t],C[t])}}}const L=u(),T=u(),C=u(),B=u();var U;!function(t){t[t.WorldSpace=0]="WorldSpace",t[t.ObjectSpace=1]="ObjectSpace"}(U||(U={}));export{V as Object3D};
