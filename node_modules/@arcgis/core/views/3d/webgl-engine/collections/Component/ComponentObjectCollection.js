/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import has from"../../../../../core/has.js";import e from"../../../../../core/Logger.js";import t from"../../../../../core/PooledArray.js";import{isArray as o}from"../../../../../core/typedArrayUtil.js";import{d as n,t as r}from"../../../../../chunks/mat3.js";import{c as i}from"../../../../../chunks/mat3f32.js";import{a as s,u as a,t as c}from"../../../../../chunks/vec3.js";import{g as l,c as m}from"../../../../../chunks/vec3f64.js";import{compactIndices as f}from"../../../../../geometry/support/Indices.js";import{b as p}from"../../../../../chunks/vec32.js";import{c as h}from"../../../../../chunks/vec33.js";import{ViewingMode as u}from"../../../../ViewingMode.js";import{ColorMixModeEnum as b,encodeSymbolColor as g}from"../../../layers/support/symbolColorUtils.js";import{clone as d,computeOffsetObb as y,radius as j}from"../../../support/orientedBoundingBox.js";import{glLayout as C}from"../../../support/buffer/glUtil.js";import{newLayout as v}from"../../../support/buffer/InterleavedLayout.js";import _ from"./ComponentData.js";import{State as w,ComponentObject as M}from"./ComponentObject.js";import O from"./IntersectionGeometry.js";import{Renderable as x}from"./Renderable.js";import{RenderGeometry as A}from"./RenderGeometry.js";import{RenderSubmitSystem as D}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as S}from"./SourceGeometry.js";import{UniformComponentParameters as I}from"./UniformComponentParameters.js";import{ComponentParametersVarying as P,ComponentParametersUniform as E,ComponentParameterSummary as L,ComponentMaterial as R}from"./Material/ComponentMaterial.js";import{attributeLocations as U}from"./Material/ComponentTechnique.js";import{encodeElevationOffset as B}from"./Material/shader/ComponentData.glsl.js";import{getVisibility as T,updateVisibilityWithCount as V}from"../../lib/ComponentUtils.js";import{assert as k}from"../../lib/Util.js";import{VertexAttribute as G}from"../../lib/VertexAttribute.js";import{getVerticalOffsetI3S as N}from"../../lib/verticalOffsetUtils.js";import{EdgeInputBufferLayout as q}from"../../lib/edgeRendering/bufferLayouts.js";import{extractComponentsEdgeLocationsLayout as H}from"../../lib/edgeRendering/edgeProcessing.js";import{BufferManager as W}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as X}from"../../../../webgl/BufferObject.js";import{Usage as Y,PrimitiveType as z}from"../../../../webgl/enums.js";import{VertexArrayObject as F}from"../../../../webgl/VertexArrayObject.js";const J=e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class K{constructor(e,o){this._renderManager=e,this._viewingMode=o,this._objects=[new t,new t],this._renderSubmit=new D(this),this._renderManager.register(this._renderSubmit),this._hasObjectAndLayerId=has("enable-feature:objectAndLayerId-rendering"),this._componentBufferManager=new W(e.rctx,2+(this._hasObjectAndLayerId?1:0))}destroy(){k(0===this._objects[w.Hidden].length&&0===this._objects[w.Visible].length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy();const e=this._objects.flatMap((e=>e.toArray()));for(const t of e)t?.destroy()}createObject(e){const t=new M;return t.toMapSpace=e.toMapSpace,t.transform=e.transform,t.obb=d(e.obb),t.components=new _(this._componentBufferManager,f(e.geometry.componentOffsets)),t.renderable=this._createRenderable(e,t.components),t.intersectionGeometry=new O(e.geometry.positionData,t.components),this._objects[t.visible].push(t),t}destroyObject(e){const t=e;this._objects[t.visible].removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;t!==o.visible&&(this._objects[o.visible].removeUnordered(o),this._objects[t].push(o),o.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=s(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.components.visibility.reset(t),o.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.components.visibility.componentCount();return{visible:o,invisible:t.components.count-o}}setComponentData(e,t){const o=e,n=o.renderable.material,r=o.components,i=r.materialDataBuffer,s=r.materialDataIndices,a=new I,c=i.textureBuffer,l=new Uint8Array(4),m=new Uint32Array(l.buffer);let f=0,p=0,h=0,u=r.verticalOffsets,j=1/0,C=-1/0,v=!1,_=!1,w=0;for(let d=0;d<r.count;d++){t(d,a),f+=+(a.externalColor[3]<1),p+=+(a.externalColorMixMode===b.Replace&&1===a.externalColor[3]),h+=+a.castShadows,g(a.externalColor,a.externalColorMixMode,l),l[2]=254&l[2]|+a.castShadows,c.setData(s[d],0,l[0],l[1],l[2],l[3]),v||=d>0&&w!==m[0],w=m[0],_||=0!==a.elevationOffset,_&&null==u&&(u=new Array(d).fill(0)),null!=u&&(u[d]=a.elevationOffset),j=Math.min(j,a.elevationOffset),C=Math.max(C,a.elevationOffset),B(a.elevationOffset,l),c.setData(s[d],1,l[0],l[1],l[2],l[3]);const e=a.objectAndLayerIdColor;null!=e&&c.setData(s[d],2,e[0],e[1],e[2],e[3]),a.pickable!==T(r.pickability,d)&&(r.pickability=V(r.pickability,r.count,d,a.pickable))}r.verticalOffsets=_?u:null,o.offsetObb=_?y(o.obb,j,C,this._viewingMode,null!=o.offsetObb?o.offsetObb:d(o.obb)):null,v||_||this._hasObjectAndLayerId?(n.componentParameters=new P,n.componentParameters.castShadows=Z(h,r.count),n.componentParameters.transparent=Z(f,r.count),n.componentParameters.opaqueOverride=Z(p,r.count),n.componentParameters.texture=c,c.updateTexture()):(n.componentParameters=new E,n.componentParameters.castShadows=a.castShadows?L.All:L.None,n.componentParameters.externalColor=a.externalColor,n.componentParameters.externalColorMixMode=a.externalColorMixMode),this._notifyDirty()}getComponentAabb(e,t,o,n=!1){e.intersectionGeometry.getComponentAabb(t,o);const r=e,i=r.components.verticalOffsets;if(n||null==i)return o;const s=i[t];if(this._viewingMode===u.Local||0===s)return o[2]+=s,o[5]+=s,o;const a=N(s);return a.localOrigin=r.transform.position,a.applyToAabb(o)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}intersect(e,t,o,i,s,l){const m=e;null!=s&&(s.localOrigin=m.transform.position);const f=n($,m.transform.rotationScale);a(ee,t,m.transform.position),a(te,o,m.transform.position),c(ee,ee,f),c(te,te,f);const p=r($,f);return m.intersectionGeometry.intersect(ee,te,i,p,s,m.components.verticalOffsets,l)}addEdges(e,t,o,n){const r=e,{indices:i,positions:s}=r.intersectionGeometry,a=r.components.offsets;return t.addComponentObject(e,r.transform,{center:r.obb.center,radius:j(r.obb)},s,i,a,o,n)}async extractEdgeInformation(e,t,o){const n=e,r=n.components.visibility;if(r.allInvisible())return{buffer:H.createBuffer(0),origin:[0,0,0]};const{indices:i,positions:s}=n.intersectionGeometry,a=n.components.offsets,c=q.createBuffer(s.length/3);h(c.position.typedBuffer,s,c.position.typedBufferStride,3),p(c.position,c.position,n.transform.rotationScale),this._setComponentIndices(c.componentIndex,i,a);const m=c.count,f=this._computeVisibilityIndices(i,r,a,m);return{origin:l(n.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:f,indicesLength:f.length,skipDeduplicate:!0,data:c,writerSettings:{reducedPrecision:!1,variants:0}},o)}}_setComponentIndices(e,t,o){let n=0;for(let r=0;r<o.length-1;r++){const i=o[r],s=o[r+1];for(let o=i;o<s;o++){const r=t?t[o]:o;e.set(r,n)}n++}}_computeVisibilityIndices(e,t,n,r){if(e&&t.allVisible())return e;let i=0;t.forEachComponentRange(((e,t)=>(i+=n[t]-n[e],!0)));const s=o(e)?new Array(i):2===e?.BYTES_PER_ELEMENT||r<=65536?new Uint16Array(i):new Uint32Array(i);let a=0;return t.forEachComponentRange(((t,o)=>{const r=n[t],i=n[o];for(let n=r;n<i;n++)s[a++]=e?e[n]:n;return!0})),s}addComponentHighlight(e,t){const o=e.components;null==o.highlightCounts&&(o.highlightCounts=new Uint32Array(o.count+1));0===o.highlightCounts[t]++&&(o.highlightsDirty(),this._notifyDirty()),o.highlightCounts[o.count]++}removeComponentHighlight(e,t){const o=e.components;if(null==o.highlightCounts)return void J.warn("Removing non-existing highlight.");const n=o.highlightCounts[t],r=o.highlightCounts[o.count];if(0!==n){if(n>1)return o.highlightCounts[t]=n-1,void(o.highlightCounts[o.count]=r-1);o.highlightCounts[t]=0,o.highlightsDirty(),this._notifyDirty(),1===r?o.highlightCounts=null:o.highlightCounts[o.count]=r-1}else J.warn("Removing non-existing highlight.")}clearHighlights(e){const t=e.components;null!=t.highlightCounts&&(t.highlightCounts=null,t.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._objects[w.Visible]}_createRenderable(e,t){const o=this._renderManager.rctx,n=e.geometry,r=n.vertices.layoutParameters,i=X.createVertex(o,Y.STATIC_DRAW,n.vertices.data),s=n.indices?X.createIndex(o,Y.STATIC_DRAW,n.indices):null,a=C(S(r)),c=new Uint16Array(n.vertices.count);for(let u=0;u<t.count;u++){const e=t.offsets[u],o=t.offsets[u+1],r=t.materialDataIndices[u];if(null!=n.indices)for(let t=e;t<o;t++){c[n.indices[t]]=r}else for(let t=e;t<o;t++)c[t]=r}const l=X.createVertex(o,Y.STATIC_DRAW,c.buffer),m=new R(e.transform,e.toMapSpace),f=new F(o,U,{data:a,componentIndices:Q},{data:i,componentIndices:l},s),p=new A(f,z.TRIANGLES,r,null!=s),h={cameraDepthSquared:.5,gpuMemoryEstimate:i.byteLength+l.byteLength+(null!=s?s.byteLength:0)};return new x(m,p,h)}_notifyDirty(){this._renderManager.notifyDirty()}}const Q=C(v().u16(G.COMPONENTINDEX));function Z(e,t){return e===t?L.All:0===e?L.None:L.Some}const $=i(),ee=m(),te=m();export{K as ComponentObjectCollection};
