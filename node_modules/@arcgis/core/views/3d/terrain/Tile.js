/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../core/mathUtils.js";import{abortMaybe as t}from"../../../core/maybe.js";import i from"../../../core/ObjectPool.js";import{j as s,s as n}from"../../../chunks/vec2.js";import{a as r}from"../../../chunks/vec2f64.js";import{f as a,m as o,j as l,i as h,g as u,l as d,c}from"../../../chunks/vec3.js";import{c as g,u as p}from"../../../chunks/vec3f64.js";import{g as f}from"../../../chunks/common.js";import{getReferenceEllipsoid as m}from"../../../geometry/ellipsoidUtils.js";import{create as _,equals as y}from"../../../geometry/support/aaBoundingRect.js";import{c as A}from"../../../chunks/sphere.js";import{isGroupLayer as T}from"../../../layers/support/layerUtils.js";import{VectorTile as E}from"../../2d/engine/vectorTiles/VectorTile.js";import{ImageWithType as v}from"../support/StreamDataLoader.js";import{ElevationBounds as I}from"./ElevationBounds.js";import{ElevationTileAgent as M}from"./ElevationTileAgent.js";import{TextureUpdate as D}from"./interfaces.js";import{TileFrustumVisibility as L,NeighborIndex as x}from"./ITile.js";import{LayerClasses as S,LayerClass as O}from"./LayerClass.js";import{MapTileAgent as j}from"./MapTileAgent.js";import{RasterTile as N}from"./RasterTile.js";import{maxPatchTesselation as U,getElevationDesiredResolutionLevel as b}from"./TerrainConst.js";import{weakAssert as C,getLayerWithExtentRange as P,isBlendableLayerView as B,oppositeCorner as R,internalAssert as V,enableTerrainInternalChecks as w,neighborEdgeIndices as G,oppositeEdge as W,neighborCornerIndices as q,isNorth as F,isSouth as H,isWest as k,isEast as X,enableWaterproofnessTests as Y,almostEquals as z,isWestCorner as $,isNorthCorner as J}from"./terrainUtils.js";import{tileAgentDone as Q}from"./TileAgent.js";import{TilePerLayerInfo as K}from"./TilePerLayerInfo.js";import Z from"./TileTexture.js";import{TileUpdate as ee}from"./TileUpdate.js";import{fallsWithinLayer as te}from"./tileUtils.js";const ie=.1;class se{constructor(){this.lij=[0,0,0],this._children=[null,null,null,null],this._pendingUpdates=0,this.renderData=null,this._dirty=!0,this._previouslyRendered=!1,this.extent=_(),this._elevationBounds=r(),this.layerInfo=[[],[]],this.extentInRadians=_(),this.centerAtSeaLevel=g(),this._center=[g(),A(),g()],this.up=p(),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._maxTesselation=0,this._usedMemory=null,this._mapTileMemoryInternal=0,this._mapDataRefCount=0,this.screenDepth=0,this.renderOrder=0,this._edgeLen=0,this._edgeLen2=0,this._curvatureHeight=0,this.extentMidX=0,this.extentMidY=0,this.distanceToPOI=-1,this._lastPOI=g()}static prune(){ae.prune(0),oe.prune(0),K.prune()}get _isCached(){return!this.shouldLoad&&this._mapDataRefCount<=0}get maxTesselation(){return this._maxTesselation}get isWithinClippingArea(){return this._isWithinClippingArea}get intersectsClippingArea(){return this._intersectsClippingArea}get clippingArea(){return this._clippingArea}get parent(){return this._parent}get children(){return this._children}get surface(){return this._surface}get elevationBounds(){return this._elevationBounds}get level(){return this.lij[0]}get key(){return`${this.lij[0]}/${this.lij[1]}/${this.lij[2]}`}get edgeLen(){return this._edgeLen}get radius(){return this._center[he.MIDDLE][3]}get visible(){return this._dirty&&this.computeVisibility(),this._visible}get frustumVisibility(){return this._dirty&&this.computeVisibility(),this._frustumVisibility}computeVisibility(){this._dirty=!1;const e=this.parent,t=e?.frustumVisibility??L.INTERSECTS;this._frustumVisibility=t===L.INSIDE?L.INSIDE:t===L.OUTSIDE?L.OUTSIDE:this._calculateFrustumVisibilityStatus(this.surface.frustum);const i=this._frustumVisibility!==L.OUTSIDE&&this._intersectsClippingArea;i!==this._visible&&(this._visible=i,this._surface.emit("tiles-visibility-changed"),this._surface.renderer.setDirty(),this.updateAgentSuspension())}get loadable(){return this.visible||this._surface.view.state.fixedContentCamera}get rendered(){const e=!!this.renderData;return e!==this._previouslyRendered&&(this._surface.emit("tiles-visibility-changed"),this._previouslyRendered=e,this._surface.renderer.setDirty()),e}get shouldLoad(){return this.isLeaf}init(e,t,i,r,a){this.lij[0]=e,this.lij[1]=t,this.lij[2]=i,this.ellipsoid=m(a.tilingScheme.spatialReference),a.tilingScheme.getExtent(e,t,i,this.extent),a.tilingScheme.convertExtentToRadians(this.extent,this.extentInRadians),this.extentMidX=.5*(this.extent[0]+this.extent[2]),this.extentMidY=.5*(this.extent[1]+this.extent[3]),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._clippingArea=null,this._mapDataRefCount=0,a.upsampleMapCache.pop(this.key),this._edgeLen=0,this._edgeLen2=0,this._center[he.MIDDLE][3]=0,this.elevationLevel=e,r&&r.elevationBounds?s(this._elevationBounds,r.elevationBounds):n(this._elevationBounds,0,0),this._pendingUpdates=0,this.renderData=null,this.screenDepth=0,this._visible=!1,this._previouslyRendered=!1,this._parent=r,this.unsetChildren(),this._surface=a,this.updateVisibility();for(const s of S){const e=a.numLayers(s),t=this.layerInfo[s];for(const i of t)i.release();t.length=e;for(let i=0;i<e;i++)t[i]=K.acquire(this._surface.upsampleInfoPool),s===O.ELEVATION&&this.findElevationBoundsForLayer(i,-1)}this.computeElevationBounds(),this._maxTesselation=Math.min(a.tilingScheme.pixelSize,U)}dispose(){C(!this.renderData,"tile.renderData was not unloaded"),this._surface.upsampleMapCache.pop(this.key);for(const e of S){for(const t of this.layerInfo[e])t.release();this.layerInfo[e].length=0}this._parent=null;for(let e=0;e<4;++e)this._children[e]=null;this._surface=null,this.setMemoryDirty()}refMapData(){++this._mapDataRefCount,this._isCached||this._surface.upsampleMapCache.pop(this.key)}unrefMapData(){if(--this._mapDataRefCount,this._isCached){this.setMemoryDirty();const e=this._cachedMemory;e>0&&this._surface.upsampleMapCache.put(this.key,this,e)}}setMemoryDirty(){this._usedMemory=null}get usedMemory(){return this._ensureUsedMemory()+(this._isCached?0:this._mapTileMemoryInternal)}get _cachedMemory(){return this._isCached?this._mapTileMemory:0}get _mapTileMemory(){return this._ensureUsedMemory(),this.layerInfo[O.MAP].reduce(((e,t)=>e+(t instanceof E?t.memoryUsed/t.referenced:0)),this._mapTileMemoryInternal)}get _cpuImageMemorySize(){const e=4,t=this._surface.tilingScheme.pixelSize;return t*t*e}_ensureUsedMemory(){if(null!=this._usedMemory)return this._usedMemory;this._usedMemory=this._baseUsedMemory,this._mapTileMemoryInternal=0;let e=0;for(const{data:i}of this.layerInfo[O.MAP])i instanceof E?e+=this._getTerrainDataMemory(i):this._mapTileMemoryInternal+=this._getTerrainDataMemory(i);const t=this._cpuImageMemorySize;for(const i of this.layerInfo[O.ELEVATION])this._usedMemory+=i.data?t:0;return this.renderData&&(this._usedMemory+=this.renderData.estimatedGeometryMemoryUsage,this._mapTileMemoryInternal+=this.renderData.texture?.usedMemory??0),this._isCached&&this._surface.upsampleMapCache.updateSize(this.key,this,this._mapTileMemoryInternal+e),this._usedMemory}getUsedMemoryForLayer(e,t){const i=this.layerInfo[e][t];return i?.data?e===O.MAP?this._isCached?0:this._getTerrainDataMemory(i.data):e===O.ELEVATION?this._cpuImageMemorySize:0:0}_getTerrainDataMemory(e){return e instanceof Z?e.texture.gpuMemoryUsage:e instanceof HTMLImageElement||e instanceof v?this._cpuImageMemorySize:e instanceof N?e.memoryUsage:e instanceof E?e.memoryUsed/e.referenced:0}updateScreenDepth(e){const t=this._center[he.MIDDLE],i=e,s=t[0],n=t[1],r=t[2],a=i[2]*s+i[6]*n+i[10]*r+i[14];this.screenDepth=a<0?0:a/(i[3]*s+i[7]*n+i[11]*r+i[15])}shouldSplit(e,t,i){if(!this.visible)return ee.NONE;if(e.frustum&&(!this._intersectsClippingArea||this._calculateFrustumVisibilityStatus(e.frustum)===L.OUTSIDE))return ee.NONE;const s=this.level;a(me,this._center[he.MIDDLE],t);let n=o(me),r=me,c=he.MIDDLE;a(_e,this._center[he.TOP],t);const g=o(_e);g<n&&(n=g,r=_e,c=he.TOP),a(ye,this._center[he.BOTTOM],t);const p=o(ye);if(p<n&&(n=p,r=ye,c=he.BOTTOM),this._edgeLen2>n&&s<e.maxLod)return ee.SPLIT;const f=null!=i?i-s:1/0,m=Math.sqrt(n),_=e.fovX*m*2,y=this._edgeLen/_,A=()=>{if(s<e.maxLod)return this.elevationLevel=s,ee.NONE;const t=s+Math.ceil(-Math.log2(e.relativeWidthLimit/y));return t!==this.elevationLevel?(this.elevationLevel=t,ee.ELEVATION):ee.NONE};if(f<=.5)return A();const T=l(this.up,me),E=this._elevationBounds[1]-this._elevationBounds[0],v=E/this.edgeLen;if(e.aboveGround&&T>0&&v<.001){if(T/m-Math.sin(this._curvatureHeight/(this.edgeLen*Math.SQRT1_2)*Math.PI)-v>0)return ee.NONE}const I=null!=i?3-Math.min(f,2):1;if(y*I<e.relativeWidthLimit||s>=e.maxLod)return A();if(s<7)return ee.SPLIT;h(Ae,this.up,T),a(Ae,Ae,r);const M=o(Ae);if(M<=this.radius*this.radius)return ee.SPLIT;h(Ae,Ae,this.radius/Math.sqrt(M)),u(Ae,Ae,this._center[c]),a(Ae,t,Ae);const D=Math.min(1,(Math.abs(l(Ae,this.up))+.5*E+this._curvatureHeight)/d(Ae)),x=ie/e.angledSplitBias,S=e.fovY*m*2;return D*(this._edgeLen/S*I)<x*e.relativeHeightLimit?ee.NONE:ee.SPLIT}setChildren(e,t,i,s){C(!!(e&&t&&i&&s),"Null child passed"),this._children[0]=e,this._children[1]=t,this._children[2]=i,this._children[3]=s}unsetChildren(){this._children[0]=null,this._children[1]=null,this._children[2]=null,this._children[3]=null}get isLoaded(){return this.renderData?.hasGeometry??!1}load(){this.refMapData();for(const e of S)this._createOrUpdateAgents(0,e);this.surface.renderer.loadTile(this)}unload(e){e.unloadTile(this);for(const t of S){const e=this.layerInfo[t];for(const t of e)t.loadingAgent&&t.loadingAgent!==Q&&(re(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0}this.resetPendingUpdate(ee.GEOMETRY),this.resetPendingUpdate(ee.TEXTURE_NOFADING),this.resetPendingUpdate(ee.TEXTURE_FADING),this.unrefMapData()}unloadMapData(){const e=this.layerInfo[O.MAP];for(const t of e)t.loadingAgent&&t.loadingAgent!==Q&&(re(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0;this.renderData&&this.renderData.releaseTexture(),this.setMemoryDirty()}updateClippingStatus(e){if(y(e,this._clippingArea))return!1;const t=this._intersectsClippingArea,i=this._isWithinClippingArea;null!=e?(this._intersectsClippingArea=this.intersectsExtent(e),this._isWithinClippingArea=this._isWithinExtent(e)):(this._intersectsClippingArea=!0,this._isWithinClippingArea=!0),this._clippingArea=e,this.updateVisibility();const s=i&&this._isWithinClippingArea,n=!(i||t||this._isWithinClippingArea||this._intersectsClippingArea);return!this.renderData||s||n||this.setPendingUpdate(ee.GEOMETRY),!0}updateVisibility(){this._dirty=!0,this._surface.setTileTreeDirty()}getLayerInfo(e,t){return this.layerInfo[t][e]}hasLayerData(e,t){const i=this.layerInfo[t][e];return!(!i?.data||i.dataInvalidated)}get updating(){if(this.hasPendingUpdates)return!0;for(const e of S){const t=this.layerInfo[e];for(const e of t)if(e.loadingAgent&&e.loadingAgent!==Q&&e.loadingAgent.updating)return!0}return!1}_isSuspended(e){return!!this.hasPendingUpdate(ee.SPLIT)||e!==O.ELEVATION&&!this.loadable}get hasPendingUpdates(){return 0!==this._pendingUpdates}hasPendingUpdate(e){return(this._pendingUpdates&e)===e}setPendingUpdate(e){this._pendingUpdates|=e,e===ee.SPLIT||e===ee.MERGE?this._surface.setTileTreeDirty():this._surface.requestUpdate()}resetPendingUpdate(e){return!!this.hasPendingUpdate(e)&&(this._pendingUpdates&=~e,!0)}requestLayerData(e,i,s){const n=this.layerInfo[i][e];if(n.waitingAgents.has(s))return console.warn("agent already requested this piece of map data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),i,e),!0;if(n.waitingAgents.push(s),n.data&&!n.dataInvalidated){console.warn("agent requested existing data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),i,e);const t=n.data&&"type"in n.data&&"vector-tile"===n.data.type;return s.dataArrived(this,t),!0}if(n.requestPromise)return!0;t(n.requestAbort),n.requestAbort=new AbortController;const r=this._surface.requestTileData(this,e,i,n.requestAbort);if(!r)return n.requestAbort=null,!1;const a=()=>{n.requestPromise===r&&(n.requestPromise=null,n.requestAbort=null)};return n.requestPromise=r,r.then(a,a),!0}get isLeaf(){return null==this._children[0]}hasLij(e){return this.lij[0]===e[0]&&this.lij[1]===e[1]&&this.lij[2]===e[2]}findByLij(e){if(this.hasLij(e))return this;const t=this._children;if(!t[0])return null;return t[0].findByLij(e)||t[1].findByLij(e)||t[2].findByLij(e)||t[3].findByLij(e)}distanceToSquared(e){return o(a(Ae,this._center[he.MIDDLE],e))}containsPoint(e){const t=this.extent;return e[0]>=t[0]&&e[1]>=t[1]&&e[0]<=t[2]&&e[1]<=t[3]}containsPointXY(e,t){const i=this.extent;return e>=i[0]&&t>=i[1]&&e<=i[2]&&t<=i[3]}unrequestLayerData(e,t,i){const s=this.layerInfo[t][e],n=s.waitingAgents,r=null!=n.removeUnordered(i);C(r,"agent has not requested this piece of map data"),n.length<1&&(s.abortRequest(),this.setMemoryDirty())}dataArrived(e,t,i){const s=null!=i&&"type"in i&&"vector-tile"===i.type,n=this.layerInfo[t][e];n.data=i,n.dataInvalidated=!1,n.waitingAgents.forAll((e=>e.dataArrived(this,s))),n.waitingAgents.clear(),this.setMemoryDirty()}dataMissing(e,t,i){i.notInTilemap||console.error(`Tile ${this.lij.toString()} layer ${t}/${e} error ${i}`);const s=this.layerInfo[t][e];s.dataMissing=!0,s.waitingAgents.forAll((e=>e.dataMissing())),s.waitingAgents.clear(),this.setMemoryDirty()}updateRenderData(e,t,i){switch(i&&this.forEachLoadedNeighbor((i=>i.updateRenderData(e,t))),e){case O.MAP:return this._updateTexture(t);case O.ELEVATION:return this._updateGeometry()}}_updateTexture(e){this.renderData&&(this.resetPendingUpdate(e===D.FADING?ee.TEXTURE_NOFADING:ee.TEXTURE_FADING),this.setPendingUpdate(e===D.FADING?ee.TEXTURE_FADING:ee.TEXTURE_NOFADING))}_updateGeometry(){this.setPendingUpdate(ee.GEOMETRY);for(const e of this.layerInfo[O.ELEVATION])e.pendingUpdates|=ee.GEOMETRY}invalidateLayerData(e,t){this.layerInfo[t][e].invalidateSourceData(),this.restartAgents(t)}computeElevationBounds(){const e=this._elevationBounds,t=e[0],i=e[1];n(e,1/0,-1/0);const s=this.layerInfo[O.ELEVATION];let r=!0;for(const n of s)null!=n.elevationBounds&&(e[0]=Math.min(e[0],n.elevationBounds.min),e[1]=Math.max(e[1],n.elevationBounds.max),n.elevationBounds.hasNoDataValues||(r=!1));r&&(e[0]=Math.min(e[0],0),e[1]=Math.max(e[1],0)),t===e[0]&&i===e[1]||(this.updateRadiusAndCenter(),this._surface.setTileTreeDirty())}_updateCenter(){const e=this._elevationBounds,t=.5*(e[0]+e[1]),i=this._center;h(Ae,this.up,t),u(i[he.MIDDLE],this.centerAtSeaLevel,Ae),h(Ae,this.up,e[0]),u(i[he.TOP],this.centerAtSeaLevel,Ae),h(Ae,this.up,e[1]),u(i[he.BOTTOM],this.centerAtSeaLevel,Ae)}findElevationBoundsForLayer(e,t){const i=this.layerInfo[O.ELEVATION][e],s=b(this.level),n=Math.max(this.elevationLevel-s,0),r=i.elevationBounds;if(null!=r&&r.level>=t&&r.level<=n)return;const a=this._surface.layerViewByIndex(e,O.ELEVATION),o=P(a);if(!te(this,o,!1))return;const l=le;let h=!1;const u=i.data;if(u&&u.level<=n){const e=i.data;l.min=e.samplerData.data.minValue,l.max=e.samplerData.data.maxValue,l.hasNoDataValues=e.samplerData.data.hasNoDataValues,l.level=this.level,h=!0}else{let t,i,r=0;for(let a=this._parent;a&&(!i||r<s)&&(r=this.elevationLevel-a.level,t=i||t,i=a.layerInfo[O.ELEVATION][e].data,!(!i&&t&&a.level<=n));a=a.parent);i=i||t,i&&(i.computeMinMaxValue(this.lij[0],this.lij[1],this.lij[2],l),l.min!==1/0&&(l.level=i.level,h=!0))}h&&(null==i.elevationBounds&&(i.elevationBounds=new I),i.elevationBounds.copyFrom(l))}modifyLayers(e,t,i){const s=this.layerInfo[i];for(const a of s)a.loadingAgent&&a.loadingAgent!==Q&&(re(a.loadingAgent),a.loadingAgent=null),a.waitingAgents.clear();for(let a=0;a<s.length;++a)void 0===e[a]&&s[a].release();const n=new Array(...s),r=t.length;s.length=r;for(let a=0;a<r;a++){const e=t[a];s[a]=e>-1?n[e]:K.acquire(this._surface.upsampleInfoPool)}this.setMemoryDirty()}restartAgents(e){this.renderData&&(this._createOrUpdateAgents(0,e),this.updateRenderData(e,D.FADING))}updateAgents(e){if(this.renderData){const t=this.layerInfo[e];for(const e of t)e.loadingAgent===Q&&(e.loadingAgent=null);this._createOrUpdateAgents(0,e)}}updateAgentSuspension(){for(const e of S){const t=this._isSuspended(e);for(const i of this.layerInfo[e])i.loadingAgent&&i.loadingAgent!==Q&&(i.loadingAgent.setSuspension(t),i.loadingAgent===Q&&this.updateRenderData(e,D.FADING))}}removeLayerAgent(e,t){const i=this.layerInfo[t][e];i.loadingAgent&&i.loadingAgent!==Q&&i.loadingAgent.dispose(),i.loadingAgent=null}agentDone(e,t){const i=this.layerInfo[t][e];i.loadingAgent=Q,i.data||null!=i.upsampleInfo||this._createOrUpdateAgents(e+1,t)}_hasBlendableAncestor(e){return"normal"!==e.blendMode||T(e.parent)&&this._hasBlendableAncestor(e.parent)}_hasBlendModes(e,t,i){for(let s=e;s<t;++s){const e=this._surface.layerViewByIndex(s,i);if(B(e)&&"normal"!==e?.layer?.blendMode||T(e?.layer?.parent)&&this._hasBlendableAncestor(e?.layer?.parent))return!0}return!1}_createOrUpdateAgents(e,t){const i=this.layerInfo[t];if(0===i.length)return;const s=this._isSuspended(t);for(let n=e;n<i.length;++n){const r=i[n];let a=!1;const o=this._surface.layerViewByIndex(n,t),l=P(o);if(r.loadingAgent?te(this,l,!1)?(r.loadingAgent!==Q&&r.loadingAgent.setSuspension(s),r.loadingAgent!==Q&&(a=r.loadingAgent.update())):r.dispose():te(this,l,!1)&&(r.loadingAgent=ne(this,n,t,s),a=r.loadingAgent.startLoading(),a?r.loadingAgent===Q&&this.setPendingUpdate(ee.GEOMETRY):(re(r.loadingAgent),r.loadingAgent=Q)),r.loadingAgent===Q&&this.updateRenderData(t,D.FADING),!this._hasBlendModes(e,i.length,t)&&a&&o.isOpaque)return}}_isWithinExtent(e){const t=this.extent;return t[0]>=e[0]&&e[2]>=t[2]&&t[1]>=e[1]&&e[3]>=t[3]}intersectsExtent(e){const t=this.extent;return t[2]>=e[0]&&e[2]>=t[0]&&t[3]>=e[1]&&e[3]>=t[1]}getElevationVerticesPerSide(t){const i=this.elevationLevel-this.level,s=Math.max(this.level-t,b(this.level)-i),n=e(1+(this.maxTesselation>>s),2,this.maxTesselation+1),r=this.getDefaultVerticesPerSide();return Math.max(n,r)}get test(){return{cachedMemory:this._cachedMemory}}_findLIJ(e,t){if(!e)return null;const i=this.surface.rootTiles;if(null!=i)for(const s of i)if(ue(s,e)){let i=s,n=e[0]-i.level-1;for(;n>=0&&!i.isLeaf&&!t(i);){const t=e[1]>>n&1,s=e[2]>>n&1;i=i.children[2*t+s],n--}return t(i)?i:null}return null}findNeighborTile(e,t){const i=this.lij,s=this.getNeighborLIJ(i,e);return s?de(i,s)?t(this)?this:null:this._findLIJ(s,t):null}findCorner(e,t){const i=e===x.NORTH_EAST?1:e===x.NORTH_WEST?0:e===x.SOUTH_WEST?2:3;let s=this;for(;s.children[0]&&(!t||!t(s));)s=s.children[i];return s}findNeighborCornerTileExact(e,t){return this.findNeighborTile(e,(e=>t(e)||e.level===this.level))?.findCorner(R(e),t)||null}forAllSubtreeOnSide(e,t){const i=e===x.NORTH?[0,1]:e===x.NORTH_EAST?[1]:e===x.EAST?[1,3]:e===x.SOUTH_EAST?[3]:e===x.SOUTH?[2,3]:e===x.SOUTH_WEST?[2]:e===x.WEST?[0,2]:[0],s=e=>{const n=e.children;!t(e)&&n[0]&&i.forEach((e=>s(n[e])))};s(this)}getNeighborEdgeStartVertexIndex(e,t){if(!t)return 0;const i=this.level-t.level;if(V(!w||i>=0),0===i)return 0;const s=2**i,n=1==(1&e),r=n?0:1,a=t.lij[r+1]*s,o=this.lij[r+1],l=o-a,h=n?s-1-l:l;return w&&(V(a<=o&&o<a+s),V(0<=h&&h<s)),h}forEachLoadedNeighbor(e){const t=this.level,i=e=>e.level===t||e.isLoaded;G.forEach((t=>{const s=this.findNeighborTile(t,i);null!=s&&s!==this&&s.forAllSubtreeOnSide(W(t),(i=>!!i.isLoaded&&(e(i,t),!0)))})),q.forEach((t=>{const s=this.findNeighborTile(t,i)?.findCorner(R(t),(e=>e.isLoaded));V(!s||ge(this,s,t)),s?.isLoaded&&e(s,t)}))}getNeighborLIJ(e,t){const i=F(t)?-1:H(t)?1:0,s=k(t)?-1:X(t)?1:0,n=[e[0],e[1]+i,e[2]+s];return n[1]<0?null:this.surface.isGlobal?this.wrapLIJ(n):n[2]<0?null:n}wrapLIJ(e){return!e||e[1]<0||e[1]>=2**e[0]?null:this.surface.wrapEastWest(e)}get westNeighborWestExtent(){return this.extent[0]*(this.isWestEnd?-1:1)}get eastNeighborEastExtent(){return this.extent[2]*(this.isEastEnd?-1:1)}get isEastEnd(){return this.lij[2]===this.surface.lijEastEnd(this.level)-1}get isWestEnd(){return 0===this.lij[2]}get isNorthEnd(){return 0===this.lij[1]}get isSouthEnd(){const e=this.surface.extent,t=e?.[1]??null;return null!=t&&this.extent[1]+f()>=t}checkGeometryWaterproofness(){Y&&(V(this.isLoaded),this.renderData?.checkGeometryWaterproofness())}shouldHaveNeighbor(e){const t=this.extent,i=this.surface.rootTilesExtent,s=.25*(t[2]-t[0]);if(F(e)&&t[3]+s>=i[3])return!1;if(H(e)&&t[1]-s<=i[1])return!1;const n=this.surface.isGlobal;return!(!n&&k(e)&&t[0]-s<=i[0])&&!(!n&&X(e)&&t[2]+s>=i[2])}updateDistanceToPOI(e){const t=this._lastPOI;if(this.distanceToPOI>=0&&t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2])return;c(this._lastPOI,e);const i=this._center[he.MIDDLE],s=e[0]-i[0],n=e[1]-i[1],r=e[2]-i[2];this.distanceToPOI=s*s+n*n+r*r}}function ne(e,t,i,s){const n=i===O.ELEVATION?oe.acquire():ae.acquire();return n.init(e,t,i,s),n}function re(e){e.dispose(),e instanceof M?oe.release(e):e instanceof j&&ae.release(e)}const ae=new i(j),oe=new i(M),le=new I;var he;function ue(e,t){const i=e.level,s=t[0];if(i>s)return!1;const n=s-i,r=Math.floor(t[1]/2**n),a=Math.floor(t[2]/2**n);return r===e.lij[1]&&a===e.lij[2]}function de(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function ce(e,t,i){if(null==e||null==t)return!1;if(0===e.level&&0===t.level){if(e.isEastEnd&&t.isWestEnd&&i===x.EAST)return!0;if(e.isWestEnd&&t.isEastEnd&&i===x.WEST)return!0}const s=Math.max(1e-6*(e.extent[2]-e.extent[0]),1);switch(i){case x.NORTH:return z(e.extent[3],t.extent[1],s);case x.SOUTH:return z(e.extent[1],t.extent[3],s);case x.EAST:return z(e.extent[2],t.extent[0],s)||z(e.extent[2],-t.extent[0],s);case x.WEST:return z(e.extent[0],t.extent[2],s)||z(e.extent[0],-t.extent[2],s)}}function ge(e,t,i){return null!=e&&null!=t&&t!==e&&(e.level>=t.level?pe(e,t,i):pe(t,e,R(i)))}function pe(e,t,i){V(e.level>=t.level);const s=$(i),n=J(i),r=e.extent,a=t.extent,o=[s?r[0]:r[2],n?r[3]:r[1]],l=[s?a[2]:a[0],n?a[1]:a[3]],h=1e-5*(r[2]-r[0]),u=z(o[0],l[0],h)||e.surface.isGlobal&&z(o[0],-l[0],h),d=z(o[1],l[1],h);if(u&&d)return!0;if(e.level===t.level)return V(!1),!1;if(!u&&!d)return V(!1),!1;const c=u?fe(a[1],a[3],r[1],r[3],h):fe(a[0],a[2],r[0],r[2],h);return V(c),c}function fe(e,t,i,s,n){return e-n<=i&&i<=s&&s<=t+n}!function(e){e[e.TOP=0]="TOP",e[e.MIDDLE=1]="MIDDLE",e[e.BOTTOM=2]="BOTTOM"}(he||(he={}));const me=g(),_e=g(),ye=g(),Ae=g();export{he as CenterPosition,se as Tile,ge as isCornerNeighbor,ce as isEdgeNeighbor};
