/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{isPowerOfTwo as t,clamp as e}from"../../../core/mathUtils.js";import{s as n}from"../../../chunks/vec4.js";import{empty as o}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as s}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevation as r}from"./ElevationData.js";import{PatchType as i}from"./interfaces.js";import{NeighborIndex as a}from"./ITile.js";import{minMaxBoundingBox as c,encodeUVInBuffer as l,EdgeDescriptor as u}from"./PatchGeometry.js";import{PatchGeometryLUT as f}from"./PatchGeometryLUT.js";import{neighborTileIfLoadedOrSelf as d}from"./PatchRenderData.js";import{enableTerrainInternalChecks as m,internalAssert as g,neighborEdgeIndices as p,almostEquals as h}from"./terrainUtils.js";import{isCornerNeighbor as M}from"./Tile.js";import{compareTilesByLij as x}from"./tileUtils.js";import{compressNormal as y}from"../webgl-engine/lib/Normals.js";const S=65536;function b(t,e){const n=t.tile,{extent:s,extentInRadians:r,surface:a}=n,u=t.localOrigin,f=t.geometryState,d=a.isWebMercator,p=f.numVerticesPerSide,h=p-1,M=(p-2)**2,x=d&&(e===i.HAS_SOUTH_POLE||e===i.HAS_BOTH_POLES),S=d&&(e===i.HAS_NORTH_POLE||e===i.HAS_BOTH_POLES),b=6,B=((x?1:0)+(S?1:0))*b*(h+1),L=f.neighborData,O=L.edgeResolutions.reduce(((t,e)=>t+e+1),0),T=M+B+O,P=a.renderer.tileGeometryCache.acquire(T),A=t.geometry;A.numVerticesPerSide=f.numVerticesPerSide,A.vertexAttributes=P;const E=A.boundingBox;o(E);const U=V(t);Q.update(h,r,U),v(t),F(t,M),R(t);const C=[];if((()=>{let t=M+O;const e=u[0],o=u[1],r=u[2],i=n.ellipsoid.radius,a=s[1],f=s[3],d=(n,s)=>{const u=s*p;c(-e,-o,n*i-r,E),C.push({connectedRowOffset:u,connectedOuterEdgeOffset:1===n?0:2,rowOffset:t,latitudeResolution:b});const d=D(-1===n?a:f,i),m=n*Math.PI/2-d,g=.99*(1===n?1:-1),M=i+0,{position:x,uv0:S}=P,{typedBuffer:v,typedBufferStride:B}=P.normalCompressed;for(let i=1;i<=b;++i){const n=d+m*(i/b),s=Math.cos(n),a=Math.sin(n);for(let i=0;i<=h;i++){const n=i/h,u=Q.sinLonLUT[i],f=Q.cosLonLUT[i]*s,d=u*s,m=a,p=f*M-e,b=d*M-o,L=m*M-r;c(p,b,L,E),x.setValues(t,p,b,L),l(S,t,n,g),y(v,t,f,d,m,B),++t}}};x&&d(-1,0),S&&d(1,h)})(),W(A,f.numVerticesPerSide,C,[0,p-1],[0,p-1],f.wireframe),t.intersectionData=null,m)for(let o=0;o<4;++o)g(A.outerEdges[o].count===L.edgeResolutions[o]+1)}function v(t){const e=t.tile;if(!e.intersectsClippingArea)return;const n=t.geometryState,o=n.numVerticesPerSide,s=o-2,i=o-1,a=t.geometry,u=a.vertexAttributes,f=u.position,d=u.uv0,{typedBuffer:m,typedBufferStride:g}=u.normalCompressed,p=e.extent,h=p[0],M=p[2],x=p[1],S=p[3],b=e.ellipsoid.radius,v=n.samplerData,B=t.localOrigin,L=B[0],R=B[1],O=B[2],T=f.typedBuffer,D=f.typedBufferStride,P=1/i,A=a.boundingBox;let V=0;if(1<=s){const t=P,e=x*(1-t)+S*t,n=Q.sinLatLUT[1],o=Q.cosLatLUT[1];for(let i=1;i<=s;i++){const s=i*P,a=h*(1-s)+M*s,u=Q.sinLonLUT[i],f=Q.cosLonLUT[i],m=b+r(a,e,v),g=m*f*o-L,p=m*u*o-R,x=m*n-O;c(g,p,x,A);const y=(i-1)*D;T[y]=g,T[y+1]=p,T[y+2]=x,l(d,i-1,s,t)}}for(let E=1;E<=s;E++){const t=E*P,e=x*(1-t)+S*t,n=Q.sinLatLUT[E],o=Q.cosLatLUT[E],a=E+1,u=a*P,f=x*(1-u)+S*u,p=Q.sinLatLUT[a],B=Q.cosLatLUT[a],U=Q.sinLonLUT[0],C=Q.cosLonLUT[0],I=b+r(h,e,v);let j=C*o*I-L,w=U*o*I-R,N=n*I-O;const H=V*D;let q=T[H],_=T[H+1],W=T[H+2];for(let S=1;S<=s;S++){const t=S*P,a=h*(1-t)+M*t,U=Q.sinLonLUT[S],C=Q.cosLonLUT[S];let I=0,H=0,F=0;if(S<s){const t=(V+1)*D;I=T[t],H=T[t+1],F=T[t+2]}else{const t=Q.sinLonLUT[i],s=Q.cosLonLUT[i],a=b+r(M,e,v);I=s*o*a-L,H=t*o*a-R,F=n*a-O}const k=j,G=w,z=N;j=q,w=_,N=W,q=I,_=H,W=F;const J=I-k,K=H-G,X=F-z;let Y=0,Z=0,$=0;if(E>1){const t=(V-s)*D;Y=T[t],Z=T[t+1],$=T[t+2]}else{const t=Q.sinLatLUT[0],e=Q.cosLatLUT[0],n=b+r(a,x,v);Y=C*e*n-L,Z=U*e*n-R,$=t*n-O}const tt=b+r(a,f,v),et=C*B*tt-L,nt=U*B*tt-R,ot=p*tt-O;if(E<s){const e=V+s,n=e*D;T[n]=et,T[n+1]=nt,T[n+2]=ot,c(et,nt,ot,A),l(d,e,t,u)}const st=Y-et,rt=Z-nt,it=$-ot;let at=C*o,ct=U*o,lt=n;lt*lt<.999&&(at=X*rt-K*it,ct=J*it-X*st,lt=K*st-J*rt);const ut=1/Math.sqrt(at*at+ct*ct+lt*lt);y(m,V,at*ut,ct*ut,lt*ut,g),++V}}}function B(t){t.tile.intersectsClippingArea&&(R(t),J(t))}function L(t){t.tile.intersectsClippingArea&&(T(t),O(t,!0),J(t))}function R(t){t.tile.intersectsClippingArea&&(T(t),O(t))}function O(e,n=!1){const o=e.geometryState,s=e.geometry,i=o.neighborData,a=e.tile,u=a.level,f=a.extent,M=a.ellipsoid.radius,y=a.extentInRadians,S=y[0],b=y[2],v=y[1],B=y[3],L=o.samplerData,R=f[0],O=f[2],T=f[1],D=f[3],P=V(e),A=s.boundingBox,E=e.localOrigin,U=E[0],C=E[1],I=E[2],j=s.vertexAttributes,w=j.position,N=w.typedBuffer,H=w.typedBufferStride,q=j.uv0;for(let V=0;V<4;++V){const o=1===V||3===V,y=i.edgeResolutions[V];g(t(y));const E=y+1,j=d(a,i.edgePeerNeighbors[V]);if(Z(a,j,V)){k(e,V,j);continue}const w=null!=j;g(!w||j.level===a.level),g(!w||x(a,j)<=0);const _=j?.renderData,W=_?.geometryState;if(m){const t=a.surface;if(!j&&t&&!t.updatingRootTiles){const e=p[V],n=a.findNeighborTile(e,(t=>t.isLoaded||t.isLeaf||t.level===a.level));n?n.intersectsClippingArea&&(g(!n.isLoaded),g(!n.isLeaf),g(n.level===u)):g(null==t?.rootTiles||!a.shouldHaveNeighbor(e))}}const F=1===V?f[2]:f[0],G=j?.extent,z=G&&o?1===V?G[0]:G[2]:F,J=0===V?f[3]:f[1],K=1===V?1:0,Q=0===V?1:0,X=1===V?b:S,Y=0===V?B:v,$=Math.sin(X),tt=Math.cos(X),et=Math.sin(Y),nt=Math.cos(Y),ot=W?.samplerData,st=w?(t,e,n)=>.5*(r(t,e,L)+r(n,e,ot)):(t,e,n)=>r(t,e,L),rt=s.outerEdges[V],it=n&&E>3?E-3:1,at=null!=L&&L.some((t=>null!=t)),ct=null!=ot&&ot.some((t=>null!=t)),lt=at||ct,ut=1/y,ft=rt.index0;g(!G||h(G[2]-G[0],f[2]-f[0]));(()=>{const t=1===V?-1:3===V?1:0,e=0===V?-1:2===V?1:0,n=(f[2]-f[0])*ut,s=t*n,i=e*n,a=o?t*((b-S)*ut):0,u=o?0:e*ut,d=Q,m=o?X+a:X,g=o?Math.sin(m):$,p=o?Math.cos(m):tt,h=o?X-a:X,x=o?Math.sin(h):$,y=o?Math.cos(h):tt,v=o?Y:P(d+u),B=o?et:Math.sin(v),j=o?nt:Math.cos(v),_=o?Y:P(d-u),W=o?et:Math.sin(_),k=o?nt:Math.cos(_);let G=0,Z=0,at=0;{const t=0*ut,e=o?F:R*(1-t)+O*t,n=o?z:e,s=o?T*(1-t)+D*t:J,r=o?X:S*(1-t)+b*t,i=o?$:Math.sin(r),a=o?tt:Math.cos(r),c=o?P(t):Y,l=o?Math.sin(c):et,u=o?Math.cos(c):nt,f=M+st(e,s,n);G=a*u*f,Z=i*u*f,at=l*f}let ct=0,dt=0,mt=0;{const t=1*ut,e=o?F:R*(1-t)+O*t,n=o?z:e,s=o?T*(1-t)+D*t:J,r=o?X:S*(1-t)+b*t,i=o?$:Math.sin(r),a=o?tt:Math.cos(r),c=o?P(t):Y,l=o?Math.sin(c):et,u=o?Math.cos(c):nt,f=M+st(e,s,n);ct=a*u*f,dt=i*u*f,mt=l*f}for(let f=1;f<E-1;f+=it){let t=0,e=0,n=0;{const s=(f+1)*ut,r=o?F:R*(1-s)+O*s,i=o?z:r,a=o?T*(1-s)+D*s:J,c=o?X:S*(1-s)+b*s,l=o?$:Math.sin(c),u=o?tt:Math.cos(c),d=o?P(s):Y,m=o?Math.sin(d):et,g=o?Math.cos(d):nt,p=M+st(r,a,i);t=u*g*p,e=l*g*p,n=m*p}const a=t,u=e,d=n,m=ct,h=dt,v=mt;ct=a,dt=u,mt=d;{const t=ft+f,e=t*H,n=m-U,s=h-C,r=v-I;N[e]=n,N[e+1]=s,N[e+2]=r,c(n,s,r,A);const i=f*ut;l(q,t,o?K:i,o?i:Q)}const E=G,_=Z,it=at;G=m,Z=h,at=v;const gt=m,pt=h,ht=v,Mt=1/Math.sqrt(gt*gt+pt*pt+ht*ht),xt=ht*Mt;let yt=0,St=0,bt=0;if(lt&&xt*xt<.999){let t=0,e=0,n=0;{const o=0===V?-1:1;t=o*(a-E),e=o*(u-_),n=o*(d-it)}{const a=f*ut,c=o?F:R*(1-a)+O*a,l=o?z:c,u=o?T*(1-a)+D*a:J,d=o?X:S*(1-a)+b*a,m=o?$:Math.sin(d),h=o?tt:Math.cos(d),v=o?P(a):Y,A=o?Math.sin(v):et,E=o?Math.cos(v):nt;let U=gt,C=pt,I=ht;if(w){const t=M+r(l-s,u-i,ot),e=o?E:k;U=(o?y:h)*e*t,C=(o?x:m)*e*t,I=(o?A:W)*t}{const a=M+r(c+s,u+i,L),l=o?E:j,f=(o?p:h)*l*a,d=(o?g:m)*l*a,x=(o?A:B)*a;w||(U=2*gt-f,C=2*pt-d,I=2*ht-x);const y=3===V?-1:1,S=y*(U-f),b=y*(C-d),v=y*(I-x);yt=n*b-e*v,St=t*v-n*S,bt=e*S-t*b;const R=1/Math.sqrt(yt*yt+St*St+bt*bt);yt*=R,St*=R,bt*=R}}}else yt=gt*Mt,St=pt*Mt,bt=ht*Mt;rt.setNormalFromValues(f,yt,St,bt)}})()}}function T(t){G(t)}function D(t,e){return Math.PI/2-2*Math.atan(Math.exp(-t/e))}function P(t,e,n,o){return D(t*(1-o)+e*o,n)}function A(t,e,n){return t*(1-n)+e*n}function V(t){const e=t.tile;if(e.surface.isWebMercator){const t=e.extent,n=e.ellipsoid.radius;return e=>P(t[1],t[3],n,e)}const n=e.extentInRadians;return t=>A(n[1],n[3],t)}function E(t,e){const s=t.tile,{extent:r,surface:i}=s,a=t.geometryState,c=r[0],l=r[1],u=r[2]-c,f=r[3]-l,d=a.clippingArea,m=null!=d?Math.max(0,(d[0]-c)/u):0,g=null!=d?Math.max(0,(d[1]-l)/f):0,p=null!=d?Math.min(1,(d[2]-c)/u):1,h=null!=d?Math.min(1,(d[3]-l)/f):1,M=a.numVerticesPerSide,x=(M-2)**2,y=x+a.neighborData.edgeResolutions.reduce(((t,e)=>t+e+1),0),S=i.renderer.tileGeometryCache.acquire(y),b=t.geometry,v=b.boundingBox;o(v),b.numVerticesPerSide=a.numVerticesPerSide,b.vertexAttributes=S,n(b.uvRange,m,g,p,h),U(t),F(t,x),j(t),W(b,a.numVerticesPerSide,[],[0,M-1],[0,M-1],a.wireframe),t.intersectionData=null}function U(t){const n=t.tile;if(!n.intersectsClippingArea)return;const o=n.surface,s=t.geometryState,i=s.samplerData,a=t.localOrigin,u=o.isWebMercatorOnPlateeCarree,f=s.clippingArea,d=null!=f?f:X,m=n.extent,g=m[0],p=m[1],h=m[2],M=m[3],x=Math.max(g,d[0]),S=Math.min(h,d[2]),b=Math.max(p,d[1]),v=Math.min(M,d[3]),B=n.ellipsoid.radius,L=n.horizontalScale,R=s.numVerticesPerSide,O=R-1,T=R-2,D=t.geometry,P=D.vertexAttributes,A=P.position,V=P.uv0,{typedBuffer:E,typedBufferStride:U}=P.normalCompressed,C=D.uvRange,I=C[0],j=C[1],w=C[2],N=C[3],H=D.boundingBox,q=a[0],_=a[1],W=a[2],F=A.typedBuffer,k=A.typedBufferStride;let G=0;const z=e(p,b,v),J=u?(Math.PI/2-2*Math.atan(Math.exp(-z/B)))*B:z*L,K=1/O,Q=e(p*(1-K)+M*K,b,v);let Y=J,Z=u?(Math.PI/2-2*Math.atan(Math.exp(-Q/B)))*B:Q*L;for(let X=1;X<=T;X++){const t=X/O,n=e(p*(1-t)+M*t,b,v),o=e(t,j,N),s=Z,a=(X-1)/O,f=e(p*(1-a)+M*a,b,v),d=Y,m=(X+1)/O,R=e(p*(1-m)+M*m,b,v),D=u?(Math.PI/2-2*Math.atan(Math.exp(-R/B)))*B:R*L,P=e(m,j,N);Y=Z,Z=D;const A=e(g,x,S);let C=A*L,z=r(A,n,i);const J=1/O,K=e(J,I,w),Q=e(g*(1-K)+h*K,x,S);let $=K,tt=Q,et=Q*L,nt=r(Q,n,i);if(1===X){const t=et-q,n=Y-_,s=nt-W,r=0*k;F[r]=t,F[r+1]=n,F[r+2]=s,c(t,n,s,H);const i=e(J,I,w);l(V,G,i,o)}for(let u=1;u<=T;u++){const t=et,a=nt,m=(u+1)/O,p=e(m,I,w),M=e(g*(1-m)+h*m,x,S),b=tt;tt=M;{const t=G+1,e=t*k;if(1===X||u===T){const a=M*L,f=r(M,n,i);if(1===X&&u<T){const n=a-q,r=s-_,i=f-W;F[e]=n,F[e+1]=r,F[e+2]=i,c(n,r,i,H),l(V,t,p,o)}et=a,nt=f}else et=F[e]+q,nt=F[e+2]+W}const v=et,B=nt,A=C,j=z;C=t,z=a;const N=(G-T)*k,J=1===X?r(b,f,i):F[N+2]+W,K=r(b,R,i);if(X<T){const e=G+T,n=e*k,o=t-q,s=D-_,r=K-W;F[n]=o,F[n+1]=s,F[n+2]=r,c(o,s,r,H);const i=$;$=p,l(V,e,i,P)}{const t=v-A,e=d-D,n=e*(B-j),o=t*(J-K),s=-e*t,r=n*n+o*o+s*s;if(0===r)y(E,G,0,0,1,U);else{const t=1/Math.sqrt(r);y(E,G,n*t,o*t,s*t,U)}}++G}}}function C(t,e){t.tile.intersectsClippingArea&&(N(t),w(t,!0),J(t))}function I(t,e){t.tile.intersectsClippingArea&&(j(t),J(t))}function j(t,e){t.tile.intersectsClippingArea&&(N(t),w(t,!1))}function w(n,o){const s=n.geometryState,i=s.neighborData,a=n.tile,l=a.surface,u=a.extent,f=s.clippingArea,h=null!=f?f:X,M=u[0],y=u[2],S=u[1],b=u[3],v=[b>h[3],y>h[2],S<h[1],M<h[0]],B=n.geometry,L=a.horizontalScale,R=_(l.isWebMercatorOnPlateeCarree,a.ellipsoid.radius,L),O=B.boundingBox,T=B.uvRange[0],D=B.uvRange[1],P=B.uvRange[2],A=B.uvRange[3],V=Math.max(M,h[0]),E=Math.min(y,h[2]),U=Math.max(S,h[1]),C=Math.min(b,h[3]),I=n.localOrigin,j=I[0],w=I[1],N=I[2],H=s.samplerData;for(let q=0;q<4;++q){const s=1===q||3===q,u=i.edgeResolutions[q];g(t(u));const f=u+1,h=v[q],I=d(a,i.edgePeerNeighbors[q]);if(!h&&Z(a,I,q)){k(n,q,I);continue}const _=null!=I&&!h,W=I?.renderData,F=W?.geometryState;if(m&&(g(!_||I.level===a.level),g(!_||x(a,I)<=0),a&&!I&&!l.updatingRootTiles)){const t=p[q],e=a.findNeighborTile(t,(t=>t.isLoaded||t.isLeaf||t.level===a.level));l.updatingRootTiles||(e?e.intersectsClippingArea&&(g(!e.isLoaded),g(!e.isLeaf),g(e.level===a.level)):g(null==l?.rootTiles||!a.shouldHaveNeighbor(t)))}const G=e(1===q?y:M,V,E),z=e(0===q?b:S,U,C),J=F?.samplerData,K=B.outerEdges[q],Q=o&&f>3?f-3:1,X=e(1===q?1:0,T,P),Y=e(0===q?1:0,D,A),$=_?(t,e)=>.5*(r(t,e,J)+r(t,e,H)):(t,e)=>r(t,e,H),tt=(y-M)/u,et=s?1===q?tt:-tt:0,nt=s?0:0===q?tt:-tt,ot=-et,st=-nt;let rt=0,it=0,at=0;{const t=0/u,n=s?G:e(M*(1-t)+y*t,V,E),o=s?e(S*(1-t)+b*t,U,C):z,r=$(n,o);rt=n*L,it=R(o),at=r}let ct=0,lt=0,ut=0;{const t=1/u,n=s?G:e(M*(1-t)+y*t,V,E),o=s?e(S*(1-t)+b*t,U,C):z,r=$(n,o);ct=n*L,lt=R(o),ut=r}for(let t=1;t<f-1;t+=Q){const n=t/u,o=ct,i=lt,a=ut;{const r=s?X:e(n,T,P),l=s?e(n,D,A):Y,u=o-j,f=i-w,d=a-N;c(o,f,d,O),K.setVertexFromValuesRawPositionUV(t,u,f,d,r,l)}{const n=(t+1)/u,o=s?G:e(M*(1-n)+y*n,V,E),r=s?e(S*(1-n)+b*n,U,C):z,i=$(o,r);ct=o*L,lt=R(r),ut=i}const l=ct,f=ut,d=rt,m=it,g=at;rt=o,it=i,at=a;let p=0,h=0,x=0;if(s){const t=lt-i,s=f-a,c=m-i,l=g-a,u=e(S*(1-n)+b*n,U,C),d=G+ot,M=d*L-o,y=r(d,u,H)-a,v=3===q?-1:1;if(p=v*(-c+t)*y,h=v*M*(-l+s),x=-v*M*(-c+t),_){const e=G+et,n=e*L-o;p=(-c+t)*(y-(r(e,u,J)-a)),h=(M-n)*(-l+s),x=-(M-n)*(-c+t)}}else{const t=l-o,s=f-a,c=d-o,u=g-a,m=e(M*(1-n)+y*n,V,E),S=z+st,b=r(m,S,H)-a,v=R(S)-i,B=2===q?-1:1;if(p=B*v*(-u+s),h=B*(-c+t)*b,x=-B*v*(-c+t),_){const e=m,n=z+nt,o=R(n)-i;p=(-v+o)*(-u+s),h=(-c+t)*(-b+(r(e,n,J)-a)),x=-(-v+o)*(-c+t)}}const v=1/Math.sqrt(p*p+h*h+x*x);K.setNormalFromValues(t,p*v,h*v,x*v)}}}function N(t,e){G(t)}function H(t,e){return(Math.PI/2-2*Math.atan(Math.exp(-t/e)))*e}function q(t,e){return t*e}function _(t,e,n){return t?t=>H(t,e):t=>q(t,n)}function W(t,e,n,o,s,r){const i=e-1,a=t.vertexAttributes.count,c=2*(Math.min(e-2,o[1])-Math.max(1,o[0]))*(Math.min(e-2,s[1])-Math.max(1,s[0])),l=p.map(((t,n)=>0===n&&s[1]<e-2||1===n&&o[1]<e-2||2===n&&s[0]>1||3===n&&o[0]>1)),u=t.outerEdges.reduce(((t,e,n)=>t+(l[n]?0:i-2+e.count-1)),0),f=n.reduce(((t,e)=>t+i*(2*(e.latitudeResolution-1)+1)),0),d=r?2:1,h=3*(c+u+f)*d,M=a>=S?new Uint32Array(h):new Uint16Array(h);let x=0;const y=e-2,b=i-2;g(b>=0);const v=(t,e,n,o,s,r)=>{const i=t*s,a=r[i],c=r[i+1],l=r[i+2],u=e*s,f=r[u],d=r[u+1],m=r[u+2],g=n*s,p=r[g],h=r[g+1],M=r[g+2],x=o*s,y=r[x],S=r[x+1],b=r[x+2];return(f-y)*(f-y)+(d-S)*(d-S)+(m-b)*(m-b)>(a-p)*(a-p)+(c-h)*(c-h)+(l-M)*(l-M)};if(r){const r=(t,e,n)=>{M[x++]=t,M[x++]=e,M[x++]=e,M[x++]=n,M[x++]=n,M[x++]=t,m&&(g(t<a),g(e<a),g(n<a),g(x<=h))};(()=>{for(let n=Math.max(s[0],1)-1;n<Math.min(s[1],e-2)-1;++n){const s=n*y;for(let i=Math.max(o[0],1)-1;i<Math.min(o[1],e-2)-1;++i){const e=n*y+i,o=e+1,a=o+y,c=a-1,l=s+i,u=l+1,f=u+y,d=f-1,m=t.vertexAttributes.position.typedBuffer,g=t.vertexAttributes.position.typedBufferStride;v(l,u,f,d,g,m)?(r(e,o,a),r(a,c,e)):(r(e,o,c),r(c,a,o))}}})(),g(x===3*c*d);(()=>{for(let e=0;e<4;++e){const n=x;if(l[e])continue;const o=t.outerEdges[e],s=t.innerEdges[e];let a=0,c=0;const u=o.count,f=s.count;g(f===i-1);let p=0;const h=1===e||2===e?(t,e,n)=>r(t,e,n):(t,e,n)=>r(t,n,e);for(;a<u-1||c<f-1;){const t=s.getVertexIndex(c),e=o.getVertexIndex(a),n=a<u-1,r=c<f-1;if(n&&(!r||(n?0+i*(a+.5)/(u-1):0)<=(r?1+b*(c+.5)/(f-1):0))){++a,m&&g(a<u);h(t,e,o.getVertexIndex(a)),p++}else{++c,m&&g(c<f);h(t,e,s.getVertexIndex(c)),p++}}m&&(g(a===u-1),g(c===f-1),g(p===u+f-2),g(p===i-2+o.count-1),g(x===n+3*p*d))}})(),g(x===3*(c+u)*d);const f=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),a=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<i;e++)r(s,s+1,o+e),t<n.latitudeResolution-1&&r(s+1,o+e+1,o+e),s+=a;s=o,a=1}};(()=>n.forEach(f))()}else{(()=>{const n=Math.max(s[0],1)-1,r=Math.min(s[1],e-2)-1,i=Math.max(o[0],1)-1,a=Math.min(o[1],e-2)-1;for(let e=n;e<r;++e){const n=e*y;for(let e=i;e<a;++e){const o=n+e,s=o+1,r=s+y,i=r-1,a=t.vertexAttributes.position.typedBuffer,c=t.vertexAttributes.position.typedBufferStride;v(o,s,r,i,c,a)?(M[x]=o,M[x+1]=s,M[x+2]=r,M[x+3]=r,M[x+4]=i,M[x+5]=o):(M[x]=o,M[x+1]=s,M[x+2]=i,M[x+3]=i,M[x+4]=s,M[x+5]=r),x+=6}}})(),g(x===3*c*d);(()=>{for(let e=0;e<4;++e){if(l[e])continue;const n=t.outerEdges[e],o=t.innerEdges[e];let s=0,r=0;const a=n.count,c=o.count;g(c===i-1);const u=1===e||2===e,f=u?1:2,d=u?2:1,m=n.index0,p=n.stride,h=o.index0,y=o.stride;for(;s<a-1||r<c-1;){const t=h+r*y,e=m+s*p,n=s<a-1,o=r<c-1,l=n&&(!o||(n?0+i*(s+.5)/(a-1):0)<=(o?1+b*(r+.5)/(c-1):0));l?++s:++r;const u=l?e+p:t+y;M[x]=t,M[x+f]=e,M[x+d]=u,x+=3}}})(),g(x===3*(c+u)*d);const r=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),r=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<i;e++){const i=o+e;M[x]=s,M[x+1]=s+1,M[x+2]=i,t<n.latitudeResolution-1?(M[x+3]=s+1,M[x+4]=i+1,M[x+5]=i,x+=6):x+=3,s+=r}s=o,r=1}};(()=>n.forEach(r))()}g(x===h),t.indices=M,t.indexCount=h}function F(t,e){const n=t.localOrigin,o=t.geometry,s=t.geometryState.neighborData.edgeResolutions,r=o.numVerticesPerSide-2,i=o.vertexAttributes;let a=e;for(let c=0;c<4;++c){{const t=0===c||2===c,e=(0===c?r-1:0)*r+(1===c?r-1:0),s=(t?0:1)*r+(t?1:0);o.innerEdges[c]=new u(i,n,e,s,r)}{const t=a,e=s[c]+1;o.outerEdges[c]=new u(i,n,t,1,e),a+=e}}}function k(n,o,s){const r=(o+2)%4,i=n.geometryState,a=n.tile,u=i.neighborData,f=a.level-s.level,d=1===o||3===o,m=u.edgeResolutions[o];g(t(m));const p=m+1,h=n.geometry,M=h.boundingBox,x=h.outerEdges[o],y=h.uvRange[0],S=h.uvRange[1],b=h.uvRange[2],v=h.uvRange[3],B=e(1===o?1:0,y,b),L=e(0===o?1:0,S,v),R=s.renderData,O=R.geometryState,T=R.geometry.outerEdges[r],D=a.getNeighborEdgeStartVertexIndex(o,s)*m,P=m*2**f;g(O.neighborData.edgeResolutions[r]===P),g(T.count-1===P);const A=R.localOrigin[0]-n.localOrigin[0],V=R.localOrigin[1]-n.localOrigin[1],E=R.localOrigin[2]-n.localOrigin[2],U=x.attributes,C=x.index0,I=x.stride,j=U.position.typedBuffer,w=U.position.typedBufferStride,N=U.normalCompressed.typedBuffer,H=U.normalCompressed.typedBufferStride,q=U.uv0,_=T.attributes,W=T.index0,F=T.stride,k=_.position.typedBuffer,G=_.position.typedBufferStride,z=_.normalCompressed.typedBuffer,J=_.normalCompressed.typedBufferStride;for(let t=1;t<p-1;++t){const n=C+I*t,o=W+F*(D+t),s=n*w,r=o*G,i=k[r]+A,a=k[r+1]+V,u=k[r+2]+E;j[s]=i,j[s+1]=a,j[s+2]=u,c(i,a,u,M);const f=n*H,g=o*J;N[f]=z[g],N[f+1]=z[g+1];const p=t/m,h=d?B:e(p,y,b),x=d?e(p,S,v):L;l(q,n,h,x)}}function G(t){const n=t.geometryState,o=n.neighborData,s=t.localOrigin,i=o.cornerNeighborData,a=t.geometry,u=a.outerEdges,f=a.boundingBox,d=t.tile,m="local"===t.tile.surface.view?.viewingMode,p=d.ellipsoid.radius,h=d.extentInRadians,M=d.horizontalScale;let y=0,S=0,b=0;const v=(t,e,n)=>{const o=h[0===e?1:3],s=h[0===t?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),c=Math.cos(s),l=p+n;y=c*r*l,S=a*r*l,b=i*l},B=m?(()=>{const n=t.geometryState.clippingArea,o=d.extent,s=null!=n&&(o[3]>n[3]||o[2]>n[2]||o[1]<n[1]||o[0]<n[0]),r=_(d.surface.isWebMercatorOnPlateeCarree,d.ellipsoid.radius,M);return(t,o,i)=>{const a=0===t?j[0]:j[2],c=0===o?j[1]:j[3],l=s?e(a,n[0],n[2]):a,u=s?e(c,n[1],n[3]):c,f=i;y=l*M,S=r(u),b=f}})():v;let L=0,R=0,O=0,T=0,D=0,P=0,A=0,E=0,U=0;const C=m&&t.tile.surface.isWebMercatorOnPlateeCarree,I=(t,e,n,o,s)=>{let r=0,i=0,a=0;if(m){const t=e*M,s=C?(Math.PI/2-2*Math.atan(Math.exp(-n/p)))*p:n*M;r=t-y,i=s-S,a=o-b}else{const s=V(t),c=t.tile,l=c.extent,u=c.extentInRadians,f=(e-l[0])/(l[2]-l[0]),d=(n-l[1])/(l[3]-l[1]),m=u[0]*(1-f)+u[2]*f,g=s(d),h=Math.cos(g),M=Math.sin(g),x=Math.sin(m),v=Math.cos(m),B=p+o;r=v*h*B-y,i=x*h*B-S,a=M*B-b}switch(s){case 0:A+=r,E+=i,U+=a;break;case 1:T-=r,D-=i,P-=a;break;case 2:A-=r,E-=i,U-=a;break;case 3:T+=r,D+=i,P+=a}},j=d.extent,w=n.clippingArea??X,N=j[0],H=j[2],q=j[1],W=j[3],F=[W>w[3],H>w[2],q<w[1],N<w[0]],k=Math.max(N,w[0]),G=Math.min(H,w[2]),J=Math.max(q,w[1]),Q=Math.min(W,w[3]),Z=t=>Math.max(w[0],Math.min(w[2],t)),$=t=>Math.max(w[1],Math.min(w[3],t)),tt=a.uvRange[0],et=a.uvRange[1],nt=a.uvRange[2],ot=a.uvRange[3],st=t=>{const e=i[t].cornerTiles;L=0,R=0,O=1,T=0,D=0,P=0,A=0,E=0,U=0;let n=1/0;for(let r=0;r<4;++r)n=Math.min(n,e[r]?.level??1/0);for(let r=0;r<4;++r){const t=e[r];Y[r]=t?.level===n?t:null}let o=1,s=0;for(let r=0;r<4;++r){const t=Y[r];t&&(o=Math.max(o,t?.renderData.geometryState.numVerticesPerSide),s=t.extent[2]-t.extent[0])}const a=s,c=o;g(c>1);const l=a/c;for(let i=0;i<4;++i){const t=Y[(i+3)%4],e=Y[i%4];if(!t&&!e)continue;const n=0===i?1:1===i?2:2===i?3:0,o=0===i?2:1===i?3:2===i?0:1;if(t&&e){const s=K[i][0]*l,a=K[i][1]*l,c=t.extent,u=Z(c[0===n||1===n?2:0]+s),f=$(c[0===n||3===n?3:1]+a),d=e.extent,m=Z(d[0===o||1===o?2:0]+s),g=$(d[0===o||3===o?3:1]+a),p=t.renderData,h=e.renderData,M=r(u,f,p.geometryState.samplerData),x=r(m,g,h.geometryState.samplerData);I(p,u,f,.5*(M+x),i)}else{const s=t??e,a=t?n:o,c=s.extent,u=K[i],f=Z(c[0===a||1===a?2:0]+u[0]*l),d=$(c[0===a||3===a?3:1]+u[1]*l),m=s.renderData,g=r(f,d,m.geometryState.samplerData);I(m,f,d,g,i)}}if(!m){const t=Math.sqrt(y*y+S*S+b*b);L=y/t,R=S/t,O=b/t}if(m||O*O<.999){const t=Math.sqrt(T*T+D*D+P*P);T/=t,D/=t,P/=t;const e=Math.sqrt(A*A+E*E+U*U);A/=e,E/=e,U/=e,L=P*E-D*U,R=T*U-P*A,O=D*A-T*E;const n=1/Math.sqrt(L*L+R*R+O*O);L*=n,R*=n,O*=n}};for(let V=0;V<4;++V){const o=V,a=(V+1)%4,m=0===V||1===V?1:0,p=0===V||3===V?1:0,h=e(m,tt,nt),M=e(p,et,ot),v=u[o],T=0===V||3===V?v.count-1:0,D=u[a],P=0===V||1===V?D.count-1:0,A=i[V].cornerTiles;let E=-1;for(let t=0;t<4;++t){const e=A[t];e&&(-1===E||x(A[E],e)>0)&&(E=t)}const U=E,C=A[U];if(C!==d){const e=d.level-C.level,n=2**e,o=[C.lij[0]+e,C.lij[1]*n,C.lij[2]*n],s=[o[1]+n===d.lij[1],0===V&&(1===U||0===U&&C!==A[3])||1===V&&(0===U||1===U&&C!==A[2]),o[1]===d.lij[1]+1,2===V&&(3===U||2===U&&C!==A[1])||3===V&&(2===U||3===U&&C!==A[0])],r=s.reduce(((t,e)=>t+(e?1:0)),0);g(1===r||2===r);let i=-1,a=-1;const u=C.renderData;if(1===r){const e=s.findIndex((t=>t));g(0<=e&&e<=3),i=(e+2)%4;const n=t.geometryState.neighborData.edgeResolutions[e];a=d.getNeighborEdgeStartVertexIndex(e,C)*n+n*(0===e&&0===V||1===e&&0===V||2===e&&1===V||3===e&&3===V?1:0)}else{g(s[1]||s[3]),i=s[1]?3:1;const t=u.geometryState.neighborData.edgeResolutions[i];a=0===V||3===V?0:t}const m=u.geometry.outerEdges[i];{const e=v.index0+T*v.stride,n=D.index0+P*D.stride,o=m.index0+a*m.stride;{const s=m.attributes.position,r=s.typedBuffer,i=o*s.typedBufferStride,a=t.localOrigin,l=m.localOrigin,u=r[i]+l[0]-a[0],d=r[i+1]+l[1]-a[1],g=r[i+2]+l[2]-a[2];c(u,d,g,f);{const t=v.attributes.position,n=t.typedBuffer,o=e*t.typedBufferStride;n[o]=u,n[o+1]=d,n[o+2]=g}{const t=D.attributes.position,e=t.typedBuffer,o=n*t.typedBufferStride;e[o]=u,e[o+1]=d,e[o+2]=g}}l(v.attributes.uv0,e,h,M),l(D.attributes.uv0,n,h,M);{const t=m.attributes.normalCompressed.typedBuffer,s=o*m.attributes.normalCompressed.typedBufferStride;{const n=v.attributes.normalCompressed,o=n.typedBuffer,r=e*n.typedBufferStride;o[r]=t[s],o[r+1]=t[s+1]}{const e=D.attributes.normalCompressed,o=e.typedBuffer,r=n*e.typedBufferStride;o[r]=t[s],o[r+1]=t[s+1]}}}}else{const t=F[o],i=F[a];let l;if(t||i){const t=e(N*(1-m)+H*m,k,G),o=e(q*(1-p)+W*p,J,Q),s=n.samplerData;l=r(t,o,s)}else l=z(A);B(m,p,l),st(V);const u=y-s[0],d=S-s[1],g=b-s[2];c(u,d,g,f),v.setVertexFromValuesRawPositionUVNormal(T,u,d,g,h,M,L,R,O),D.setVertexFromValuesRawPositionUVNormal(P,u,d,g,h,M,L,R,O)}}for(let e=0;e<4;++e)Y[e]=null}function z(t){const e=t.reduce(((t,e)=>Math.min(t,e?.level??1/0)),1/0);m&&(g(!t[0]||!t[2]||M(t[0],t[2],a.SOUTH_WEST)),g(!t[1]||!t[3]||M(t[1],t[3],a.NORTH_WEST)));let n=0,o=0;for(let i=0;i<4;++i){const s=t[i];if(s&&s.level===e){const t=0===i||1===i,e=0===i||3===i,a=s.extent,c=a[t?0:2],l=a[e?1:3],u=s.renderData?.geometryState?.samplerData;o+=r(c,l,u),n++}}const s=n?o/n:0;return g(null!=s),s}function J(t){const e=t.vao,n=t.geometry.vertexAttributes.position.typedBuffer;e.vertexBuffers.geometry.setSubData(n,0,0,n.length)}const K=[[0,1],[1,0],[0,-1],[-1,0]],Q=new f,X=s(-1/0,-1/0,1/0,1/0),Y=[null,null,null,null];function Z(t,e,n){if(!e)return!1;const o=x(t,e);return o>0||0===o&&n>=2}export{E as createPlanarGlobePatch,b as createSphericalGlobePatch,L as updateCornerSpherical,C as updateCornersPlanar,I as updateEdgesAndCornersPlanar,B as updateEdgesAndCornersSpherical};
