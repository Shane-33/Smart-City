/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{isPowerOfTwo as t}from"../../../core/mathUtils.js";import{disposeMaybe as r}from"../../../core/maybe.js";import{o as i,r as s,k as o,f as a,n,j as l,u as h,G as d}from"../../../chunks/vec3.js";import{c as g,g as u}from"../../../chunks/vec3f64.js";import{empty as c}from"../../../geometry/support/aaBoundingBox.js";import{containsXY as m}from"../../../geometry/support/aaBoundingRect.js";import{earth as p}from"../../../geometry/support/Ellipsoid.js";import{glLayout as f}from"../support/buffer/glUtil.js";import{GeometryState as y}from"./GeometryState.js";import{NeighborIndex as _}from"./ITile.js";import{LayerClass as x}from"./LayerClass.js";import{PatchGeometry as D}from"./PatchGeometry.js";import{enableTerrainInternalChecks as v,internalAssert as C,neighborEdgeIndices as S,oppositeEdge as $,neighborCornerIndices as E,v32s as b,lij2s as T}from"./terrainUtils.js";import{TextureFader as j,ActivationTime as A}from"./TextureFader.js";import{isEdgeNeighbor as V}from"./Tile.js";import R from"./TileOverlayData.js";import{fallsWithinLayer as w}from"./tileUtils.js";import{VertexArrayObject as L}from"../webgl-engine/lib/VertexArrayObject.js";import{terrainVertexAttributeLocations as P}from"../webgl-engine/shaders/TerrainTechnique.js";import{BufferObject as N}from"../../webgl/BufferObject.js";import{PixelFormat as G}from"../../webgl/enums.js";class I{constructor(){this.geometry=new D,this.intersectionData=null,this.geometryState=null,this._textureRef=new j((()=>this.tile.surface.textureFadeDuration)),this.overlay=new R,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._dirtyEdgeResolutions=15,this._dirtyEdges=15,this._dirtyCorners=15}get tile(){return this._tile}init(e){this.clear(),this._tile=e;const t=this.geometry;t.indices=null,t.vertexAttributes=null,c(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new y,this.localOrigin=null,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),v&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)C(this.geometry.outerEdges[t].count===this.geometryState.neighborData.edgeResolutions[t]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,o=S[e];if(!t)return C(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(o)),i;if(t.isLoaded){const r=t,o=r.renderData.geometryState,a=s-r.level;if(C(a>=0),0===a){const e=o.numVerticesPerSide-1;return Math.max(e,i)}const n=2**a,l=o.neighborData.edgeResolutions[(e+2)%4]/n;return Math.max(1,l)}C(!t.isLeaf);let a=i;return t.forAllSubtreeOnSide($(o),(e=>e===r||(e.isLoaded?(a=Math.max(a,2**(e.level-s)),!0):(C(!e.isLeaf),!1)))),a}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const r=e.renderData.geometryState.neighborData,i=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=r.edgePeerNeighbors,o=r.edgePeerNeighborSamplerVersions;for(let n=0;n<4;++n){const a=e.findNeighborTile(S[n],i),l=W(e,a),h=l?.renderData?.geometryState.samplerDataVersion??-1,d=s[n],g=l!==W(e,d),u=o[n]!==h;s[n]=a,(g||u)&&(o[n]=h,this._markEdgeDirty(n));const c=r.edgeResolutions[n],m=this._calculateEdgeResolution(n,a);C(t(m)),C(m>=1),r.edgeResolutions[n]=m,c!==m&&this._markEdgeResolutionDirty(n)}const a=r.cornerPeerNeighbors;for(let t=0;t<4;++t){const o=e.findNeighborTile(E[t],i);a[t]=o;const n=W(e,s[t]),l=W(e,s[(t+1)%4]),h=W(e,o);H[t]=h,H[(t+1)%4]=l,H[(t+2)%4]=e,H[(t+3)%4]=n,C(H.some((t=>t?.isLoaded||t===e)));const d=H.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);H.forEach(((e,t)=>{e&&e?.level>d&&(H[t]=null)})),C(H.some((t=>t?.isLoaded||t===e)));const g=r.cornerNeighborData[t].cornerTiles,u=r.cornerNeighborData[t].cornerTileSamplerVersions;for(let e=0;e<4;++e){const r=H[e],i=r?.renderData.geometryState.samplerDataVersion??-1,s=g[e]!==r,o=!s&&u[e]!==i;(s||o)&&(g[e]=r,u[e]=i,this._markCornerDirty(t))}C(g.some((t=>t?.isLoaded||t===e)))}v&&C(this.geometryState.neighborData.edgeResolutions.every((e=>e>0)));for(let t=0;t<4;++t)H[t]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;v&&C(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const t=this.tile,r=this._vao,i=this.geometry.vertexAttributes,s=!r||!i||this._wireframeChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions,o=!s&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),a=!o&&0!==this._dirtyCorners;s?(this.releaseGeometry(),this._createGeometry(e)):o||a?t.updateEdgeElevations():a?t.updateCornerElevations():console.warn("Update for no reason?"),this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._dirtyEdgeResolutions=0,this._dirtyEdges=0,this._dirtyCorners=0,this._clippingAreaChanged=!1,this._wireframeChanged=!1}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao=r(this._vao),this.geometry.release(),!0)}ensureTexture(e,t,r){const i=t?G.RGBA:G.RGB;return null==this._texture||this._texture.descriptor.width===e&&this._texture.descriptor.pixelFormat===i||this.releaseTexture(),null==this._texture&&(this._texture=r(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){null!=this._texture&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}_markCornerDirty(e){const t=1<<e;this._dirtyCorners|=t}_markEdgeDirty(e){const t=1<<e;this._dirtyEdges|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e;this._dirtyEdgeResolutions|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._dirtyCorners=15,this._dirtyEdges=15,this._dirtyEdgeResolutions=15}updateGeometryState(){const t=this._getElevationInfo(),r=this.tile,i=t.samplerData?r.getElevationVerticesPerSide(t.maxTileLevel):r.getDefaultVerticesPerSide(),s=Math.max(i,5);let o=r.clippingArea;r.intersectsClippingArea&&!r.isWithinClippingArea||(o=null);const a=this.geometryState;let n=!1;a.numVerticesPerSide!==s&&(this._numVerticesPerSideChanged=!0,a.numVerticesPerSide=s,a.samplerDataVersion++,n=!0),t.changed&&(this._samplerDataChanged=!0,a.samplerData=t.samplerData,a.samplerDataVersion++,n=!0),e(a.clippingArea,o)||(this._clippingAreaChanged=!0,a.clippingArea=o,n=!0);const l=r.surface.wireframe;return a.wireframe!==l&&(this._wireframeChanged=!0,a.wireframe=l,n=!0),this._geometryStateChangedSinceLastUpdate||=n,n&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const t=this.geometry.vertexAttributes,r=this.geometry.indices,i=e.gl;this._vao=new L(e,P,{geometry:f(t.layout)},{geometry:N.createVertex(e,i.STATIC_DRAW,t.buffer)},N.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=A.Immediate){null!=e&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[x.ELEVATION],r=t.length,i=new Array(r);let s=0,o=0,a=!1;for(let h=0;h<r;h++){const r=t[h];if(null!=r.upsampleInfo){const t=r.upsampleInfo.tile,n=t.layerInfo[x.ELEVATION][h].data,l=n&&n.samplerData;e&&e[s]===l||(a=!0),i[s++]=l,o=Math.max(o,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(h,x.ELEVATION);if(w(this.tile,t.layer,!1)){const t=r.data;e&&e[s]===t.samplerData||(a=!0),i[s++]=t.samplerData,o=this.tile.level}}}null!=e&&e.length!==s&&(a=!0);const n=s>0,l=n?i:null;return n&&(i.length=s),{changed:a,samplerData:l,maxTileLevel:o}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){return{hasTexture:null!=this._texture}}checkGeometryWaterproofness(){if(!v)return;const e=this.tile;if(!e.isLoaded||!e.intersectsClippingArea||0===e.level)return void C(e?.isLoaded);const r=e.surface.extent;if(null!=r&&!e.intersectsExtent(r))return;const c=S.map(((t,i)=>null!=r&&(i<2?-1:1)*(e.extent[3-i]-r[3-i])<0)),f=e.level;C(0===this._dirtyCorners),C(0===this._dirtyEdges),C(0===this._dirtyEdgeResolutions),C(!this._numVerticesPerSideChanged),C(!this._samplerDataChanged),C(!this._clippingAreaChanged),C(!this._wireframeChanged);const y=E.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),x=this.geometryState.neighborData;for(let t=0;t<4;++t){const r=x.cornerPeerNeighbors[t],i=y[t];C(i===r,`Tile[${e.lij}].corner[${t}] out of date: cur=[${r?.lij}] exp=[${i?.lij}]`)}S.forEach(((r,y)=>{if(c[y])return;const x=e.findNeighborTile(r,(e=>(e.level===f||e?.isLoaded)&&e?.intersectsClippingArea));if(!x){const t=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(r);return void C(!t)}C(x.isLoaded||x.level===e.level),C(x===this.geometryState.neighborData.edgePeerNeighbors[y]);const D=f-x.level;if(!x.isLoaded)return C(!x.isLeaf),void C(0===D);const v=x.renderData;C(V(e,x,r)),C(D>=0);const S=2**D;if(D<0)return void C(!1);const $=e.renderData,E=$.geometry,j=E.outerEdges[y],A=E.numVerticesPerSide-1,R=v.geometry;if(!R)return void C(!1);const w=this.geometryState.neighborData.edgePeerNeighbors[y];if(w?.isLoaded){const e=w.renderData;C(w==w),C($.geometryState.neighborData.edgePeerNeighborSamplerVersions[y]===e.geometryState.samplerDataVersion),C(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[y]===e.geometryState.samplerDataVersion)}const L=(y+2)%4,P=R.outerEdges[L],N=j.count-1,G=P.count-1;C(N*S===G,`Tile[${e.lij}]:e${y},res=${N} edgeRes mismatch with Neighbor[${x.lij}]:e${L},res=${G} (expected:${N*S})`);const I=e.extent,H=r===_.NORTH||r===_.SOUTH,W=P.count-1,q=W/2**D,z=j.count-1;if(q<1)return void C(1===z);C(q===z),C(t(q));const J=R.numVerticesPerSide-1;C(D>0||q===Math.max(J,A));const K=e.getNeighborEdgeStartVertexIndex(y,x);C(0<=K&&K<S);const Q=K*q;C(0<=Q&&Q<=W-q);let Y=0,Z=Q;j.getVertexPos(M,0),j.getVertexPos(O,j.count-1);const ee=i(M,O),te=Math.max(X,1e-4*ee);for(let t=0;t<=q;++t){j.getVertexPos(M,Y),P.getVertexPos(O,Z);const i=t/q,c=H?I[0]+i*(I[2]-I[0]):r===_.WEST?I[0]:I[2],f=H?r===_.SOUTH?I[1]:I[3]:I[1]+i*(I[3]-I[1]),D=e.surface.extent;if(null==D||m(D,c,f)){const t=s(M,O),r=o(M)-p.radius,i=o(O)-p.radius,m=t<te;if(!m){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${y}[${Y}/${j.count}] and [${x.lij}].edge${L}[${Z}/${P.count}]`),null!=D&&console.warn("  surface extent= ",D," x,y=",c,",",f);const s=g();a(s,$.localOrigin,v.localOrigin),o(s)>0&&console.warn(`   localOrigins: ${$.localOrigin} vs ${v.localOrigin} d=${o(s)} [${s}]`);(()=>{const t=u(M),r=u(O);e.updateEdgeElevations(),x.updateEdgeElevations(),j.getVertexPos(M,Y),P.getVertexPos(O,Z);const i=g();h(i,M,t),o(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${M} d=${o(i)} [${i}]`),h(i,O,r),o(i)>0&&console.warn(`  XXX Neighbor[${x.lij}] edge out of date: ${r} vs ${O} d=${o(i)} [${i}]`)})(),C(m,`Mismatch in tile [${e.lij}].edge[${y}][${Y}/${j.count}] vs neighbor [${x.lij}].edge[${L}][${Z}/${P.count}] ${b(M)} vs ${b(O)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}j.getNormal(k,Y),P.getNormal(U,Z),n(B,k),n(F,U);const _=l(B,F),S=1-_<.01||!1||e===x;if(!S){const t=g();h(t,k,U);const r=()=>`Mismatch in tile edge normal ${T(e.lij)} (${Y}/${j.count-1}) edge ${y} vs neighbor ${T(x.lij)}  (${Z}/${P.count-1}) nedge ${L} :${b(k)} vs ${b(U)}  dot = ${_} : ${b(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),x.updateEdgeElevations();const t=g(),r=g();j.getNormal(t,Y),P.getNormal(r,Z),d(k,t)||console.warn("Missing update in tile normal: ",b(k)," => ",b(t)),d(U,r)||console.warn("Missing update in neighbor normal: ",b(U)," => ",b(r))}C(S,r())}}Y+=1,Z+=1}}))}}const M=g(),O=g(),k=g(),U=g(),B=g(),F=g(),X=1,H=[null,null,null,null];function W(e,t){return t?.isLoaded||t===e?t:null}export{A as ActivationTime,I as PatchRenderData,W as neighborTileIfLoadedOrSelf};
