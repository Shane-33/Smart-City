/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{f as e,c as t}from"../../../chunks/vec3f64.js";import r from"../../../geometry/SpatialReference.js";import{projectVectorToVector as i}from"../../../geometry/projection/projectVectorToVector.js";import{wrap as a}from"../../../geometry/support/aaBoundingBox.js";import{create as s}from"../../../geometry/support/aaBoundingRect.js";import{isPlateCarree as o}from"../../../geometry/support/spatialReferenceUtils.js";import{TileFrustumVisibility as n}from"./ITile.js";import{createPlanarGlobePatch as l,updateCornersPlanar as c,updateEdgesAndCornersPlanar as h}from"./PatchGeometryFactory.js";import{Tile as u,CenterPosition as d}from"./Tile.js";import{intersectAabbInvDirBefore as m}from"../webgl-engine/materials/internal/MaterialUtil.js";class p extends u{constructor(e,t,r,i,a){super(),this._horizontalScaleFactor=1,this._extentInRenderSR=s(),this._baseUsedMemory=900,this.init(e,t,r,i,a)}init(t,a,s,n,l){super.init(t,a,s,n,l);const c=l.view.renderSpatialReference,h=l.spatialReference,u=null!=c&&o(c)&&null!=h&&h.isGeographic?this.ellipsoid.radius*Math.PI/180:1;this._horizontalScaleFactor=u;const d=this.surface.isWebMercatorOnPlateeCarree,m=this._extentInRenderSR,p=this.extent;if(d){const t=e(p[0],p[1],0);i(t,r.WebMercator,t,r.PlateCarree);const a=e(p[2],p[3],0);i(a,r.WebMercator,a,r.PlateCarree),m[0]=t[0],m[1]=t[1],m[2]=a[0],m[3]=a[1]}else for(let e=0;e<4;++e)m[e]=p[e]*u;this.centerAtSeaLevel[0]=.5*(m[0]+m[2]),this.centerAtSeaLevel[1]=.5*(m[1]+m[3]),this.centerAtSeaLevel[2]=0,this._edgeLen=Math.max(m[2]-m[0],m[3]-m[1]),this._edgeLen2=this._edgeLen*this._edgeLen,this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateCenter();const e=this._extentInRenderSR,t=.5*(e[2]-e[0]),r=.5*(e[3]-e[1]),i=Math.sqrt(t*t+r*r),a=.5*(this.elevationBounds[0]-this.elevationBounds[1]),s=Math.max(i,a);this._center[d.MIDDLE][3]=s}_calculateFrustumVisibilityStatus(e){const t=this._aabb(),r=t[0],i=t[1],a=t[2],s=t[3],o=t[4],l=t[5];let c=!0;for(let h=0;h<6;h++){const t=e[h],u=t[0],d=t[1],m=t[2],p=t[3];if(u*(u>0?r:s)+d*(d>0?i:o)+m*(m>0?a:l)+p>=0)return n.OUTSIDE;c=c&&u*(u<0?r:s)+d*(d<0?i:o)+m*(m<0?a:l)+p<=0}return c?n.INSIDE:n.INTERSECTS}_aabb(){const e=this._extentInRenderSR;return a(e[0],e[1],this.elevationBounds[0],e[2],e[3],this.elevationBounds[1])}intersectsRay(e,t,r,i){return f[0]=1/t[0],f[1]=1/t[1],f[2]=1/t[2],m(this._aabb(),e,f,r,i)}createGeometry(){l(this.renderData,this._horizontalScaleFactor),this.setMemoryDirty()}getDefaultVerticesPerSide(){return this.level<9?3:2}updateCornerElevations(){c(this.renderData,this._horizontalScaleFactor)}updateEdgeElevations(){h(this.renderData,this._horizontalScaleFactor)}get horizontalScale(){return this._horizontalScaleFactor}}const f=t();export{p as PlanarPatch};
