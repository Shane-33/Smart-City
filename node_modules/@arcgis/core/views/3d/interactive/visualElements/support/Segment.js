/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{p as t,f as e,n as s,i as r,g as i,c as n}from"../../../../../chunks/vec3.js";import{c as o,g as p}from"../../../../../chunks/vec3f64.js";import{canProjectWithoutEngine as c}from"../../../../../geometry/projection.js";import{getSphericalPCPF as a}from"../../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectVectorToVector as h}from"../../../../../geometry/projection/projectVectorToVector.js";import{sv3d as d}from"../../../../../geometry/support/vectorStacks.js";import{slerpTangent as f,slerp as l}from"../../../support/mathUtils.js";class m{constructor(t=o(),e=o()){this.startRenderSpace=t,this.endRenderSpace=e,this.type="euclidean"}eval(r,i,n){return t(i,this.startRenderSpace,this.endRenderSpace,r),n&&(e(n,this.endRenderSpace,this.startRenderSpace),s(n,n)),i}createRenderGeometry(t,s){const r=[],i=[],n=(s,n)=>{const o=j;e(o,s,t),r.push([o[0],o[1],o[2]]),i.push([n[0],n[1],n[2]])},o=s.worldUpAtPosition(this.eval(.5,R),d.get());return n(this.startRenderSpace,o),n(this.endRenderSpace,o),{points:r,normals:i}}static fromPositionAndVector(t,e,s=1){return r(R,e,s),i(R,t,R),new m(p(t),p(R))}}class _{_projectIn(t,e){this._project?h(t,this.renderSpatialReference,e,this._pcpf):n(e,t)}constructor(t,e,s){this.startRenderSpace=t,this.endRenderSpace=e,this.renderSpatialReference=s,this.type="geodesic",this._start=o(),this._end=o(),this._pcpf=a(s),this._project=c(s,this._pcpf),this._projectIn(t,this._start),this._projectIn(e,this._end)}eval(r,n,o){if(this._project)if(o){const t=j;f(this._start,this._end,r,n,t),i(u,n,t),h(n,this._pcpf,n,this.renderSpatialReference),h(u,this._pcpf,u,this.renderSpatialReference),e(o,u,n),s(o,o)}else l(this._start,this._end,r,n),h(n,this._pcpf,n,this.renderSpatialReference);else t(n,this._start,this._end,r),o&&(e(o,this._end,this._start),s(o,o));return n}createRenderGeometry(t,s){const r=[],i=[],n=(s,n)=>{const o=u;e(o,s,t),r.push([o[0],o[1],o[2]]),i.push([n[0],n[1],n[2]])},o=128+1&-2;for(let e=0;e<o;++e){const t=e/(o-1),r=R,i=j;this.eval(t,r),s.worldUpAtPosition(r,i),n(r,i)}return{points:r,normals:i}}}const R=o(),j=o(),u=o();export{m as EuclideanSegment,_ as GeodesicSegment};
