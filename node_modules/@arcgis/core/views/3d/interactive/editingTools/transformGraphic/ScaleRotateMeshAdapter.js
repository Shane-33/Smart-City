/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import e from"../../../../../core/Accessor.js";import{deg2rad as o,rad2deg as i}from"../../../../../core/mathUtils.js";import{when as r,sync as n}from"../../../../../core/reactiveUtils.js";import{property as s}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import{subclass as a}from"../../../../../core/accessorSupport/decorators/subclass.js";import{i as l}from"../../../../../chunks/vec3.js";import{create as c,axis as p,angle as g,composeAxes as h,compose as u}from"../../../../../geometry/support/axisAngleDegrees.js";import m from"../../../../../geometry/support/MeshTransform.js";import{ViewingMode as d}from"../../../../ViewingMode.js";import{createGraphicGeometryUndoRecord as y}from"./undoRecords.js";let v=class extends e{constructor(t){super(t),this._interactionState=null}initialize(){this.addHandles([r((()=>{const t=this._interactionState;return t&&t.angle!==t.previousAngle?{interactionState:t,angle:t.state.angle}:null}),(({interactionState:t})=>{this._updateMeshRotation(t)}),n),r((()=>{const t=this._interactionState;return t&&t.scale!==t.previousScale?{interactionState:t,scale:t.state.scale}:null}),(({interactionState:t})=>{this._updateMeshSize(t)}),n)])}get initialAngle(){return this._interactionState?.initialAngle??0}get angle(){const t=this.geometry.transform;if(null==t)return this._interactionState?.angle??0;const e=p(t.rotation)[2];return Math.abs(e)>.999999?o(g(t.rotation))*Math.sign(e):0}get angleClockwise(){return-this.angle}get relativeAngle(){return this.angle-this.initialAngle}get relativeAngleClockwise(){return-this.relativeAngle}get scale(){return this._interactionState?.scale??1}startInteraction(){const t=new f({angle:this.angle});this._interactionState=t;const e=()=>{this._interactionState=null};return{state:t,done:e,cancel:()=>{t.cancel(),e()}}}createUndoRecord(){return y(this.graphic)}_updateMeshRotation(t){const{angle:e,previousAngle:o}=t;t.previousAngle=e;const{geometry:r}=this,{vertexSpace:n}=r,s=i(e-o);if(n.isGeoreferenced){const t=!n.isRelative&&this.viewingMode===d.Global,e=this.geometry.anchor;this.geometry.rotate(0,0,s,{origin:e,geographic:t}),this.graphic.notifyGeometryChanged()}else{r.transform??=new m;const{transform:t}=r,e=h(0,0,s,S);t.rotation=u(t.rotation,e,t.rotation),this.graphic.notifyMeshTransformChanged()}}_updateMeshSize(t){const{scale:e,previousScale:o}=t;t.previousScale=e;const{geometry:i}=this,{vertexSpace:r}=i,n=e/o;if(r.isGeoreferenced){const t=!r.isRelative&&this.viewingMode===d.Global,e=this.geometry.anchor;this.geometry.scale(n,{origin:e,geographic:t}),this.graphic.notifyGeometryChanged()}else{i.transform??=new m;const{transform:t}=i;t.scale=l(t.scale,t.scale,n),this.graphic.notifyMeshTransformChanged()}}};t([s({constructOnly:!0})],v.prototype,"graphic",void 0),t([s({constructOnly:!0})],v.prototype,"geometry",void 0),t([s({constructOnly:!0})],v.prototype,"viewingMode",void 0),t([s()],v.prototype,"initialAngle",null),t([s()],v.prototype,"angle",null),t([s()],v.prototype,"angleClockwise",null),t([s()],v.prototype,"relativeAngle",null),t([s()],v.prototype,"relativeAngleClockwise",null),t([s()],v.prototype,"scale",null),t([s()],v.prototype,"_interactionState",void 0),v=t([a("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateMeshAdapter")],v);let f=class extends e{get state(){const{angle:t,scale:e}=this;return{angle:t,scale:e}}constructor(t){super(t),this.angle=0,this.initialAngle=0,this.previousAngle=0,this.previousScale=1,this.scale=1,this.initialAngle=t.angle,this.previousAngle=t.angle}cancel(){this.angle=this.initialAngle,this.scale=1}};t([s()],f.prototype,"angle",void 0),t([s()],f.prototype,"initialAngle",void 0),t([s()],f.prototype,"previousAngle",void 0),t([s()],f.prototype,"previousScale",void 0),t([s()],f.prototype,"scale",void 0),t([s()],f.prototype,"state",null),f=t([a("InteractionState")],f);const S=c();export{v as ScaleRotateMeshAdapter};
