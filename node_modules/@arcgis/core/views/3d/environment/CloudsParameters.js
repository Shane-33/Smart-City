/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{clamp as t}from"../../../core/mathUtils.js";import{k as a}from"../../../chunks/mat4.js";import{I as i,a as s}from"../../../chunks/mat4f64.js";import{l as e,n as o,i as r,f as h,c as n}from"../../../chunks/vec3.js";import{c as d,f as c}from"../../../chunks/vec3f64.js";import{create as F,fromPoints as f,axis as p}from"../../../geometry/support/axisAngleDegrees.js";import{earth as l}from"../../../geometry/support/Ellipsoid.js";import{CloudsTextureChannels as u,CloudsRenderingStages as _,ensureClouds as D}from"./CloudsData.js";import{weatherHeightLimit as E}from"./weather.js";import{RenderState as m}from"../../support/RenderState.js";class A{constructor(){this.readChannels=u.RG,this.renderingStage=_.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=d(),this.parallax=new C,this.parallaxNew=new C,this.pointOnGround=d(),this.fadeMode=O.HIDE,this.fadeFactor=0,this.opacity=0}updateParallax(t){const s=this.parallax,o=e(t.eye);if(s.radiusCurvatureCorrectionFactor=.84*Math.sqrt(Math.max(o*o-l.radius*l.radius,0))/o,f(S,s.anchorPointClouds,g),a(s.transform,i,g[3],p(g)),this.fadeMode===O.CROSS_FADE){const t=this.parallaxNew;f(S,t.anchorPointClouds,g),a(t.transform,i,g[3],p(g))}}updateFading(t,a,i,s){this.isFading&&this._advanceFading(i,s),this._evaluateFading(t,a,i)}_evaluateFading(t,a,i){const s=t.relativeElevation,e=this._calculateDistanceToAnchorPoint(t);if((s>1.7*E||s<-E||e>v)&&this.opacity>0)this._setFade(O.HIDE,i);else if(!this.isFading)if((s>E||s<-.35*E||e>M)&&this.opacity>0)this._setFade(O.FADE_OUT,i);else if(s<=E&&s>=-.35*E&&a===m.IDLE&&D(this.data)){if(0===this.opacity)return void this._setFade(O.FADE_IN,i);(e>y||this.renderingStage===_.FADING)&&this._setFade(O.CROSS_FADE,i)}}_advanceFading(t,a){this._switchReadChannels(),this._updateAnchorPoint(),this._advanceFadingFactorAndOpacity(t,a)}_advanceFadingFactorAndOpacity(a,i){if(this.fadeFactor<1)return this.fadeFactor=i?t((a-this.startTime)/(I*i),0,1):1,this.fadeMode===O.FADE_OUT&&(this.opacity=1-this.fadeFactor),this.fadeMode===O.FADE_IN&&(this.opacity=this.fadeFactor),void(this.fadeMode===O.CROSS_FADE&&(this.opacity=1));this.fadeFactor=0,this.fadeMode===O.FADE_OUT&&(this.opacity=0),this.fadeMode===O.FADE_IN&&(this.opacity=1),this.fadeMode===O.CROSS_FADE&&(this.opacity=1),this.fadeMode=O.NONE}_switchReadChannels(){const t=this.fadeMode===O.CROSS_FADE&&1===this.fadeFactor,a=this.fadeMode===O.FADE_IN&&0===this.fadeFactor;this.renderingStage===_.FADING&&(t||a)&&(this.readChannels=1-this.readChannels,this.renderingStage=_.FINISHED)}_calculateDistanceToAnchorPoint(t){return o(this.pointOnGround,t.eye),r(this.pointOnGround,this.pointOnGround,l.radius),e(h(N,this.parallax.anchorPointClouds,this.pointOnGround))}_updateAnchorPoint(){this.fadeMode===O.CROSS_FADE&&(0===this.fadeFactor&&n(this.parallaxNew.anchorPointClouds,this.pointOnGround),1===this.fadeFactor&&n(this.parallax.anchorPointClouds,this.parallaxNew.anchorPointClouds)),this.fadeMode===O.FADE_IN&&0===this.fadeFactor&&n(this.parallax.anchorPointClouds,this.pointOnGround)}_setFade(t,a){switch(t){case O.HIDE:this.opacity=0;break;case O.FADE_OUT:this.opacity=1;break;case O.FADE_IN:this.opacity=0;break;case O.CROSS_FADE:this.opacity=1}this.fadeMode=t,this.fadeFactor=0,this.startTime=a}get isFading(){return this.fadeMode===O.FADE_OUT||this.fadeMode===O.FADE_IN||this.fadeMode===O.CROSS_FADE}}var O;!function(t){t[t.NONE=0]="NONE",t[t.HIDE=1]="HIDE",t[t.FADE_OUT=2]="FADE_OUT",t[t.FADE_IN=3]="FADE_IN",t[t.CROSS_FADE=4]="CROSS_FADE"}(O||(O={}));class C{constructor(){this.anchorPointClouds=d(),this.radiusCurvatureCorrectionFactor=0,this.transform=s()}}const S=c(0,0,1),g=F(),N=d(),I=1.25,y=34e3,M=64e3,v=2e5;export{A as CloudsParameters,O as FadeMode,y as crossFadeDistanceThreshold,M as fadeOutDistanceThreshold,v as hideDistanceThreshold};
