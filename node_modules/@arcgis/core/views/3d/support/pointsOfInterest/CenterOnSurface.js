/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{clamp as e}from"../../../../core/mathUtils.js";import{removeMaybe as r,destroyMaybe as s}from"../../../../core/maybe.js";import{property as i}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import{subclass as o}from"../../../../core/accessorSupport/decorators/subclass.js";import{c as a,o as n,i as c,g as u,h as l,m as d}from"../../../../chunks/vec3.js";import{c as p}from"../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as h}from"../../../../geometry/ellipsoidUtils.js";import f from"../../../../geometry/Point.js";import{projectBoundingRect as m}from"../../../../geometry/projection/projectBoundingRect.js";import{create as _}from"../../../../geometry/support/aaBoundingRect.js";import{debugFlags as S}from"../debugFlags.js";import{PropertiesPool as y}from"../PropertiesPool.js";import{PointOfInterest as g}from"./PointOfInterest.js";import{Task as A}from"../../../support/Scheduler.js";const j=Array;let L=class extends g{constructor(t){super(t),this._propertiesPool=new y({location:f,renderLocation:j},this),this._currentSurfaceAltitude=0,this._latestSurfaceAltitude=0,this.distance=0,this.renderLocation=p(),this.updating=!1}initialize(){this._frameWorker=this.scheduler.registerTask(this.task,this),this.runTask()}destroy(){this._frameWorker=r(this._frameWorker),this._propertiesPool=s(this._propertiesPool)}get _camera(){return this.state.contentCamera}get location(){const t=this._propertiesPool.get("location");return this.renderCoordsHelper.fromRenderCoords(this.renderLocation,t,this.state.spatialReference),t}updateRenderLocation(){this.updating=!0,this._updateRenderLocation()}get estimatedSurfaceAltitude(){return this._latestSurfaceAltitude}get running(){return this.updating}runTask(){return this._latestSurfaceAltitude=this.estimateSurfaceAltitudeAtCenter(),this._updateRenderLocation(),this.updating=!1,A.YIELD}_updateRenderLocation(){const t=v;let e=this._calculateSurfaceIntersection(this._currentSurfaceAltitude,t);const r=this._currentSurfaceAltitude!==this._latestSurfaceAltitude;!e&&r&&(e=this._calculateSurfaceIntersection(this._latestSurfaceAltitude,t),e&&(this._currentSurfaceAltitude=this._latestSurfaceAltitude));const s=C;e&&this._latestSurfaceAltitudeChangesDistanceSignificantly(t,s)&&(a(t,s),this._currentSurfaceAltitude=this._latestSurfaceAltitude),e?this.distance=n(this._camera.eye,t):(c(t,this._camera.viewForward,this._get("distance")),u(t,t,this._camera.eye)),l(this._get("renderLocation"),t)||this._set("renderLocation",a(this._propertiesPool.get("renderLocation"),t))}_calculateSurfaceIntersection(t,r){const s=this._camera;if(!this.renderCoordsHelper.intersectInfiniteManifold(s.ray,t,r))return!1;if(this.state.isGlobal){const e=h(this.renderCoordsHelper.spatialReference).radius,i=e+t,o=d(s.eye),a=o<i*i,l=n(s.eye,r);if(a&&l>e/4){const t=i-Math.sqrt(o);return c(r,s.viewForward,t),u(r,r,s.eye),!0}}else{const t=this.surface?.ready?this.surface.extent:null;null!=t&&m(t,this.surface?.spatialReference,I,this.renderCoordsHelper.spatialReference)&&(r[0]=e(r[0],I[0],I[2]),r[1]=e(r[1],I[1],I[3]))}return!0}_latestSurfaceAltitudeChangesDistanceSignificantly(t,e){if(this._latestSurfaceAltitude===this._currentSurfaceAltitude||null==t)return!1;if(this._calculateSurfaceIntersection(this._latestSurfaceAltitude,e)){if(S.TESTS_DISABLE_OPTIMIZATIONS)return!0;const r=this._camera.eye,s=n(r,t),i=n(r,e);if(Math.abs(i-s)/s>k)return!0}return!1}};t([i({constructOnly:!0})],L.prototype,"scheduler",void 0),t([i({constructOnly:!0})],L.prototype,"task",void 0),t([i()],L.prototype,"distance",void 0),t([i({constructOnly:!0})],L.prototype,"estimateSurfaceAltitudeAtCenter",void 0),t([i({readOnly:!0})],L.prototype,"location",null),t([i({readOnly:!0})],L.prototype,"renderLocation",void 0),t([i()],L.prototype,"updating",void 0),L=t([o("esri.views.3d.support.CenterOnSurface")],L);const k=.05,v=p(),C=p(),I=_();export{L as CenterOnSurface};
