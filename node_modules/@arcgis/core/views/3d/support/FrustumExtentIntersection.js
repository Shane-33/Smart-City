/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{neverReached as t}from"../../../core/compilerUtils.js";import{lerp as e}from"../../../core/mathUtils.js";import{i}from"../../../chunks/mat4.js";import{a as r}from"../../../chunks/mat4f64.js";import{g as n,i as o,C as s,e as a,s as c,j as p}from"../../../chunks/vec3.js";import{c as l}from"../../../chunks/vec3f64.js";import{getReferenceEllipsoid as h}from"../../../geometry/ellipsoidUtils.js";import{computeTranslationToOriginAndRotation as d}from"../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{projectBoundingRect as _}from"../../../geometry/projection/projectBoundingRect.js";import{projectVectorToVector as m}from"../../../geometry/projection/projectVectorToVector.js";import{create as g,empty as u,expandWithVec3 as f}from"../../../geometry/support/aaBoundingBox.js";import{create as x,center as R}from"../../../geometry/support/aaBoundingRect.js";import{PlaneIndex as y}from"../../../geometry/support/frustum.js";import{create as j,fromPoints as A}from"../../../geometry/support/lineSegment.js";import{create as b,fromVectorsAndPoint as E,copy as S,negate as C,signedDistance as B}from"../../../geometry/support/plane.js";import{wrap as H}from"../../../geometry/support/ray.js";import{ViewingMode as w}from"../../ViewingMode.js";import{frustumLineSegment as G}from"./intersectionUtils.js";const M=.5*Math.PI,F=M/Math.PI*180;class N{constructor(t){this._renderCoordsHelper=t.renderCoordsHelper,this._extent=new Array(4),this._planes=new Array(6),this._maxSpan=0,this._center={origin:l(),direction:l()};for(let e=0;e<4;e++)this._extent[e]={origin:l(),direction:l(),cap:{next:null,direction:l()}},this._planes[e]=b();this._planes[y.NEAR]=b(),this._planes[y.FAR]=b(),this._planesWithoutFar=this._planes.slice(0,5)}update(t,e,i,r=!0){const a=this._extent;this._toRenderBoundingExtent(t,e,i),n(this._center.origin,a[0].origin,a[2].origin),o(this._center.origin,this._center.origin,.5),this._renderCoordsHelper.worldUpAtPosition(this._center.origin,this._center.direction),r||o(this._center.direction,this._center.direction,-1);for(let n=0;n<4;n++){const t=a[n];this._renderCoordsHelper.worldUpAtPosition(t.origin,t.direction);const e=a[3===n?0:n+1];t.cap.next=e.origin,s(t.cap.direction,t.origin,e.origin),E(t.direction,t.cap.direction,t.origin,this._planes[n]),r||o(t.direction,t.direction,-1)}E(a[0].cap.direction,a[1].cap.direction,a[0].origin,this._planes[y.NEAR]),r?C(this._planes[y.NEAR],this._planes[y.FAR]):(S(this._planes[y.FAR],this._planes[y.NEAR]),C(this._planes[y.NEAR],this._planes[y.NEAR])),this._maxSpan=Math.max(Math.abs(t[0]-t[2]),Math.abs(t[1]-t[3])),this._maxSpanSpatialReference=e,this._minGlobalAltitude=.9*h(this._maxSpanSpatialReference).radius}isVisibleInFrustum(t,e,i=!1){if(null==t)return!1;if(this._renderCoordsHelper.viewingMode===w.Global){const i=this._maxSpanSpatialReference.isGeographic?F:M*e;if(this._maxSpan>i)return!0;if(null!=t.altitude&&t.altitude>=this._minGlobalAltitude)return this._isVisibleInFrustumGlobal(t)}if(0===this._maxSpan){const e=this._extent[0];return!(i||!t.intersectsRay(H(e.origin,e.direction)))}for(let n=0;n<this._extent.length;n++){const e=this._extent[n];if(!i&&t.intersectsRay(H(e.origin,e.direction)))return!0;if(t.intersectsLineSegment(A(e.origin,e.cap.next,P),e.cap.direction))return!0}const r=i?this._planes:this._planesWithoutFar;for(let n=0;n<t.lines.length;n++){const e=t.lines[n];if(G(r,e.origin,e.endpoint,e.direction))return!0}return!1}_toRenderBoundingExtentGlobal(t,r,n){const o=5;R(t,U),U[2]=n,d(r,U,V,this._renderCoordsHelper.spatialReference),i(v,V),u(I);for(const{x0:i,x1:s,y0:c,y1:p}of k)for(let l=0;l<o;l++){const h=l/(o-1);U[0]=e(t[i],t[s],h),U[1]=e(t[c],t[p],h),U[2]=n,m(U,r,U,this._renderCoordsHelper.spatialReference),a(U,U,v),f(I,U)}c(this._extent[0].origin,I[0],I[1],I[2]),c(this._extent[1].origin,I[3],I[1],I[2]),c(this._extent[2].origin,I[3],I[4],I[2]),c(this._extent[3].origin,I[0],I[4],I[2]);for(let e=0;e<4;++e)a(this._extent[e].origin,this._extent[e].origin,V)}_toRenderBoundingExtentLocal(t,e,i){_(t,e,L,this._renderCoordsHelper.spatialReference),c(this._extent[0].origin,L[0],L[1],i),c(this._extent[1].origin,L[2],L[1],i),c(this._extent[2].origin,L[2],L[3],i),c(this._extent[3].origin,L[0],L[3],i)}_toRenderBoundingExtent(e,i,r){switch(this._renderCoordsHelper.viewingMode){case w.Global:this._toRenderBoundingExtentGlobal(e,i,r);break;case w.Local:this._toRenderBoundingExtentLocal(e,i,r);break;default:t(this._renderCoordsHelper.viewingMode)}}_isVisibleInFrustumGlobal(t){if(B(t.planes[y.NEAR],this._center.origin)<0&&p(this._center.direction,t.direction)<0)return!0;for(let e=0;e<4;e++){const i=this._extent[e];if(B(t.planes[y.NEAR],i.origin)<0&&p(i.direction,t.direction)<0)return!0}return!1}}const k=[{x0:0,y0:1,x1:2,y1:1},{x0:0,y0:3,x1:2,y1:3},{x0:0,y0:1,x1:0,y1:3},{x0:2,y0:1,x1:2,y1:3}],U=l(),V=r(),v=r(),I=g(),L=x(),P=j();export{N as FrustumExtentIntersection};
