/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import t from"../../../Camera.js";import"../../../geometry.js";import e from"../../../Graphic.js";import n from"../../../Viewpoint.js";import{result as a}from"../../../core/asyncUtils.js";import"../../../core/has.js";import{cyclicalDegrees as o}from"../../../core/Cyclical.js";import r from"../../../core/Error.js";import{throwIfAborted as i}from"../../../core/promiseUtils.js";import{f as s,t as c}from"../../../chunks/mat3.js";import{a as l}from"../../../chunks/mat3f64.js";import{a as m}from"../../../chunks/mat4f64.js";import{i as u,g as f,o as p,c as g,f as y,s as h,t as d}from"../../../chunks/vec3.js";import{c as w}from"../../../chunks/vec3f64.js";import{project as x,projectWithZConversion as j}from"../../../geometry/projection.js";import{computeTranslationToOriginAndRotation as v}from"../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{projectPointToVectorWithEngine as R}from"../../../geometry/projection/projectPointToVectorWithEngine.js";import{projectVectorToPoint as b}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as z}from"../../../geometry/projection/projectVectorToVector.js";import{create as G,empty as S,center as B,toRect as T,isPoint as M,expandWithVec3 as E,expandWithAABB as Z,width as A,height as F,depth as k}from"../../../geometry/support/aaBoundingBox.js";import{create as O,isPoint as P}from"../../../geometry/support/aaBoundingRect.js";import{intersectsPoint as D}from"../../../geometry/support/frustum.js";import{getResolutionInMetersForScale as U}from"../../../geometry/support/scaleUtils.js";import{cameraOnContentAlongViewDirection as V}from"../camera/intersectionUtils.js";import{getViewSR as C,fromExtentSync as I,fromExtentAsync as J,internalToExternal as K,OrientationMode as L,scaleToDistance as N,fromCenterDistanceSync as W,fromCenterDistanceAsync as Y,externalToInternal as q,computeScale as X,distanceToScale as _,fromCenterScale as H,directionToHeadingTilt as Q,zoomToScale as $}from"./cameraUtils.js";import{getElevationAtPoint as tt}from"./ElevationProvider.js";import et from"../../../geometry/Point.js";import nt from"../../../geometry/Extent.js";import at from"../../../geometry/SpatialReference.js";import ot from"../../../geometry/Geometry.js";import rt from"../../../geometry/Multipoint.js";const it=.66;function st(t){return 360-o.normalize(t)}function ct(t){return o.normalize(360-t)}function lt(t,e,n){const a=e.camera;if(null!=a)return ut(a,C(t));const{targetGeometry:o}=e;if(null==o)return null;const{camera:r,mode:i}=pt(t,e.rotation,n);if("point"===o.type)return gt(t,e,o,r,i);const s=o.extent;return null==s?null:I(t,s,r.heading,r.tilt,i)}async function mt(t,e,n,a){const o=e.camera;if(null!=o)return ft(o,C(t),a);const{targetGeometry:r}=e;if(null==r)throw new Error("Viewpoint has no targetGeometry!");const{camera:i,mode:s}=pt(t,e.rotation,n);if("point"===r.type)return yt(t,e,r,i,s,a);const c=r.extent;if(null==c)throw new Error("Target geometry has no extent!");return J(t,c,i.heading,i.tilt,s,a)}function ut(t,e){const n=t.position;let a;try{a=x(n,e)}catch(r){return null}const o=t.clone();return o.position=a.clone(),o}async function ft(t,e,n){const a=t.position,o=await j(a,e,{signal:n});i(n);const r=t.clone();return r.position=o.clone(),r}function pt(t,e,n){const a=K(t,t.state.camera);let o=L.ADJUST;return null!=e&&(a.heading=st(e),o=L.LOCKED),null!=n&&(a.tilt=n),{camera:a,mode:o}}function gt(t,e,n,a,o){const r=t.spatialReference;let i;try{i=x(n.clone(),r)}catch(c){return null}const s=null!=e.scale?N(t,e.scale,i.latitude):t.state.camera.distance;return W(t,i,s,a,o)}async function yt(t,e,n,a,o,r){const s=t.spatialReference,c=await j(n.clone(),s,{signal:r});i(r);const l=null!=e.scale?N(t,e.scale,c.latitude):t.state.camera.distance;return Y(t,c,l,a,o,r)}function ht(t,e,a=null){return null==a&&(a=new n),vt(t,null,e.clone(),a)}async function dt(e,a,o){const i=kt(e,a);if(!i)throw new r("viewpointutils-create:no-target","Missing target for creating viewpoint");const s=new t({fov:e.camera.fov}),c=new n({camera:s});if(i.target instanceof n){return Ot(await Gt(e,i.target,i,o,c))}if(i.target instanceof t)return Ot(await St(e,i.target,o,c));const l=null!=i.scale||null!=i.zoom;if(i.target instanceof nt){const t=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return Ot(l||t?await Tt(e,i,i.target.center,s,o,c):await Zt(e,i,i.target,s,o,c))}const m={boundingBox:S(),hasZ:!1,screenSpaceObjects:[]},u=l?xt(e,i):void 0;if(await zt(e,i.target,u,m,o),isFinite(m.boundingBox[0])){let t;if(B(m.boundingBox,Dt),Wt.x=Dt[0],Wt.y=Dt[1],Wt.z=Dt[2],Wt.spatialReference=e.spatialReference,isFinite(Wt.z)&&m.hasZ?t=M(m.boundingBox):(Wt.z=void 0,t=P(T(m.boundingBox,It))),l||t)return Ot(await Tt(e,i,Wt,s,o,c));const n=Pt(e,m.screenSpaceObjects);return Ot(await Ft(e,i,Wt,m.boundingBox,n,s,o,c))}return i.position?Ot(await Mt(e,i,s,c,o)):Ot(await Et(e,i,s,o,c))}function wt(t,e){return null==e.scale&&null!=e.zoom?$(t,e.zoom):e.scale}function xt(t,e){const n=wt(t,e);return n?U(n):void 0}function jt(t,e){let n=!1;return null!=e.heading?(t.heading=e.heading,n=!0):null!=e.rotation&&(t.heading=st(e.rotation),n=!0),null!=e.tilt&&(t.tilt=e.tilt,n=!0),null!=e.fov&&(t.fov=e.fov),n}function vt(t,e,n,a){const o=t.spatialReference||at.WGS84;return null==(e=null!=e?e:q(t,n))||(a.targetGeometry=b(e.center,t.renderSpatialReference,o),a.scale=X(t,e),a.rotation=ct(n.heading),a.camera=n),a}async function Rt(t,e,n,a){const o=()=>new r("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!e)throw o();"mesh"===e.type&&(e=e.extent);const i=e.spatialReference,s=t.spatialReference,c=t.basemapTerrain.spatialReference;if(!e.hasZ&&t.basemapTerrain){let n;switch(e.type){case"point":n=e;break;case"multipoint":case"polyline":n=e.extent?.center;break;case"extent":n=e.center;break;case"polygon":n=e.centroid}null!=n&&null!=c&&null!=t.elevationProvider?(n=await j(n,c,{signal:a}),Dt[2]=tt(t.elevationProvider,n)??0):Dt[2]=0}const l=Yt[e.type],m=new Array;if(l(e,e.hasZ?t=>{m.push([t[0],t[1],t[2]])}:t=>{m.push([t[0],t[1]])},Dt),0===m.length)throw o();const u=await j(new rt({spatialReference:i,hasZ:e.hasZ,hasM:!1,points:m}),s,{signal:a});if(e.hasZ&&(n.hasZ=!0),e.hasZ)for(const[r,f,p]of u.points)Dt[0]=r,Dt[1]=f,Dt[2]=p,E(n.boundingBox,Dt);else for(const[r,f]of u.points)Dt[0]=r,Dt[1]=f,E(n.boundingBox,Dt)}async function bt(t,e,n,o,r){const i=await a(t.whenViewForGraphic(e));if(!1===i.ok||null==i.value||!("whenGraphicBounds"in i.value))return void await Rt(t,e.geometry,o,r);const s=i.value,c=await a(s.whenGraphicBounds(e,{minDemResolution:n}));if(!1===c.ok||!c.value)return void await Rt(t,e.geometry,o,r);const{screenSpaceObjects:l,boundingBox:m}=c.value;Z(o.boundingBox,m),l&&l.forEach((t=>{o.screenSpaceObjects.push(t)})),isFinite(m[2])&&(o.hasZ=!0)}async function zt(t,n,a,o,r){if(Array.isArray(n)&&2===n.length){const e=n[0],a=n[1];if("number"==typeof e&&"number"==typeof a)return Wt.x=e,Wt.y=a,Wt.z=void 0,Wt.spatialReference=t.spatialReference?.isGeographic?t.spatialReference:at.WGS84,void await Rt(t,Wt,o,r)}n&&"map"in n&&"function"==typeof n.map?await Promise.allSettled(n.map((e=>zt(t,e,a,o,r)))):n instanceof ot?await Rt(t,n,o,r):n instanceof e&&await bt(t,n,a,o,r)}async function Gt(t,e,n,a,o){if(null!=e.camera)return St(t,e.camera,a,o);o.scale=e.scale,o.rotation=e.rotation,o.targetGeometry=null!=e.targetGeometry?e.targetGeometry.clone():null,o.camera=null,null!=n.heading?o.rotation=ct(n.heading):null!=n.rotation&&(o.rotation=n.rotation);const r=wt(t,n);return null!=r&&(o.scale=r),o.camera=await mt(t,o,n.tilt,a),o}async function St(t,e,n,a){const o=t.spatialReference,r=await j(e.position,o,{signal:n});return(e=e.clone()).fov=t.camera.fov,e.position=r,vt(t,null,e,a)}async function Bt(t,e,n,a,o,r,i){const s=t.renderSpatialReference;return await R(e,Lt,s,0,{signal:i}),await R(n,Kt,s,0,{signal:i}),r.targetGeometry=new et(e),o.position=new et(n),y(Jt,Lt,Kt),Q(t,Kt,Jt,a.up,o),r.scale=_(t,p(Kt,Lt),r.targetGeometry.latitude),r.rotation=ct(o.heading),r.camera=o,r}async function Tt(t,e,n,a,o,i){if(null==n)throw new r("createfromcenter","invalid point");i.targetGeometry=n.clone();const s=V(t);if(e.position)return Bt(t,i.targetGeometry,e.position,s,a,i,o);if(e.zoomFactor){const a=s.distance/e.zoomFactor,o=u(Dt,s.viewForward,-a);s.eye=f(Dt,s.center,o),i.scale=_(t,a,n.latitude)}K(t,s,a);const c=jt(a,e)?L.LOCKED:L.ADJUST;if(!e.zoomFactor){const r=wt(t,e);if(null==r){const{renderSpatialReference:e}=t;await R(n,Dt,e,0,{signal:o}),D(s.frustum,Dt)?i.scale=_(t,p(s.eye,Dt),n.latitude):i.scale=X(t,s)}else i.scale=r;i.camera=await H(t,i.targetGeometry,i.scale,a,c,o)}return i}async function Mt(t,e,n,a,o){const r=V(t);g(Jt,r.viewForward),Q(t,r.eye,Jt,r.up,Nt);const i=t.spatialReference,{position:s}=e;if(s){const t=await j(s,i,{signal:o});n.position=t}else n.position=new et;return n.heading=null!=e.heading?e.heading:Nt.heading,n.tilt=null!=e.tilt?e.tilt:Nt.tilt,vt(t,null,n,a)}async function Et(t,e,n,a,o){const r=V(t),{spatialReference:i,renderSpatialReference:s}=t;return Tt(t,e,b(r.center,s,i),n,a,o)}async function Zt(t,e,n,a,o,r){r.targetGeometry=n.clone();const i=V(t);K(t,i,a);const s=jt(a,e)?L.LOCKED:L.ADJUST;return r.camera=await J(t,n,a.heading,a.tilt,s,o),r}function At(t,e,n,a,o){let r=0;null!=n.z?r=n.z:t.basemapTerrain&&t.elevationProvider&&(r=tt(t.elevationProvider,n)),h(Dt,n.x,n.y,r),v(t.spatialReference,Dt,Ut,t.renderSpatialReference),s(Vt,Ut),c(Vt,Vt),S(Ct);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let s=0;s<i.length;s++){const e=i[s];let n=a[e[2]];isFinite(n)||(n=r),h(Dt,a[e[0]],a[e[1]],n),z(Dt,t.spatialReference,Dt,t.renderSpatialReference),E(Ct,d(Dt,Dt,Vt))}const l=A(Ct),m=F(Ct),u=k(Ct),f=1/Math.tan(e.fovX/2),p=1/Math.tan(e.fovY/2),g=.5*Math.sqrt(l*l+u*u)*Math.max(p,f)+.5*m,y=.5*m*p+.5*Math.max(l,u);return Math.max(g,y)/o}async function Ft(t,e,n,a,o,r,i,s){s.targetGeometry=n.clone();const c=V(t),l=At(t,c,n,a,o);K(t,c,r);const m=jt(r,e)?L.LOCKED:L.ADJUST;return s.scale=_(t,l,s.targetGeometry.latitude),s.camera=await H(t,s.targetGeometry,s.scale,r,m,i),s}function kt(t,e){if(!e||!t.spatialReference)return null;const n={target:void 0};return"declaredClass"in e||Array.isArray(e)?n.target=e:(Object.assign(n,e),e.center&&!n.target&&(n.target=e.center)),n}function Ot(t){return null!=t?.camera&&(t.rotation=ct(t.camera.heading)),t}function Pt(t,e){const n=it;if(!e.length)return n;let a=Number.NEGATIVE_INFINITY;for(let o=0;o<e.length;o++){const t=e[o].screenSpaceBoundingRect;a=Math.max(a,Math.abs(t[0]),Math.abs(t[1]),Math.abs(t[2]),Math.abs(t[3]))}return n-a/Math.min(t.width,t.height)*2}const Dt=w(),Ut=m(),Vt=l(),Ct=G(),It=O(),Jt=w(),Kt=w(),Lt=w(),Nt={heading:0,tilt:0},Wt=new et,Yt={point(t,e,n){n[0]=t.x,n[1]=t.y,null!=t.z&&(n[2]=t.z),e(n)},polygon(t,e,n){const a=t.hasZ;for(let o=0;o<t.rings.length;o++){const r=t.rings[o];for(let t=0;t<r.length;t++)n[0]=r[t][0],n[1]=r[t][1],a&&(n[2]=r[t][2]),e(n)}},polyline(t,e,n){const a=t.hasZ;for(let o=0;o<t.paths.length;o++){const r=t.paths[o];for(let t=0;t<r.length;t++)n[0]=r[t][0],n[1]=r[t][1],a&&(n[2]=r[t][2]),e(n)}},multipoint(t,e,n){const a=t.points,o=t.hasZ;for(let r=0;r<a.length;r++)n[0]=a[r][0],n[1]=a[r][1],o&&(n[2]=a[r][2]),e(n)},extent(t,e,n){null!=t.zmin&&null!=t.zmax?(e(h(n,t.xmin,t.ymin,t.zmin)),e(h(n,t.xmax,t.ymin,t.zmin)),e(h(n,t.xmin,t.ymax,t.zmin)),e(h(n,t.xmax,t.ymax,t.zmin)),e(h(n,t.xmin,t.ymin,t.zmax)),e(h(n,t.xmax,t.ymin,t.zmax)),e(h(n,t.xmin,t.ymax,t.zmax)),e(h(n,t.xmax,t.ymax,t.zmax))):(e(h(n,t.xmin,t.ymin,n[2])),e(h(n,t.xmax,t.ymin,n[2])),e(h(n,t.xmin,t.ymax,n[2])),e(h(n,t.xmax,t.ymax,n[2])))}};export{dt as create,ht as fromCamera,mt as toCameraAsync,lt as toCameraSync};
