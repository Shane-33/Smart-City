/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as t}from"../../../core/Cyclical.js";import n from"../../../core/Logger.js";import{deg2rad as r,rad2deg as i}from"../../../core/mathUtils.js";import{throwIfAborted as o}from"../../../core/promiseUtils.js";import{i as a,g as c,r as l,c as s}from"../../../chunks/vec3.js";import{g as u,c as f}from"../../../chunks/vec3f64.js";import{getReferenceEllipsoid as m}from"../../../geometry/ellipsoidUtils.js";import p from"../../../geometry/Point.js";import{projectWithZConversion as d,project as g}from"../../../geometry/projection.js";import h from"../../../geometry/SpatialReference.js";import{projectPointToVector as v}from"../../../geometry/projection/projectPointToVector.js";import{projectPointToVectorWithEngine as y}from"../../../geometry/projection/projectPointToVectorWithEngine.js";import{projectVectorToPoint as R}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToPointWithEngine as j}from"../../../geometry/projection/projectVectorToPointWithEngine.js";import{projectVectorToVector as w}from"../../../geometry/projection/projectVectorToVector.js";import{ViewingMode as x}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as T}from"../camera/intersectionUtils.js";import{t as M,c as S}from"../../../chunks/cameraUtilsPlanar.js";import{t as C,c as z}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as P}from"./earthUtils.js";import{getElevationAtPoint as U}from"./ElevationProvider.js";import{isSpatialReferenceSupported as b}from"../../support/spatialReferenceSupport.js";const A=n.getLogger("esri.views.3d.support.cameraUtils"),D=39.37,H=96,L=1,E=8,G=5,O=1,V=f(),k={heading:0,tilt:0},q=f(),I=new t(-20037508.342788905,20037508.342788905),W=new t(-180,180);var J;function F(e){return e.spatialReference??h.WGS84}function X(e){return"global"===e.viewingMode?z:S}function K(e,t,n,r,i){return X(e).headingTiltToDirectionUp(t,n,r,i)}function Y(e,t){if(null==t)return null;const n=e.renderSpatialReference,i=X(e).headingTiltToDirectionUp,o=f();if(!v(t.position,o,n))return null;const l=i(o,t.heading,t.tilt);a(l.direction,l.direction,e.state.camera.distance),c(l.direction,l.direction,o);const s=T(e,o,l.direction,l.up);return s.fov=r(t.fov),s}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(J||(J={}));const N=f();function Z(t,n,r){const o=t.renderSpatialReference,a=te(t,n.eye,n.viewForward,n.up,k);let c=F(t);return w(n.eye,o,N,c)||(c=h.WGS84,w(n.eye,o,N,c)),null==r?new e(new p(N,c),a.heading,a.tilt,i(n.fov)):(r.position.x=N[0],r.position.y=N[1],r.position.z=N[2],r.position.spatialReference=c,r.heading=a.heading,r.tilt=a.tilt,r.fov=i(n.fov),r)}function B(e,t,n){const i=e.state.camera,o=i.width/2/i.pixelRatio;e.renderCoordsHelper.viewingMode===x.Global&&null!=n&&(t*=Math.cos(r(n))),t/=e.renderCoordsHelper.unitInMeters;return o/(H*D/t)/Math.tan(i.fovX/2)}function Q(e,t,n){const i=e.state.camera,o=t*Math.tan(i.fovX/2),a=i.width/2/i.pixelRatio;let c=H*D/(a/o);return e.renderCoordsHelper.viewingMode===x.Global&&null!=n&&(c/=Math.cos(r(n))),c*e.renderCoordsHelper.unitInMeters}async function $(e,t,n,r,i,o){return ee(e,t,B(e,n,t.latitude),r,i,o)}function _(e,t,n,r,i,o){return Ce(e,ae(e,r.heading,r.tilt,t,n,i),r.fov,o)}async function ee(e,t,n,r,i,a){const c=await ce(e,r.heading,r.tilt,t,n,i,a);return o(a),ze(e,c,r.fov,a)}function te(e,t,n,r,i){return X(e).directionToHeadingTilt(t,n,r,i)}function ne(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,q,e.spatialReference)&&e.elevationProvider&&(U(e.elevationProvider,q)??0)>q[2]-O)}async function re(e,t,n){if(ne(e,t))return!0;const{elevationProvider:r,spatialReference:i,renderCoordsHelper:a}=e;if(null==r||!a.fromRenderCoords(t,q,i))return!1;const[c,l,s]=q,u=await r.queryElevation(c,l,s,i,"ground",n)??0;return o(n),u>s-O}async function ie(e,t,n){const r=f();if(null==t)return s(r,e.state.camera.center);if(t instanceof p){const{renderSpatialReference:i,basemapTerrain:a,elevationProvider:c}=e,l=t.spatialReference;if(await y(t,r,i,0,{signal:n}),o(n),null==t.z&&null!=a&&null!=c){const i=await c.queryElevation(t.x,t.y,t.z??0,l,"ground",n);o(n),null!=i&&e.renderCoordsHelper.setAltitude(r,i)}return r}return s(r,t)}function oe(e,t){const n=f();if(null==t)return s(n,e.state.camera.center);if(t instanceof p){if(!v(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:i}=e;if(null==t.z&&null!=r&&null!=i){const r=U(i,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return s(n,t)}function ae(e,t,n,r,i,o){return le(e,t,n,r instanceof p?r:null,oe(e,r),i,o)}async function ce(e,t,n,r,i,a,c){const l=r instanceof p?r:null,s=await ie(e,r,c);return o(c),se(e,t,n,l,s,i,a,c)}function le(e,t,n,r,i,o,a){if(null==i)return null;if(r??=R(i,e.renderSpatialReference,F(e)),null==r)return null;const c=ue(e,t,n,i,o,a);if(fe(e,n,a)&&ne(e,c.eye)){const{tilt:a,mode:c}=me(e,n,i,o);return le(e,t,a,r,i,o,c)}return pe(c,i)}async function se(e,t,n,r,i,a,c,l){r??=await j(i,e.renderSpatialReference,F(e),{signal:l}),o(l);const s=ue(e,t,n,i,a,c);if(fe(e,n,c)&&await re(e,s.eye,l)){o(l);const{tilt:c,mode:s}=me(e,n,i,a);return se(e,t,c,r,i,a,s,l)}return pe(s,i)}function ue(e,t,n,r,i,o){const a=je(e,t,n,r,i=Math.max(i,e.state.constraints.minimumPoiDistance),o);return(0,X(e).eyeForCenterWithHeadingTilt)(r,i,a.heading,a.tilt)}function fe(e,t,n){const r=e.map.ground.navigationConstraint;return n===J.ADJUST&&"global"===e.viewingMode&&t>0&&(null==r||"stay-above"===r.type)}function me(e,t,n,r){const i=Me(e,n,r,Te(e,r,t,n));return{tilt:i,mode:t-i<1?J.LOCKED:J.ADJUST}}function pe(e,t){return{...e,center:u(t)}}function de(e,t){const{state:n,spatialReference:r}=e,i=t.spatialReference;return n.isGlobal&&b(i,x.Global)||n.isLocal&&r.equals(i)}function ge(e,t){let n,r,i;if(e.state.isGlobal){const e=new p(t.xmin,t.ymin,t.spatialReference),o=new p(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?W:I;n=new p({x:a.center(e.x,o.x),y:(o.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=m(t.spatialReference),l=P(n,e,o);r=l.lon,i=l.lat,a.diff(e.x,o.x)>a.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),i=Math.min(i,c.halfCircumference)}else{const o=e.renderSpatialReference??t.spatialReference;o.equals(t.spatialReference)||(t=g(t,o)),r=t.xmax-t.xmin,i=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new p({x:t.xmin+.5*r,y:t.ymin+.5*i,z:a,spatialReference:o})}const o=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,c=1/Math.tan(a.fovX/2),l=1/Math.tan(a.fovY/2),s=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*i*l,.5*o*s)/L}}async function he(e,t,n,r,i,a){const c=de(e,t)?t:await d(t,e.spatialReference,{signal:a});o(a);const{center:l,distance:s}=ge(e,c),u=await ce(e,n,r,l,s,i,a);return o(a),ze(e,u,e.camera.fov,a)}function ve(e,t,n,r,i,o){let a;try{a=de(e,t)?t:g(t,e.spatialReference)}catch(u){return null}const{center:c,distance:l}=ge(e,a),s=ae(e,n,r,c,l,i);return null==s?null:Ce(e,s,e.camera.fov,o)}function ye(e,t,n){const r=e.renderSpatialReference,i=R(n,r,F(e));if(null==i)return null;const o=Math.tan(t.fovX/2),a=Math.tan(t.fovY/2),c=l(t.eye,n),s=2*c*o*L,u=2*c*a*L;return"global"===e.viewingMode?C(e,i,s,u):M(e,i,s,u)}function Re(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>E)return!0;const i=e.renderSpatialReference,o=F(e),a=R(t,i,o),c=R(e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,i,o);if(null==a||null==c)return!1;const l=Math.tan(.5*e.state.camera.fov)*r;return c.distance(a)/l>G}function je(e,t,n,r,i,o){let a=0;return o===J.ADJUST&&Re(e,r,i)?(t=0,a=xe(e,i,n,r)):a=Se(e,r,i,n),a=e.state.constraints.clampTilt(i,a),{heading:t,tilt:n=Me(e,r,i,a)}}const we=.7;function xe(e,t,n,r){const i=Se(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);o.max=Math.min(o.max,.5*Math.PI);const a=o.min*(1-we)+o.max*we;return Math.min(i,a)}function Te(e,t,n,r){let i=Se(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);return i=Math.min(i,.5*Math.PI),o.min*(1-we)+i*we}function Me(e,t,n,r){return X(e).lookAtTiltToEyeTilt(r,t,n)}function Se(e,t,n,r){return X(e).eyeTiltToLookAtTilt(r,t,n)}function Ce(t,n,r,i){if(null==n)return null;const o=t.renderSpatialReference,a=R(n.eye,o,F(t));return null==a?null:(i??=new e,i.position=a,i.heading=n.heading,i.tilt=n.tilt,i.fov=r,i)}async function ze(t,n,r,i){const a=t.renderSpatialReference,c=await j(n.eye,a,F(t),{signal:i});return o(i),new e(c,n.heading,n.tilt,r)}function Pe(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);A.error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Ue(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);A.error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function be(e,t){return w(t.center,e.renderSpatialReference,V,h.WGS84),Q(e,t.distance,V[1])}export{J as OrientationMode,be as computeScale,te as directionToHeadingTilt,Q as distanceToScale,Y as externalToInternal,ee as fromCenterDistanceAsync,_ as fromCenterDistanceSync,$ as fromCenterScale,he as fromExtentAsync,ve as fromExtentSync,ce as getObserverForPointAtDistanceAsync,ae as getObserverForPointAtDistanceSync,F as getViewSR,K as headingTiltToDirectionUp,Z as internalToExternal,B as scaleToDistance,Pe as scaleToZoom,ye as toExtent,Ue as zoomToScale};
