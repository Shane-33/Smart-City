/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{asinClamped as i}from"../../../../../core/mathUtils.js";import{createScreenPointArray as e,screenPointObjectToArray as n}from"../../../../../core/screenUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/Error.js";import{subclass as o}from"../../../../../core/accessorSupport/decorators/subclass.js";import{d as s}from"../../../../../chunks/vec2.js";import{E as r,c as a,j as m,f as h,l as c,n as l,i as p,g as _}from"../../../../../chunks/vec3.js";import{c as u,f as d}from"../../../../../chunks/vec3f64.js";import{wrapAxisAngle as C}from"../../../../../geometry/support/axisAngle.js";import{create as g,fromNormalAndOffset as M,setOffsetFromPoint as v,negate as f,normal as b}from"../../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as w,applyAll as j}from"../../../camera/constraintUtils.js";import{ConstraintTypes as E}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as V}from"../../../camera/constraintUtils/InteractionType.js";import{TiltMode as P}from"../../../camera/constraintUtils/TiltMode.js";import{ExponentialFalloff as S}from"../../../input/util.js";import{getVoxelWasm as z}from"../../../layers/VoxelWasm.js";import{InteractiveController as H}from"../InteractiveController.js";import{PanPlanarMomentumController as y}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as O}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as T}from"../momentum/ZoomPlanarMomentumController.js";import{NavigationMode as A,contentIntersectorOptions as F,panDistanceModifier as L,minHeightLimit as U,screenPixelArea as x,centroid as R,applyZoomToPoint as D,applyPanPlanar as N,normalizeRotationDelta as k,applyRotation as I,intersectPlaneFromScreenPointAtEye as G}from"../../utils/navigationUtils.js";import{Camera as Z}from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as B}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as W}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as q}from"../../../../navigation/ZoomMomentumEstimator.js";const J=d(0,0,1),K={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI};let Q=class extends H{constructor(){super(...arguments),this._rotationValueSmooth=new S(.05),this._scalingValueSmooth=new S(.05),this._planeHorizontal=g(),this._planeVertical=g(),this._rotationMomentumEstimator=new W,this._panMomentumEstimator=new B(300,12,.9),this._zoomMomentumEstimator=new q,this._beginRadius=0,this._beginCenter=u(),this._beginAngle=0,this._tmpPoints=[],this._panMode=A.Horizontal,this._beginCenterScreen=e(),this._tmpCentroid3d=u(),this._tmpCentroid2d=e(),this._tmp2d=e(),this._pointerCount=0,this._constraintOptions={selection:E.ALL,interactionType:V.NONE,interactionFactor:0,interactionStartCamera:new Z,interactionDirection:null,tiltMode:P.TUMBLE}}begin(t){if(!this.active)return;const e=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=e,this._rotationMomentumEstimator.enabled=e,this._panMomentumEstimator.enabled=e,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),n(t.center,this._beginCenterScreen),M(J,0,this._planeHorizontal);const o=u(),s=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,o,0===this.view.map.ground.opacity?F:{}),d=u();r(d,this.startCamera.viewForward);const C=u();a(C,J);const g=m(d,C),w=i(g<0?-g:g);this._panMode=w>=K.ANGLE_THRESHOLD?A.Horizontal:A.Vertical;const j=Math.min(L,1/Math.abs(m(C,this.startCamera.viewForward)))*Math.max(Math.abs(this.view.camera.position.z),U);v(this._planeHorizontal,this._planeHorizontal,o),this.startCamera.aboveGround||f(this._planeHorizontal,this._planeHorizontal);const E=u(),V=u(),P=u();h(E,o,this.currentCamera.eye);const S=c(E);if(l(E,E),this._panMode===A.Vertical){p(C,C,g),h(this._planeVertical,d,C),l(this._planeVertical,this._planeVertical),v(this._planeVertical,this._planeVertical,o);const i=this.view._stage.renderView.getMinimalDepthForArea(z(this.view),this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,x);let e=null!=i?i:j;e=s?Math.min(e,S):e,a(P,_(V,this.currentCamera.eye,p(V,E,e))),this._planeVertical[3]=-m(this._planeVertical,P),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),R(this._tmpPoints,this._beginCenter)}else{const i=s?S:j;a(P,_(V,this.currentCamera.eye,p(V,E,i))),this._planeHorizontal[3]=-m(b(this._planeHorizontal),P),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),R(this._tmpPoints,this._beginCenter)}this._constraintOptions.interactionStartCamera?.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,e=this._panMode===A.Horizontal?this._planeHorizontal:this._planeVertical,o=this._beginCenter;if(i){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=e,this._scalingValueSmooth.update(i),D(this.currentCamera,o,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=V.ZOOM,this._constraintOptions.interactionFactor=w(Math.abs(t.radius-this._beginRadius)),j(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,e,this.currentCamera,this._tmpPoints),R(this._tmpPoints,this._tmpCentroid3d),n(t.center,this._tmpCentroid2d),N(this.currentCamera,o,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=V.PAN,this._constraintOptions.interactionFactor=w(s(this._beginCenterScreen,this._tmpCentroid2d)),j(this.view,this.currentCamera,this._constraintOptions),i){const i=this._planeHorizontal,e=o,n=this._rotationValueSmooth.value,s=n+k(t.angle-n),r=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=r,this._rotationValueSmooth.update(s);const a=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(a,.001*t.timestamp),I(this.currentCamera,e,C(i,a)),this._constraintOptions.interactionType=V.TUMBLE,this._constraintOptions.interactionFactor=w(Math.abs(t.radius*a)),j(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return new T({view:this.view,momentum:i,zoomCenter:this._beginCenter});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new O({view:this.view,momentum:e,center:this._beginCenter,axis:b(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new y({view:this.view,momentum:n}):null}_computePlanePoints(t,i,e,n){n.length=t.size;const o=this._tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=u()),G(i,e,o,n[s]),s+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}};Q=t([o("esri.views.3d.state.controllers.local.PinchAndPanController")],Q);export{Q as PinchAndPanController};
