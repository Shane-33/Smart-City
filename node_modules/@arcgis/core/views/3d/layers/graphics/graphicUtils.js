/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{getMetersPerUnitForSR as t}from"../../../../core/unitUtils.js";import{o as e,r as n,n as r}from"../../../../chunks/mat4.js";import{a as o}from"../../../../chunks/mat4f64.js";import{e as i,O as s}from"../../../../chunks/vec3f64.js";import{s as u}from"../../../../chunks/vec4.js";import{d as l,O as a}from"../../../../chunks/vec4f64.js";import{projectPoint as m}from"../../../../geometry/projection.js";import{width as c,depth as f,height as p}from"../../../../geometry/support/aaBoundingBox.js";import{create as h}from"../../../../geometry/support/aaBoundingRect.js";import{ringsCentroid as g}from"../../../../geometry/support/centroid.js";import{getPointOnPath as y,getPathLength as d}from"../../../../geometry/support/coordsUtils.js";import{makeDehydratedPoint as x}from"../../../../layers/graphics/dehydratedPoint.js";import{isHydratedGeometry as j,clonePoint as b}from"../../../../layers/graphics/hydratedFeatures.js";import{VertexAttribute as v}from"../../webgl-engine/lib/VertexAttribute.js";function w(t,e){if("point"===t.type)return M(t,e,!1);if(j(t))switch(t.type){case"extent":return M(t.center,e,!1);case"polygon":return M(t.centroid,e,!1);case"polyline":return M(A(t),e,!0);case"mesh":return M(t.origin,e,!1)}else switch(t.type){case"extent":return M(P(t),e,!0);case"polygon":return M(z(t),e,!0);case"polyline":return M(A(t),e,!0)}}function A(t){const e=t.paths[0];if(!e||0===e.length)return null;const n=y(e,d(e)/2);return x(n[0],n[1],n[2],t.spatialReference)}function P(t){return x(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),null!=t.zmin&&null!=t.zmax&&isFinite(t.zmin)&&isFinite(t.zmax)?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}function z(t){const e=t.rings[0];if(!e||0===e.length)return null;const n=g(t.rings,!!t.hasZ);return x(n[0],n[1],n[2],t.spatialReference)}function M(t,e,n){const r=n?t:b(t);return e&&t?m(t,r,e)?r:null:r}function R(t,e,n,r=0){if(t){e||(e=h());const o=t;let i=.5*o.width*(n-1),s=.5*o.height*(n-1);return o.width<1e-7*o.height?i+=s/20:o.height<1e-7*o.width&&(s+=i/20),u(e,o.xmin-i-r,o.ymin-s-r,o.xmax+i+r,o.ymax+s+r),e}return null}function k(t,e){for(let n=0;n<t.geometries.length;++n){const r=t.geometries[n].getMutableAttribute(v.AUXPOS1);r&&r.data[3]!==e&&(r.data[3]=e,t.geometryVertexAttributeUpdated(t.geometries[n],v.AUXPOS1))}}function F(t,e,n=null){const r=l(a);return null!=t&&(r[0]=t[0],r[1]=t[1],r[2]=t[2]),null!=e?r[3]=e:null!=t&&t.length>3&&(r[3]=t[3]),n&&(r[0]*=n,r[1]*=n,r[2]*=n,r[3]*=n),r}function U(t,e,n,r,o,i=[0,0,0,0]){for(let s=0;s<3;++s)i[s]=null!=t?.[s]?t[s]:null!=n?.[s]?n[s]:o[s];return i[3]=null!=e?e:null!=r?r:o[3],i}function O(t=s,e,n,r=1){const o=new Array(3);if(null==e||null==n)o[0]=1,o[1]=1,o[2]=1;else{let r,i=0;for(let s=2;s>=0;s--){const u=t[s];let l;const a=null!=u,m=0===s&&!r&&!a,c=n[s];"symbol-value"===u||m?l=0!==c?e[s]/c:1:a&&"proportional"!==u&&isFinite(u)&&(l=0!==c?u/c:1),null!=l&&(o[s]=l,r=l,i=Math.max(i,Math.abs(l)))}for(let t=2;t>=0;t--)null==o[t]?o[t]=r:0===o[t]&&(o[t]=.001*i)}for(let i=2;i>=0;i--)o[i]/=r;return i(o)}function B(t){return null!=t.isPrimitive}function D(t){return I(B(t)?[t.width,t.depth,t.height]:t)?null:"Symbol sizes may not be negative values"}function I(t){const e=t=>null==t||t>=0;return Array.isArray(t)?t.every(e):e(t)}function S(t,i,s,u=o()){return t&&e(u,u,-t/180*Math.PI),i&&n(u,u,i/180*Math.PI),s&&r(u,u,s/180*Math.PI),u}function V(e,n,r){if(null!=r.minDemResolution)return r.minDemResolution;const o=t(n),i=c(e)*o,s=f(e)*o,u=p(e)*(n.isGeographic?1:o);return 0===i&&0===s&&0===u?r.minDemResolutionForPoints:.01*Math.max(i,s,u)}export{w as computeCentroid,S as computeObjectRotation,O as computeObjectScale,V as demResolutionForBoundingBox,R as enlargeExtent,I as isValidSize,F as mixinColorAndOpacity,U as overrideColor,k as updateVertexAttributeAuxpos1w,D as validateSymbolLayerSize};
