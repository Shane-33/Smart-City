/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{h as t}from"../../../../chunks/mat4.js";import{a as e}from"../../../../chunks/mat4f64.js";import{s as o}from"../../../../chunks/vec3.js";import{c as n}from"../../../../chunks/vec3f64.js";import{computeTranslationToOriginAndRotation as a}from"../../../../geometry/projection/computeTranslationToOriginAndRotation.js";import{projectBuffer as r}from"../../../../geometry/projection/projectBuffer.js";import{SampleElevationInfo as s}from"./elevationAlignmentUtils.js";import{updateVertexAttributeAuxpos1w as i}from"./graphicUtils.js";import{debugFlags as l}from"../../support/debugFlags.js";import{SamplePosition as m}from"../../support/ElevationProvider.js";import{isGeometryWithMapPositions as f}from"../../webgl-engine/lib/GeometryWithMapPositions.js";import{VertexAttribute as c}from"../../webgl-engine/lib/VertexAttribute.js";function u(t,e,o,n,a){const r=t.stageObject,s=r.geometries;let i=0;for(const l of s){if(!f(l))continue;const{update:t,averageGeometrySampledElevation:s}=j(l,e,o,n,a);i+=s,t&&r.geometryVertexAttributeUpdated(l,c.POSITION)}return i/s.length}function p(e,n,r,s,m,f){const c=e.stageObject,u=n.centerPointInElevationSR;let p=0;if(c.usesVerticalDistanceToGround)s(u,E),i(c,E.verticalDistanceToGround),p=E.sampledElevation;else{s(u,E);"absolute-height"!==n.mode&&(p=E.sampledElevation)}const I=t(g,f??c.transformation),d=o(v,I[12],I[13],I[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=u.x,T[1]=u.y,T[2]=E.z,a(u.spatialReference,T,I,m.spatialReference)&&(f?t(f,I):c.transformation=I)):m.setAltitudeOfTransformation(E.z,I);const S=b/m.unitInMeters;return(Math.abs(I[12]-d[0])>=S||Math.abs(I[13]-d[1])>=S||Math.abs(I[14]-d[2])>=S)&&(f?t(f,I):c.transformation=I),p}const g=e();function I(t,e,n,r,s){const i=t.graphics3DSymbolLayer.lodRenderer;if(null==i)return 0;const m=e.centerPointInElevationSR;r(m,E);const f="absolute-height"!==e.mode?E.sampledElevation:0,c=i.instanceData,u=t.instanceIndex,p=O;c.getGlobalTransform(u,p);const g=o(v,p[12],p[13],p[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=m.x,T[1]=m.y,T[2]=E.z,a(m.spatialReference,T,p,s.spatialReference)&&c.setGlobalTransform(u,p)):s.setAltitudeOfTransformation(E.z,p);const I=b/s.unitInMeters;return(l.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(p[12]-g[0])>=I||Math.abs(p[13]-g[1])>=I||Math.abs(p[14]-g[2])>=I)&&c.setGlobalTransform(u,p),f}function d(t,e,o,n,a){const r=t.stageObject,s=r.geometries;if(0===s.length)return 0;let i=0,l=null,m=0,u=!1;for(const p of s){if(!f(p))continue;const t=p.attributes.get(c.POSITION);if(t!==l){const{update:r,averageGeometrySampledElevation:s}=j(p,e,o,n,a);m=s,l=t,u=r}u&&r.geometryVertexAttributeUpdated(p,c.POSITION),i+=m}return i/s.length}const b=.01,T=n(),S=n(),h=n(),O=e(),v=n(),E=new s;function j(t,e,o,n,a){let s=!1;const i=t.transformation,f=e.requiresSampledElevationInfo;S[0]=i[12],S[1]=i[13],S[2]=i[14],t.invalidateBoundingInfo();const u=t.getMutableAttribute(c.POSITION),p=u.data,g=u.size,I=p.length/g,d=new m(t.mapPositions,o);let O=0,v=0;for(let m=0;m<I;m++){if(h[0]=p[O],h[1]=p[O+1],h[2]=p[O+2],n(d,E),f&&(v+=E.sampledElevation),l.TESTS_DISABLE_OPTIMIZATIONS)p[O]=d.array[d.offset],p[O+1]=d.array[d.offset+1],p[O+2]=E.z,r(p,o,O,p,a.spatialReference,O,1),p[O]-=S[0],p[O+1]-=S[1],p[O+2]-=S[2],s=!0;else{T[0]=p[O]+S[0],T[1]=p[O+1]+S[1],T[2]=p[O+2]+S[2],a.setAltitude(T,E.z),p[O]=T[0]-S[0],p[O+1]=T[1]-S[1],p[O+2]=T[2]-S[2];const t=b/a.unitInMeters;(Math.abs(h[0]-p[O])>=t||Math.abs(h[1]-p[O+1])>=t||Math.abs(h[2]-p[O+2])>=t)&&(s=!0)}O+=g,d.offset+=3}return v/=I,{update:s,averageGeometrySampledElevation:v}}export{I as perLodInstanceElevationAligner,p as perObjectElevationAligner,u as perVertexElevationAligner,d as sharedGeometryElevationAligner};
