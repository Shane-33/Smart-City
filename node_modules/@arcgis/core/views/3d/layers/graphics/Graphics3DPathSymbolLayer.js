/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import e from"../../../../core/Error.js";import{w as t}from"../../../../chunks/mat4.js";import{I as s,a as i}from"../../../../chunks/mat4f64.js";import{s as r,a}from"../../../../chunks/vec2.js";import{f as o,b as n}from"../../../../chunks/vec2f64.js";import{s as l}from"../../../../chunks/vec3.js";import{e as h,c}from"../../../../chunks/vec3f64.js";import{projectBuffer as p}from"../../../../geometry/projection/projectBuffer.js";import{create as m,empty as d,expandWithBuffer as f,intersectsClippingArea as u}from"../../../../geometry/support/aaBoundingBox.js";import{newDoubleArray as y,doubleArrayFrom as b}from"../../../../geometry/support/DoubleArray.js";import{needsElevationUpdates3D as g,evaluateElevationAlignmentAtPoint as _,SampleElevationInfo as v}from"./elevationAlignmentUtils.js";import{Graphics3DObject3DGraphicLayer as w}from"./Graphics3DObject3DGraphicLayer.js";import{pathNumRoundJoinSubdivisions as x,pathNumRoundCapExtrusionSubdivisions as P}from"./Graphics3DPathSymbolLayerConstants.js";import{Graphics3DSymbolLayer as j}from"./Graphics3DSymbolLayer.js";import{isValidSize as S}from"./graphicUtils.js";import{ApplyRendererDiffResult as D}from"./interfaces.js";import{ConvertOptions as C,initFastSymbolUpdatesState as L,updateFastSymbolUpdatesState as V,getAttributeValue as U}from"../support/FastSymbolUpdates.js";import{SamplePosition as k}from"../../support/ElevationProvider.js";import{NormalType as E}from"../../webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{CullFaceOptions as R}from"../../webgl-engine/lib/basicInterfaces.js";import{Object3D as A}from"../../webgl-engine/lib/Object3D.js";import{Path as z}from"../../webgl-engine/lib/Path.js";import{PathBuilder as I}from"../../webgl-engine/lib/PathBuilder.js";import{RoundCapBuilder as G,TriangulationCapBuilder as B,NoCapBuilder as O}from"../../webgl-engine/lib/PathCapBuilder.js";import{SimpleExtruder as M,MiterExtruder as q}from"../../webgl-engine/lib/PathExtruder.js";import{UpVectorAlignment as F,PathGeometry as H,isPathGeometry as N}from"../../webgl-engine/lib/PathGeometry.js";import{FastUpdatePathGeometry as T,StaticPathGeometry as W}from"../../webgl-engine/lib/PathGeometryData.js";import{computeMinimumRotationTangentFrame as Z}from"../../webgl-engine/lib/pathGeometryUtils.js";import{quadProfiles as J,circleProfiles as K}from"../../webgl-engine/lib/PathProfile.js";import{newPathVertex as Q}from"../../webgl-engine/lib/PathVertex.js";import{VertexAttribute as X}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as Y}from"../../webgl-engine/materials/DefaultMaterial.js";import{PathMaterial as $}from"../../webgl-engine/materials/PathMaterial.js";const ee=["polyline"];class te extends j{constructor(e,t,s,i){super(e,t,s,i),this._intrinsicSize=o(1,1),this._upVectorAlignment=F.Path,this._stencilWidth=.1,this.usedMemory=0,this.ensureDrapedStatus(!1)}async doLoad(){const t=null!=this.symbolLayer.width?this.symbolLayer.width:this.symbolLayer.height,s=null!=this.symbolLayer.height?this.symbolLayer.height:t;this._vvConvertOptions=new C({size:!0,color:!0,rotation:!1,opacity:!0},[1,1,1],[t,1,s],this._context.renderCoordsHelper.unitInMeters),this._fastUpdates=this._context.renderer?.visualVariables?.length>0?L(this._context.renderer,this._vvConvertOptions):null;const i=this.symbolLayer.anchor||"center";this._upVectorAlignment="heading"===this.symbolLayer.profileRotation?F.World:F.Path;const o=this.symbolLayer.profile||"circle";switch(o){default:case"circle":this._profile=K[i];break;case"quad":this._profile=J[i]}switch(this.symbolLayer.join){case"round":this._extruder=new q(0,x);break;case"bevel":this._extruder=new q(0,1);break;case"miter":this._extruder=new q(.8*Math.PI,1);break;default:this._extruder=new M}const l=this.symbolLayer.cap||"butt";switch(l){case"none":this._startCap=new O,this._endCap=new O;break;case"butt":default:this._startCap=new B(this._profile,0),this._endCap=new B(this._profile,0,!0);break;case"square":this._startCap=new B(this._profile,-.5),this._endCap=new B(this._profile,.5,!0);break;case"round":{const e="quad"===o;this._startCap=new G({profile:this._profile,flip:!1,breakNormals:e,subdivisions:P}),this._endCap=new G({profile:this._profile,flip:!0,breakNormals:e,subdivisions:P});break}}const c=this.symbolLayer?.material?.color,p=this._getCombinedOpacityAndColor(c),m=h(p),d=p[3],f=d<1||this.needsDrivenTransparentPass,u={diffuse:m,ambient:m,opacity:d,transparent:f,hasVertexColors:!1,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:f||"none"===l?R.None:R.Back,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(r(this._intrinsicSize,t,s),!S(this._intrinsicSize[0])||!S(this._intrinsicSize[1])))throw new e("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");if(this._fastUpdates?.visualVariables.size||a(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates){const e={...u,...this._fastUpdates.materialParameters,size:n(this._intrinsicSize)};this._materials[0]=new $(e)}else u.hasVertexColors=this._drivenProperties.color||this._drivenProperties.opacity,u.normalType=E.Compressed,this._materials[0]=new Y(u);this._materials[0].setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._materials[0])}destroy(){super.destroy(),this._context.stage.remove(this._materials[0]),this._materials[0]=null,this._materials.length=0}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,ee,this.symbolLayer.type))return null;const s=this.setGraphicElevationContext(t),i=e.renderingInfo;return this._createAs3DShape(t,i,s,t.uid)}layerOpacityChanged(){const e=this.symbolLayer?.material?.color,t=this._getCombinedOpacity(e),s=t<1||this.needsDrivenTransparentPass;this._materials[0]?.setParameters({opacity:t,transparent:s})}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,g)}slicePlaneEnabledChanged(){return this._materials[0]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._materials[0]?.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}applyRendererDiff(e,t){for(const s in e.diff){if("visualVariables"!==s)return D.RecreateSymbol;if(!V(this._fastUpdates,t,this._vvConvertOptions))return D.RecreateSymbol;this._materials[0]?.setParameters(this._fastUpdates.materialParameters)}return D.FastUpdate}_getVertexData(e){let t=0;const s=e.paths,i=[],r=e.spatialReference,a=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const c of s)t+=c.length;const n=y(3*t);let l,h=0;for(const c of s){i.push({offset:h,numVertices:c.length});for(const t of c)n[h++]=t[0],n[h++]=t[1],n[h++]=e.hasZ?t[2]:0}return null==a||r.equals(a)||p(n,r,0,n,a,0,t)?(null==a||a.equals(o)?l=b(n):(l=y(3*t),p(n,a,0,l,o,0,t)),{pathVertexDataInfos:i,vertexDataES:n,vertexDataRS:l}):null}_createAs3DShape(e,r,a,o){this.usedMemory=0;const n=e.geometry,h=this._getVertexData(n);if(null==h)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(0===h.pathVertexDataInfos.length)return 0!==n.paths.length&&n.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)"),null;const c=new Array,p=n.spatialReference,y=m(),b=this._context.renderCoordsHelper,v=new k(h.vertexDataES);for(const m of h.pathVertexDataInfos){const n=m.numVertices;if(n<2)continue;const g=m.offset;if(null!=this._context.clippingExtent&&(d(y),f(y,h.vertexDataES,g,n),!u(y,this._context.clippingExtent)))continue;const w=new Array,x=g+3*n;for(let e=g;e<x;e+=3){v.offset=e;const t=_(v,this._context.elevationProvider,a,b);l(oe,h.vertexDataRS[e],h.vertexDataRS[e+1],h.vertexDataRS[e+2]),b.setAltitude(oe,t),h.vertexDataRS[e]=oe[0],h.vertexDataRS[e+1]=oe[1],h.vertexDataRS[e+2]=oe[2],w.push(Q(this._upVectorAlignment))}const P=new z(w,h.vertexDataES,h.vertexDataRS,g);se(P,this._upVectorAlignment,this._context.renderCoordsHelper);const j=new I(P,this._profile,this._extruder,this._startCap,this._endCap);let S=null;if(this._fastUpdates){const t=this._fastUpdates.visualVariables,s=U(t.size?.field,e)??0,i=U(t.color?.field,e)??0,r=U(t.opacity?.field,e)??0;S=new T(j,s,i,r)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];if(this._drivenProperties.size){const t=r.size;e[0]*=ie(t[0],"symbol-value"===t[2]?this.symbolLayer.height||0:t[2],this.symbolLayer.width||0),e[1]*=ie(t[2],"symbol-value"===t[0]?this.symbolLayer.width||0:t[0],this.symbolLayer.height||0)}let t;this._drivenProperties.color&&(t=r.color),this._drivenProperties.opacity&&null!=r.opacity&&(t=t?[t[0],t[1],t[2],r.opacity]:[1,1,1,r.opacity]);const s=new W(j);s.bake(e),t&&s.bakeVertexColors(t),S=s}const D=S.createGeometryData(),C=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:o,layerUid:this._context.layer.uid}),L=new H(this._materials[0],D,S,p,this._stencilWidth,C);L.transformation=t(i(),s,j.path.origin),c.push(L),this.usedMemory+=j.usedMemory}if(0===c.length)return null;const x=new A({geometries:c,layerUid:this._context.layer.uid,graphicUid:o}),P=new w(this,x,c,null,null,((e,t,s,i,r)=>ae(e,t,i,r,this._upVectorAlignment)),a);return P.alignedSampledElevation=0,P.needsElevationUpdates=g(a.mode),P}}function se(e,t,s){const{origin:i,positions:r}=e;let a=e.offset;switch(t){default:case F.World:for(const t of e.vertices)oe[0]=r[a++]+i[0],oe[1]=r[a++]+i[1],oe[2]=r[a++]+i[2],s.worldUpAtPosition(oe,oe),t.setFrameFromUpVector(oe);break;case F.Path:oe[0]=r[a]+i[0],oe[1]=r[a+1]+i[1],oe[2]=r[a+2]+i[2],s.worldUpAtPosition(oe,oe),Z(e,oe)}}function ie(e,t,s){switch(e){case"symbol-value":return s;case"proportional":return t;default:return e}}function re(e,t,s,i){let r=0;const{origin:a,vertices:o,positions:n,positionsES:h}=e,c=e.offset+3*o.length;for(let p=e.offset;p<c;p+=3)l(oe,h[p],h[p+1],h[p+2]),s(oe,ne),r+=ne.sampledElevation,oe[0]=n[p]+a[0],oe[1]=n[p+1]+a[1],oe[2]=n[p+2]+a[2],i.setAltitude(oe,ne.z),n[p]=oe[0]-a[0],n[p+1]=oe[1]-a[1],n[p+2]=oe[2]-a[2];return e.updatePathVertexInformation(),r/o.length}function ae(e,t,s,i,r){const a=e.stageObject,o=a.geometries;let n=0;for(const l of o){if(!N(l))continue;const e=l.path,o=e.builder.path;n+=re(o,t,s,i),r!==F.World&&se(o,r,i),e.onPathChanged(l),l.invalidateBoundingInfo(),a.geometryVertexAttributeUpdated(l,X.POSITION)}return n/o.length}const oe=c(),ne=new v;export{te as Graphics3DPathSymbolLayer};
