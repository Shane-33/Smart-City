/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{disposeMaybe as s}from"../../../../core/maybe.js";import t from"../../../../core/PooledArray.js";import{property as i}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import{subclass as r}from"../../../../core/accessorSupport/decorators/subclass.js";import{f as n,l as o,i as a,E as l,j as h,m as c}from"../../../../chunks/vec3.js";import{c as u}from"../../../../chunks/vec3f64.js";import{s as d}from"../../../../chunks/vec4.js";import{create as p,offset as m,contains as g,containsPoint as _,set as f,positiveInfinity as P,equals as b}from"../../../../geometry/support/aaBoundingBox.js";import{create as S}from"../../../../geometry/support/plane.js";import{fromPoints as x}from"../../../../geometry/support/ray.js";import{PclTarget as z}from"./Intersector.js";import{PointHighlights as w}from"./PointHighlights.js";import{minimumDistancePlane as R,maximumDistancePlane as j,intersectLine as y,toAaBoundingBox as q}from"../../support/orientedBoundingBox.js";import{ShaderOutput as A}from"../../webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SyncPrepareRenderPlugin as I}from"../../webgl-engine/effects/RenderPlugin.js";import{Default3D as v}from"../../webgl-engine/lib/DefaultVertexAttributeLocations.js";import{newIntersectorResult as E}from"../../webgl-engine/lib/Intersector.js";import{IntersectorType as F,StoreResults as O}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{RenderSlot as C}from"../../webgl-engine/lib/RenderSlot.js";import{VertexArrayObject as N}from"../../webgl-engine/lib/VertexArrayObject.js";import{VertexAttribute as T}from"../../webgl-engine/lib/VertexAttribute.js";import{P as L,a as H,g as M}from"../../../../chunks/PointRenderer.glsl.js";import{PointRendererTechnique as B}from"../../webgl-engine/shaders/PointRendererTechnique.js";import{PointRendererTechniqueConfiguration as U}from"../../webgl-engine/shaders/PointRendererTechniqueConfiguration.js";import{BufferObject as D}from"../../../webgl/BufferObject.js";import{DataType as V,PrimitiveType as W,Usage as k}from"../../../webgl/enums.js";import{VertexElementDescriptor as G}from"../../../webgl/VertexElementDescriptor.js";const Q={positions:[new G(T.POSITION,3,V.FLOAT,0,12)],colors:[new G(T.COLOR,3,V.UNSIGNED_BYTE,0,3,!0)]};let Y=class extends I{constructor(e){super(e),this.type=F.PCL,this.isGround=!1,this._passParameters=new L,this._highlights=new w({forEachNode:e=>this.forEachNode(e),addHighlight:(e,s,t)=>this._addHighlight(e,s,t),removeHighlight:(e,s)=>this._removeHighlight(e,s)}),this.produces=new Map([[C.OPAQUE_MATERIAL,e=>e!==A.Highlight||!this._highlights.empty]]),this.layerUid="",this._slicePlaneEnabled=!1,this._techniqueConfig=new U,this._nodes=new t}initializeRenderContext(e){this._context=e,e.requestRender()}uninitializeRenderContext(){}intersect(e,s,t,i){const r=u(),f=u(),P=u(),b=u(),w=S(),A=e.camera.perScreenPixelRatio/2,I=e.camera.near;n(f,i,t);const v=1/o(f);a(f,f,v),l(P,f),d(w,f[0],f[1],f[2],-h(f,t));const F=new ie,C=new ie,N=new Array,T=p(),L=p(this._passParameters.clipBox);m(L,-t[0],-t[1],-t[2],L),this._nodes.forAll((o=>{const a=o.splatSize*this._passParameters.scaleFactor;let l=R(o.obb,w),u=j(o.obb,w);l-=Z(a,l+I,this._passParameters,A,o.isLeaf),u-=Z(a,u+I,this._passParameters,A,o.isLeaf);const d=u<0,p=null!=F.dist&&null!=C.dist&&F.dist<l*v&&C.dist>u*v;if(d||p)return;const S=X(a,u+I,this._passParameters,A,o.isLeaf);if(!y(o.obb,t,f,S))return;const x=S*S;q(o.obb,T),m(T,-t[0],-t[1],-t[2],T);const z=!g(L,T);n(b,o.origin,t);const E=o.coordinates.length/3;for(let n=0;n<E;n++){if(r[0]=b[0]+o.coordinates[3*n],r[1]=b[1]+o.coordinates[3*n+1],r[2]=b[2]+o.coordinates[3*n+2],z&&!_(L,r))continue;const l=h(r,f),u=c(r)-l*l;if(u>x)continue;let d=l+I;const p=Z(a,d,this._passParameters,A,o.isLeaf);if(l-p<0)continue;d-=p;const m=X(a,d,this._passParameters,A,o.isLeaf);if(u>m*m)continue;const g=(l-p)*v,S=e=>(e.point=$(o,n,e.point),e.dist=g,e.normal=P,e.node=o,e.pointId=n,e.layerUid=this.layerUid,e);if((null==F.dist||g<F.dist)&&(null==s||s(t,i,g))&&S(F),e.options.store!==O.MIN&&(null==C.dist||g>C.dist)&&(null==s||s(t,i,g))&&S(C),e.options.store===O.ALL&&(null==s||s(t,i,g))){const e=new ie;N.push(S(e))}}}));const H=e=>{const{layerUid:s,node:t,pointId:i}=e;return new z(e.point,s,i,(()=>this.createGraphic(t,i,e.point)))},M=(e,s)=>{const t=H(s);e.set(this.type,t,s.dist,s.normal)};if(re(F)){const s=e.results.min;(null==s.dist||F.dist<s.dist)&&M(s,F)}if(re(C)&&e.options.store!==O.MIN){const s=e.results.max;(null==s.dist||C.dist>s.dist)&&M(s,C)}if(e.options.store===O.ALL){const s=x(t,i);for(const t of N){const i=E(s);M(i,t),e.results.all.push(i)}}}prepareTechnique(e){return 0===this._nodes.length||e.output!==A.Color&&e.output!==A.Depth&&e.output!==A.Highlight?null:(this._nodes.forAll((s=>{null==s.vao&&this._initNode(e,s)})),this._techniqueConfig.drawScreenSize=this._passParameters.drawScreenSpace,this._techniqueConfig.useFixedSizes=this._passParameters.useFixedSizes,this._techniqueConfig.hasSlicePlane=this._slicePlaneEnabled,this._techniqueConfig.hasOccludees=e.bindParameters.hasOccludees,this._techniqueConfig.clippingEnabled=this._clippingEnabled,this._techniqueConfig.output=e.output,this._context.techniqueRepository.releaseAndAcquire(B,this._techniqueConfig,this._technique))}renderNode(e,s){const t=e.rctx,i=t.bindTechnique(s,this._passParameters,e.bindParameters),r=e.output===A.Highlight;this._nodes.forAll((s=>{0===s.coordinates.length||r&&!s.highlights||(i.bindDraw(s,e.bindParameters,this._passParameters),t.bindVAO(s.vao),r?this._renderHighlightFragments(t,s):t.drawArrays(W.POINTS,0,s.coordinates.length/3))}))}_renderHighlightFragments(e,s){const t=s.highlights;if(null==t)return;let i=t[0].component,r=i+1;for(let o=1;o<t.length;o++){const s=t[o].component;if(s!==r){const t=r-i;t>0&&e.drawArrays(W.POINTS,i,t),i=s}r=s+1}const n=r-i;n>0&&e.drawArrays(W.POINTS,i,n)}set useFixedSizes(e){this._passParameters.useFixedSizes!==e&&(this._passParameters.useFixedSizes=e,this._requestRender())}get useFixedSizes(){return this._passParameters.useFixedSizes}set scaleFactor(e){this._passParameters.scaleFactor!==e&&(this._passParameters.scaleFactor=e,this._requestRender())}get scaleFactor(){return this._passParameters.scaleFactor}set minSizePx(e){this._passParameters.minSizePx!==e&&(this._passParameters.minSizePx=e,this._requestRender())}get minSizePx(){return this._passParameters.minSizePx}set useRealWorldSymbolSizes(e){this._passParameters.useRealWorldSymbolSizes!==e&&(this._passParameters.useRealWorldSymbolSizes=e,this._requestRender())}get useRealWorldSymbolSizes(){return this._passParameters.useRealWorldSymbolSizes}set size(e){this._passParameters.size!==e&&(this._passParameters.size=e,this._requestRender())}get size(){return this._passParameters.size}set sizePx(e){this._passParameters.sizePx!==e&&(this._passParameters.sizePx=e,this._requestRender())}get sizePx(){return this._passParameters.sizePx}set clippingBox(e){f(this._passParameters.clipBox,e||P)}get _clippingEnabled(){return!b(this._passParameters.clipBox,P,((e,s)=>e===s))}get slicePlaneEnabled(){return this._slicePlaneEnabled}set slicePlaneEnabled(e){this._slicePlaneEnabled!==e&&(this._slicePlaneEnabled=e,this._requestRender())}addNode(e){this._nodes.push(e),this._highlights.nodeAdded(e),this._requestRender()}removeNode(e){let t=null;return this._nodes.filterInPlace((i=>i.id!==e||(t=i,i.vao=s(i.vao),this._highlights.nodeRemoved(i),!1))),this._requestRender(),t}forEachNode(e){this._nodes.forAll(e)}removeAll(){this._nodes.forAll((e=>e.vao=s(e.vao))),this._highlights.removeAll(),this._nodes.clear(),this._requestRender()}highlight(e){return this._highlights.add(e)}_addHighlight(e,s,t){e.highlights=se(e.highlights,s,t),this._requestRender()}_removeHighlight(e,s){e.highlights=te(e.highlights,s),this._requestRender()}_initNode(e,s){const t=e.rctx;s.vao=new N(t,v,Q,{positions:D.createVertex(t,k.STATIC_DRAW,s.coordinates),colors:D.createVertex(t,k.STATIC_DRAW,s.rgb)})}_requestRender(){this._context&&this._context.requestRender()}};e([i({constructOnly:!0})],Y.prototype,"createGraphic",void 0),Y=e([r("esri.views.3d.layers.i3s.PointRenderer")],Y);class J extends H{constructor(e,s,t,i,r,n,o,a,l=null,h=null){super(t,r,s),this.id=e,this.obb=i,this.coordinates=n,this.rgb=o,this.attributes=a,this.pointIdFilterMap=l,this.highlights=h}}function K(e){return e.hasOwnProperty("splatSize")}function X(e,s,t,i,r){if(t.drawScreenSpace)return t.fixedSize*s*i;const n=M(r)*s*i;return t.useFixedSizes?Math.min(t.fixedSize/2,n):t.screenMinSize>0?Math.min(Math.max(t.screenMinSize*s*i,e/2),n):Math.min(e/2,n)}function Z(e,s,t,i,r){return t.drawScreenSpace?0:X(e,s,t,i,r)}function $(e,s,t){return null==t&&(t=u()),t[0]=e.origin[0]+e.coordinates[3*s],t[1]=e.origin[1]+e.coordinates[3*s+1],t[2]=e.origin[2]+e.coordinates[3*s+2],t}function ee(e){return null!=e.component?e.component:-1}function se(e,s,t){null==e&&(e=[]);const i={component:s,id:t};e.push(i);const r=ee(i);let n=e.length-1;for(;n>0&&r<ee(e[n-1]);)[e[n-1],e[n]]=[e[n],e[n-1]],--n;return e}function te(e,s){if(null==e)return e;const t=e.filter((e=>e.id!==s));return 0===t.length?null:t}class ie{constructor(){this.node=null,this.pointId=null,this.point=null,this.dist=null,this.normal=null,this.layerUid=""}}function re(e){return null!=e.dist&&null!=e.point&&null!=e.pointId&&null!=e.node}export{Y as PointRenderer,J as PointRendererNode,K as isInstanceOfNode};
