/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import e from"../../../core/Accessor.js";import n from"../../../core/Evented.js";import{isAborted as i}from"../../../core/promiseUtils.js";import{watch as s,sync as r,syncAndInitial as a}from"../../../core/reactiveUtils.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import{subclass as p}from"../../../core/accessorSupport/decorators/subclass.js";import{project as c,initializeProjection as d}from"../../../geometry/projection.js";import{absoluteHeightElevationInfo as h}from"../../../support/elevationInfoUtils.js";import{fromPoint as l}from"../sketch/normalizedPoint.js";import{defaults as u}from"./Settings.js";import{SnappingDomain as f}from"./SnappingDomain.js";import{defaultSnappingEnginesFactory as _}from"./snappingFactory.js";import g from"./SnappingOptions.js";import{snappingPointToSnappingOutput as m}from"./snappingPointUtils.js";import{sortCandidatesInPlace as S,squaredScreenDistance as v}from"./snappingUtils.js";import{IntersectionSnappingCandidate as y}from"./candidates/IntersectionSnappingCandidate.js";import{vectorToScreenPoint as C}from"../support/viewUtils.js";let P=class extends(n.EventedMixin(e)){constructor(t){super(t),this.options=new g,this.snappingEnginesFactory=_,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=T.MAIN}initialize(){this.addHandles([s((()=>{const{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:n,distance:i}=this.options;return{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:n,distance:i}}),(()=>{this.doneSnapping(),this.emit("changed")}),r),s((()=>this.options),(t=>{for(const e of this._engines)e.options=t}),r),s((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:t,snappingEnginesFactory:e})=>this._recreateEngines(t,e)),a)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((t=>t.updating))}_recreateEngines(t,e){if(this._destroyEngines(),!t)return;const{view:n,options:i}=this;this._engines=e(n,i)}_destroyEngines(){for(const t of this._engines)t.destroy();this._engines=[]}get _squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:t,touchSensitivityMultiplier:e}=this.options,n=t*e;return n*n}get _squaredSatisfiesConstraintThreshold(){return u.satisfiesConstraintScreenThreshold*u.satisfiesConstraintScreenThreshold}snap(t){return E(t)?this._snapMultiPoint(t):this._snapSinglePoint(t)}update(t){const{point:e,context:n}=t;this._removeVisualization();const i=this._currentMainCandidate;if(null==i)return e;const s=this._selectUpdateInput(t);if(null==s)return e;const{spatialReference:r}=n,a=c(s,r);if(null==a)return e;const{view:o}=this,{elevationInfo:p,visualizer:d}=n,h=[],u=l(a,o,p),f=i.constraint.closestTo(u);if(!this._arePointsWithinScreenThreshold(u,f,n))return this._resetSnappingState(),e;i.targetPoint=f,h.push(...i.hints);for(const c of this._currentOtherActiveCandidates)c.targetPoint=f,h.push(...c.hints);return null!=d&&this.addHandles(d.draw(h,{spatialReference:r,elevationInfo:I(n),view:o,selfSnappingZ:n.selfSnappingZ}),w),m(f,o,{z:e.z,m:e.m,spatialReference:e.spatialReference,elevationInfo:p})}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:t,scenePoint:e}){switch(this._currentSnappedType){case T.MAIN:return t;case T.SCENE:return e}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=T.MAIN}_removeVisualization(){this.removeHandles(w)}async _snapSinglePoint({point:t,context:e,signal:n}){const{view:i}=this,{elevationInfo:s}=e,r=l(t,i,s),a=await this._fetchCandidates(r,f.ALL,e,n);return this._createSnapResult(r,T.MAIN,a,i,e,{z:t.z,m:t.m,spatialReference:t.spatialReference,elevationInfo:s},n)}async _snapMultiPoint({point:t,scenePoint:e,context:n,signal:i}){const{view:s}=this,{coordinateHelper:r,elevationInfo:a,spatialReference:o}=n;await d(e.spatialReference,o);const p=c(e,o),h=l(p,s,a),u=await this._fetchCandidates(h,f.FEATURE,n,i);if(u.length>0){const t=await this._fetchCandidates(h,f.SELF,n,i);return this._createSnapResult(h,T.SCENE,[...u,...t],s,n,{z:p.z,m:p.m,spatialReference:p.spatialReference,elevationInfo:a},i)}const _=l(t,s,a),g=await this._fetchCandidates(_,f.SELF,n,i);return this._createSnapResult(_,T.MAIN,g,s,n,{z:r.hasZ()&&t.hasZ?t.z??0:void 0,m:r.hasM()&&t.hasM?t.m??0:void 0,spatialReference:t.spatialReference,elevationInfo:a},i)}async _fetchCandidates(t,e,n,i){return(await Promise.all(this._engines.map((s=>s.fetchCandidates(t,e,n,i))))).flat()}_createSnapResult(t,e,n,s,r,a,o){return{get valid(){return!i(o)},apply:()=>{const{spatialReference:i}=r,{snappedPoint:o,hints:p}=this._processCandidates(t,e,n,r);return this._removeVisualization(),null!=r.visualizer&&this.addHandles(r.visualizer.draw(p,{spatialReference:i,elevationInfo:h,view:s,selfSnappingZ:r.selfSnappingZ}),w),m(o,s,a)}}}_processCandidates(t,e,n,i){if(n.length<1)return this.doneSnapping(),{snappedPoint:t,hints:[]};this._currentSnappedType!==e&&this._resetSnappingState(),S(t,n);const s=this._currentMainCandidate;if(null!=s){const r=this._findOldConstraintInNewCandidates(s,n);if(r>=0){if(!(n[r]instanceof y))return this._intersectWithOtherCandidates(r,n,t,e,i);if(this._arePointsWithinScreenThreshold(t,s.targetPoint,i))return this._updateSnappingCandidate(s,e,n,i)}}return this._intersectWithOtherCandidates(0,n,t,e,i)}_findOldConstraintInNewCandidates(t,e){return t instanceof y?this._findOldCandidateIndex(e,t.first)>=0&&this._findOldCandidateIndex(e,t.second)>=0?0:-1:this._findOldCandidateIndex(e,t)}_intersectWithOtherCandidates(t,e,n,i,s){const{coordinateHelper:r}=s,a=e[t],o=[];for(let p=0;p<e.length;++p){if(p===t)continue;const i=e[p],s=a.constraint.intersect(i.constraint);if(s)for(const t of s.closestPoints(a.targetPoint))o.push([new y(t,a,i,i.isDraped),this._squaredScreenDistance(n,t,r)])}return o.length>0&&(o.sort(((t,e)=>t[1]-e[1])),o[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(o[0][0],i,e,s):this._updateSnappingCandidate(a,i,e,s)}_updateSnappingCandidate(t,e,n,i){this.doneSnapping(),this._currentMainCandidate=t,this._currentSnappedType=e;const s=this._currentMainCandidate.targetPoint,r=[];r.push(...t.hints);for(const a of n){if(t instanceof y){if(a.constraint.equals(t.first.constraint)||a.constraint.equals(t.second.constraint))continue}else if(a.constraint.equals(t.constraint))continue;const e=a.constraint.closestTo(s);this._squaredScreenDistance(e,s,i.coordinateHelper)<this._squaredSatisfiesConstraintThreshold&&(a.targetPoint=s,this._currentOtherActiveCandidates.push(a),r.push(...a.hints))}return{snappedPoint:s,hints:r}}_squaredPointProximityThreshold(t){return"touch"===t?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}_arePointsWithinScreenThreshold(t,e,n){return this._squaredScreenDistance(t,e,n.coordinateHelper)<this._squaredPointProximityThreshold(n.pointer)}_squaredScreenDistance(t,e,n){return v(this._toScreen(t,n),this._toScreen(e,n))}_toScreen(t,e){return C(t,e.spatialReference,h,this.view)}_findOldCandidateIndex(t,e){let n=-1;for(let i=0;i<t.length;++i)if(e.constraint.equals(t[i].constraint)){n=i;break}return n}get test(){return{visualizationsActive:this.hasHandles(w),engines:this._engines}}};var T;t([o({constructOnly:!0})],P.prototype,"view",void 0),t([o()],P.prototype,"options",void 0),t([o({readOnly:!0})],P.prototype,"updating",null),t([o()],P.prototype,"snappingEnginesFactory",void 0),t([o()],P.prototype,"_engines",void 0),t([o()],P.prototype,"_squaredMouseProximityTreshold",null),t([o()],P.prototype,"_squaredTouchProximityThreshold",null),t([o()],P.prototype,"_squaredSatisfiesConstraintThreshold",null),P=t([p("esri.views.interactive.snapping.SnappingManager")],P),function(t){t[t.MAIN=0]="MAIN",t[t.SCENE=1]="SCENE"}(T||(T={}));const w="visualization-handle";function E(t){return null!=t.scenePoint}function I({coordinateHelper:t,elevationInfo:e}){return t.hasZ()?h:e}export{P as SnappingManager};
