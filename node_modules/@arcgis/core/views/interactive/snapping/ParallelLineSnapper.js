/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{k as e}from"../../../chunks/vec2.js";import{a as t}from"../../../chunks/vec2f64.js";import{absoluteHeightElevationInfo as r}from"../../../support/elevationInfoUtils.js";import{fromAnyMapPoint as i,fromValues as s}from"../sketch/normalizedPoint.js";import{defaults as o}from"./Settings.js";import{SnappingAlgorithm as n}from"./SnappingAlgorithm.js";import{editEdgeToSnappingEdge as l,squaredScreenDistance as a}from"./snappingUtils.js";import{ParallelLineSnappingCandidate as h}from"./candidates/ParallelLineSnappingCandidate.js";import{vectorToScreenPoint as c}from"../support/viewUtils.js";import{projectPointToLine as d}from"../../support/geometry2dUtils.js";class p extends n{snapNewVertex(e,t){const s=t.editGeometryOperations.data.components[0],o=s.edges.length,n=s.vertices.length,a=[];if(o<2)return a;const{view:h}=this,d=c(e,t.spatialReference,r,h),p=i(s.vertices[n-1].pos,h,t),g=i(s.vertices[0].pos,h,t),f=s.edges[o-1];let m=f;do{if(this.edgeExceedsShortLineThreshold(m,t)){const r=l(m,h,t);this._checkEdgeForParallelLines(r,p,e,d,t,a),this._checkEdgeForParallelLines(r,g,e,d,t,a)}m=m.leftVertex.leftEdge}while(m&&m!==f);return a}snapExistingVertex(e,t){const s=[],o=t.vertexHandle,n=o.component;if(n.edges.length<3)return s;const{view:a}=this,h=c(e,t.spatialReference,r,a),d=o.leftEdge,p=o.rightEdge,g=n.vertices[0],f=i(g.pos,a,t),m=n.vertices.length,u=n.vertices[m-1],v=i(u.pos,a,t),E=n.edges[0];let L=E;do{if(L!==d&&L!==p&&this.edgeExceedsShortLineThreshold(L,t)){const r=l(L,a,t);d&&this._checkEdgeForParallelLines(r,i(d.leftVertex.pos,a,t),e,h,t,s),p&&this._checkEdgeForParallelLines(r,i(p.rightVertex.pos,a,t),e,h,t,s),o===g?this._checkEdgeForParallelLines(r,v,e,h,t,s):o===u&&this._checkEdgeForParallelLines(r,f,e,h,t,s)}L=L.rightVertex.rightEdge}while(L&&L!==E);return s}_checkEdgeForParallelLines(t,i,n,l,p,f){const m=t.left,u=t.right;if(d(g,i,m,u),e(g,i)<o.parallelLineThreshold)return;d(g,n,m,u,i);const{spatialReference:v,pointer:E}=p,L=s(g[0],g[1],n[2]);if(a(l,c(L,v,r,this.view))<this.squaredProximityThreshold(E)){if(this.isVertical(L,i)||this.isVertical(m,u))return;if(this._parallelToPreviousCandidate(t,f))return;f.push(new h({referenceLine:t,lineStart:i,targetPoint:L,isDraped:"on-the-ground"===p.elevationInfo?.mode}))}}_parallelToPreviousCandidate(t,r){const i=t.left,s=t.right;for(const n of r)if(d(g,s,n.constraint.start,n.constraint.end,i),e(g,s)<o.parallelLineThreshold)return n.addReferenceLine(t),!0;return!1}}const g=t();export{p as ParallelLineSnapper};
