/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import r from"../../../core/Accessor.js";import t from"../../../core/Logger.js";import{watch as i,syncAndInitial as l}from"../../../core/reactiveUtils.js";import{sqlAnd as s}from"../../../core/sql.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import{subclass as n}from"../../../core/accessorSupport/decorators/subclass.js";import a from"../../../layers/support/FeatureFilter.js";import{getFloorFilterClause as p}from"../../../layers/support/floorFilterUtils.js";import{isSubtypeGroupLayer as u,isFeatureLayer as d}from"../../../layers/support/layerUtils.js";import{isUtilityNetworkWebMap as c}from"./snappingUtils.js";let y=class extends r{get layerView(){return this.view?.allLayerViews?.find((e=>e.layer===this.layer))}get valid(){return this._valid}get subtypeFilter(){const{layer:e}=this;if(!u(e)||!e.subtypes?.length)return{mode:"not-in-use",filter:null};const r=e.fieldsIndex.get(e.subtypeField)?.name??e.subtypeField,t=e.sublayers.filter((e=>e.visible)).map((e=>e.subtypeCode));return t.length?t.length===e.subtypes.length?{mode:"all-visible",filter:null}:1===t.length?{mode:"in-use",filter:`${r} = ${t.getItemAt(0)}`}:{mode:"in-use",filter:`${r} IN (${t.join(", ")})`}:{mode:"none-visible",filter:null}}get floorFilter(){const{view:e,layer:r}=this;return e&&r?p({view:e,layer:r}):null}constructor(e){super(e),this.rulesTable=null,this._valid=!1}initialize(){if(!this.snappingSource||!this.layer)return;const{layer:e,snappingSource:r}=this;if("refresh"in e){const t=e;this.addHandles(t.on("refresh",(()=>r.refresh())))}this.loadRules(),this.addHandles([i((()=>r.updating),(e=>r.layerSource.updating=e),l),i((()=>r.availability),(e=>r.layerSource.availability=e),l)])}getFetchCandidatesParameters(e,r,t){if(!this.valid)return[];const{layer:i,layerView:l,floorFilter:o,rulesTable:n,subtypeFilter:p}=this,u={distance:t,mode:this.view?.type??"2d",point:e,coordinateHelper:r.coordinateHelper,...this._types,filter:l&&"filter"in l?l.filter:null};if(o&&(u.filter=f(u.filter,o)),"not-in-use"!==p.mode&&"all-visible"!==p.mode){if("none-visible"===p.mode)return[];u.filter?u.filter.where=s(u.filter.where,p.mode):u.filter=new a({where:p.filter})}if(n){const e=r.feature,t=e?.sourceLayer;if(!(e&&d(i)&&i.layerId&&d(t)&&"loaded"===n.loadStatus))return[];const l=[],s=i.layerId,o=n.getFeatureSQL(t,e)?.[s];if(!o)return[];const a=o.anyVertex;let p=o.endVertex;return p&&a&&p===a&&(p=""),p&&l.push({...u,returnEdge:!1,vertexMode:"ends",filter:f(u.filter,p)}),a&&l.push({...u,returnEdge:!1,vertexMode:"all",filter:f(u.filter,a)}),l}return[u]}async loadRules(){const{layer:e,view:r}=this;if(e&&r&&c(r?.map)&&d(e)){const l=r.map.utilityNetworks?.find((r=>r.isUtilityLayer(e)));if(l)try{this.rulesTable=await l.getRulesTable(),await(this.rulesTable?.load()),this._valid=!0}catch(i){return void t.getLogger("esri.views.interactive.snapping.FeatureSnappingSourceInfo").error("Failed to load rules table for snapping source",e.title)}}else this._valid=!0}get _types(){return{returnEdge:!0,vertexMode:"all"}}remove(){this.destroy()}destroy(){this.snappingSource?.destroy()}};function f(e,r){return null==e?new a({where:r}):e.where?new a({where:s(e.where,r)}):new a({where:r})}e([o({constructOnly:!0})],y.prototype,"layer",void 0),e([o({constructOnly:!0})],y.prototype,"snappingSource",void 0),e([o({constructOnly:!0})],y.prototype,"view",void 0),e([o()],y.prototype,"layerView",null),e([o()],y.prototype,"rulesTable",void 0),e([o()],y.prototype,"valid",null),e([o()],y.prototype,"subtypeFilter",null),e([o()],y.prototype,"floorFilter",null),e([o()],y.prototype,"_valid",void 0),y=e([n("esri.views.interactive.snapping.FeatureSnappingSourceInfo")],y);export{y as FeatureSnappingSourceInfo};
