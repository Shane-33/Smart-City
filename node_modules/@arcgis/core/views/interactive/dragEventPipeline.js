/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import"../../geometry.js";import{isSome as e}from"../../core/arrayUtils.js";import"../../core/has.js";import{clone as t}from"../../core/lang.js";import{clamp as n}from"../../core/mathUtils.js";import{createScreenPoint as r}from"../../core/screenUtils.js";import{g as a}from"../../chunks/vec3f64.js";import{project as o}from"../../geometry/projection.js";import{hydratedSpatialReference as l,clonePoint as s}from"../../layers/graphics/hydratedFeatures.js";import{MeshTransformUpdateAction as c}from"../../layers/graphics/sources/interfaces.js";import{getZForElevationMode as i}from"../../support/elevationInfoUtils.js";import{ViewingMode as u}from"../ViewingMode.js";import{move as p}from"../draw/support/drawUtils.js";import m from"../../geometry/Point.js";function f(e,t){let n=null,r=null;return a=>{if("cancel"===a.action)return void(null!=r&&(r.execute({action:"cancel"}),n=null,r=null));const o={action:a.action,screenStart:a.start,screenEnd:a.screenPoint};"start"===a.action&&null==n&&(n=new U,r=new U,t(e,n,r,a.pointerType,o)),null!=n&&n.execute(o),"end"===a.action&&null!=n&&(n=null,r=null)}}function d(e,t){return e.events.on("drag",f(e,t))}function y(e,t){const n=[e.x,e.y,e.z??0],r=t,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const l=e=>{const t=(e.x-n[0])*a[0]+(e.y-n[1])*a[1];e.x=n[0]+t*a[0],e.y=n[1]+t*a[1]};return e=>(l(e.mapStart),l(e.mapEnd),{...e,axis:a})}function x(e,t){let n=null;return r=>{if("start"===r.action&&(n=h(e,r.mapStart.spatialReference,t)),null==n)return null;const a=r.mapEnd.x-r.mapStart.x,o=r.mapEnd.y-r.mapStart.y,l=r.mapEnd.z-r.mapStart.z;return n.move(a,o,l,r.action),{...r,translationX:a,translationY:o,translationZ:l}}}function g(e,t){return null==e?null:e.spatialReference.equals(t)?e.clone():o(e,t)}function h(e,t,n){const r=e.geometry,a=l(t);if(null==r)return null;if("mesh"===r.type)return E(e,r,a,n);const s=g(r,a),c=r.spatialReference;return null==s?null:{move:(t,n,r)=>{const a=p(s.clone(),t,n,r);a.spatialReference.equals(c)?e.geometry=a:e.geometry=o(a,c)}}}function E(e,t,n,r){if(t.vertexSpace.isRelative)return S(e,t,t.vertexSpace,n);if(!t.spatialReference.equals(n))return null;let a=0,o=0,l=0;return{move:(n,s,c)=>{const i=n-a,p=s-o,f=c-l;if(i||p||f){const d=new m(t.origin.x+i,t.origin.y+p,(t.origin.z??0)+f,t.origin.spatialReference);t.centerAt(d,{geographic:t.vertexSpace.isRelative?void 0:r===u.Global}),e.notifyGeometryChanged(),a=n,o=s,l=c}}}}function S(e,t,n,r){const a=g(n.getOriginPoint(t.spatialReference),r),l=t.spatialReference;return null==a?null:{move:(t,r,s,i)=>{const u=p(a.clone(),t,r,s);if(u.spatialReference.equals(l))n.setOriginFromPoint(u);else{const e=o(u,l);null!=e&&n.setOriginFromPoint(e)}if(n.isGeoreferenced)e.notifyGeometryChanged();else{const t="end"===i;e.notifyMeshTransformChanged(t?{action:c.UpdateFastLocalOrigin}:{})}}}}function v(e,t=null,n){let r=null;const a=null==t||e.spatialReference?.equals(t)?e=>e:e=>null!=e?o(e,t):e,l={exclude:[],...n};return t=>{if("start"===t.action&&(r=a(e.toMap(t.screenStart,l))),null==r)return null;const n=a(e.toMap(t.screenEnd,l));return null!=n?{...t,mapStart:r,mapEnd:n}:null}}function j(t,n){const r=t.map((e=>x(e,n))).filter(e);return e=>{const t=e.mapEnd.x-e.mapStart.x,n=e.mapEnd.y-e.mapStart.y,a=e.mapEnd.z-e.mapStart.z;return r.forEach((t=>t(e))),{...e,translationX:t,translationY:n,translationZ:a}}}function R(e,n){const r=new Map;for(const a of n)r.set(a,t(e[a]));return t=>(r.forEach(((t,n)=>{e[n]=t})),t)}function z(e){return null!=e.geometry&&"mesh"===e.geometry.type?M(e,e.geometry):R(e,["geometry"])}function M(e,t){const{vertexSpace:n}=t;if(n.isGeoreferenced){const n=t.vertexAttributes.clonePositional();return r=>(t.vertexAttributes=n,e.notifyGeometryChanged(),r)}const r=a(n.origin),o=t.transform?.clone();return n=>(t.transform=o,t.vertexSpace.origin=r,e.notifyMeshTransformChanged(),n)}function w(e){const t=e.map((e=>z(e))).filter((e=>null!=e));return e=>(t.forEach((t=>t(e))),e)}function P(){let e=0,t=0,n=0;return r=>{"start"===r.action&&(e=r.mapStart.x,t=r.mapStart.y,n=r.mapStart.z);const a=r.mapEnd.x-e,o=r.mapEnd.y-t,l=r.mapEnd.z-n;return e=r.mapEnd.x,t=r.mapEnd.y,n=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:l,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function q(){let e=0,t=0;return n=>{"start"===n.action&&(e=n.screenStart.x,t=n.screenStart.y);const r=n.screenEnd.x-e,a=n.screenEnd.y-t;return e=n.screenEnd.x,t=n.screenEnd.y,{...n,screenDeltaX:r,screenDeltaY:a}}}function D(e,t){let a=null,o=0,l=0;return s=>{if("start"===s.action&&(a=e.toScreen?.(t),null!=a&&(a.x<0||a.x>e.width||a.y<0||a.y>e.height?a=null:(o=s.screenStart.x-a.x,l=s.screenStart.y-a.y))),null==a)return null;const c=n(s.screenEnd.x-o,0,e.width),i=n(s.screenEnd.y-l,0,e.height),u=r(c,i);return s.screenStart=a,s.screenEnd=u,s}}const G=()=>{};class U{constructor(){this.execute=G}next(e,t=new U){return null!=e&&(this.execute=n=>{const r=e(n);null!=r&&t.execute(r)}),t}}function C(e,t,n=[]){if("2d"===e.type)return e=>e;let r=null;return a=>{"start"===a.action&&(r=e.toMap(a.screenStart,{exclude:n}),null!=r&&(r.z=i(r,e,t)));const o=e.toMap(a.screenEnd,{exclude:n});null!=o&&(o.z=i(o,e,t));const l=null!=r&&null!=o?{sceneStart:r,sceneEnd:o}:null;return{...a,scenePoints:l}}}function F(e,t,n){const r=t.elevationProvider.getElevation(e.x,e.y,e.z??0,e.spatialReference,"scene")??0,a=s(e);return a.z=r,a.hasZ=!0,a.z=i(a,t,n),a}function O(e,t){if("2d"===e.type)return e=>e;let n=null;return r=>{"start"===r.action&&(n=F(r.mapStart,e,t));const a=F(r.mapEnd,e,t),o=null!=n&&null!=a?{sceneStart:n,sceneEnd:a}:null;return{...r,scenePoints:o}}}export{U as EventPipeline,P as addMapDelta,q as addScreenDelta,y as constrainToMapAxis,f as createDragEventPipelineCallback,d as createManipulatorDragEventPipeline,D as dragAtLocation,x as dragGraphic,j as dragGraphicMany,z as resetGraphic,w as resetGraphicMany,R as resetProperties,C as sceneSnappingAtLocation,O as sceneSnappingAtProjectedLocation,v as screenToMap};
