/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{isSome as t,equals as e}from"../../../core/arrayUtils.js";import{g as n,c as r,k as s}from"../../../chunks/vec2.js";import{a as i}from"../../../chunks/vec2f64.js";import{j as o,c as u,g as c,q as a,h as f,a as l,u as h,m as d,s as p,f as m,G as L}from"../../../chunks/vec3.js";import{c as k,g,f as P,d as T}from"../../../chunks/vec3f64.js";import{create as y,intersectLine as q,distance as x,isVertical as v,intersectPlanes as z,signedDistance as j,projectPoint as w,fromPositionAndNormal as E,fromPoints as A,normal as M}from"../../../geometry/support/plane.js";import{create as N}from"../../../geometry/support/ray.js";import{k as Z,l as I,p as G,m as S}from"../../../chunks/sphere.js";import{fromVec3 as O,clone as U,fromValues as b}from"./normalizedPoint.js";import{vectorsHaveCloseZ as C,isClose as F,isPointInsidePlane as H,intersectLineLikeAndCircle as R,pointsInsidePlane as Y,intersectVerticalPlaneAndVerticalCylinder as _,projectPointToLineLike as B,projectPointToVerticalCylinder as D,projectPointToVerticalPlane as J,VerticalPlaneType as K,intersectLineLikes as Q,intersectVerticalPlaneAndLineLike as V,intersectLineLikeAndVerticalCylinder as W,intersectVerticalPlanes as X,intersectVerticalCylinders as $,intersectVerticalPlaneAndPoint as tt}from"../../support/geometry3dUtils.js";import{LineType as et}from"../../support/geometry2dUtils.js";class nt{intersect(t){return zt(this,t)}closestPoints(t){return[this.closestTo(t)]}}class rt extends nt{constructor(t){super(),this.point=t}equals(t){return this===t||$t(t)&&f(this.point,t.point)}closestTo(){return U(this.point)}}class st extends nt{constructor(t,e,n){super(),this.start=t,this.end=e,this.lineLike={start:t,end:e,type:n}}equals(t){return this===t||te(t)&&this.lineLike.type===t.lineLike.type&&f(this.start,t.start)&&f(this.end,t.end)}closestTo(t){const e=B(t,this.lineLike);return O(e)}}class it extends st{constructor(t,e){super(t,e,et.LINE)}}class ot extends st{constructor(t,e){super(t,e,et.RAY)}}class ut extends nt{constructor(t){super(),this.constraints=t}equals(t){return this===t||Xt(t)&&e(this.constraints,t.constraints,((t,e)=>t.equals(e)))}closestTo(t){let e,n=1/0;for(const r of this.constraints){const s=r.closestTo(t),i=l(t,s);i<n&&(n=i,e=s)}return e?U(e):t}closestPoints(t){return this.constraints.flatMap((e=>e===this?[]:e.closestPoints(t)))}}class ct extends nt{constructor(t,e){super(),this.center=t,this.radius=e}equals(t){return this===t||re(t)&&this.center[0]===t.center[0]&&this.center[1]===t.center[1]&&this.radius===t.radius}closestTo(t){const e=D(t,this.center,this.radius);return O(e)}}class at extends nt{constructor(t,e){super(),this.center=t,this.radius=e}equals(t){return this===t||se(t)&&f(this.center,t.center)&&this.radius===t.radius}closestTo(t){const e=D(t,this.center,this.radius);return e[2]=this.center[2],O(e)}asCircle(){return new ft(U(this.center),this.radius,b(0,0,1))}}class ft extends nt{constructor(t,e,n,r=void 0){super(),this.center=t,this.radius=e,this.normal=n,this.slicePlane=r}equals(t){return this===t||ie(t)&&f(this.center,t.center)&&f(this.normal,t.normal)&&this.radius===t.radius}closestTo(t){const{center:e,radius:n}=this;w(this.getPlane(ht),t,lt);const r=h(lt,lt,e),s=d(r);if(F(s,0))return U(t);const i=n/Math.sqrt(s),o=a(k(),e,r,i),{slicePlane:u}=this;if(u&&!H(u,o)){const e=At(u,this);return e?.closestTo(t)??U(t)}return O(o)}getPlane(t=y()){return E(this.center,this.normal,t)}}const lt=k(),ht=y();class dt extends nt{constructor(t){super(),this.z=t}equals(t){return this===t||ee(t)&&this.z===t.z}closestTo(t){return O(P(t[0],t[1],this.z))}getPlane(t=y()){return p(pt,0,0,this.z),E(pt,T,t)}}const pt=k();class mt extends nt{constructor(t,e,n){super(),this.start=t,this.end=e,this.planeLike={start:t,end:e,type:n}}equals(t){return this===t||ne(t)&&this.planeLike.type===t.planeLike.type&&f(this.start,t.start)&&f(this.end,t.end)}closestTo(t){return O(J(t,this.planeLike))}closestEndTo(t){const{start:e,end:s}=this;return Math.sign(n(r(Lt,s,e),r(kt,t,e)))>0?s:e}getPlane(t=y()){const e=u(gt,this.end);return e[2]+=1,A(this.start,this.end,e,t)}getSlicePlane(t=y()){const{start:e,end:n,type:r}=this.planeLike;if(r===K.PLANE)return;const s=p(gt,e[0],e[1],0),i=p(Pt,n[0],n[1],0),o=m(Pt,i,s);return E(s,o,t),t}}const Lt=i(),kt=i(),gt=k(),Pt=k();class Tt extends mt{constructor(t,e){super(t,e,K.HALF_PLANE)}}class yt extends mt{constructor(t,e){super(t,e,K.PLANE)}}class qt extends nt{constructor(t,e){super(),this.sphere=Z(t,e)}equals(t){return this===t||oe(t)&&I(this.sphere,t.sphere)}closestTo(t){const e=G(this.sphere,t,k());return O(e)}get center(){return this.sphere}get radius(){return this.sphere[3]}}class xt extends nt{constructor(t,e,n){super(),this.start=t,this.end=e,this.getZ=n,this.planeLike={start:t,end:e,type:K.PLANE}}equals(t){return this===t||ue(t)&&f(this.start,t.start)&&f(this.end,t.end)&&this.getZ===t.getZ}closestTo(t){return vt(this,t)}addIfOnTheGround(t,e){for(const n of e){const e=this.getZ(n[0],n[1])??0;F(n[2],e)&&(n[2]=e,t.push(n))}}}function vt(t,e){const n=J(e,t.planeLike);return n[2]=t.getZ(n[0],n[1])??ce,O(n)}function zt(t,e){if(Xt(t)){const n=[];for(const r of t.constraints){const t=r.intersect(e);t&&n.push(t)}return Wt(n)}if(Xt(e))return zt(e,t);if(ue(t))return Jt(t,e);if(ue(e))return Jt(e,t);if($t(t)){const{point:n}=t,r=e.closestTo(n);return L(r,n)?t:void 0}if(te(t)){if($t(e))return zt(e,t);if(te(e))return Qt(Q(t.lineLike,e.lineLike));if(ee(e))return jt(t,e);if(ne(e))return Qt(V(e.planeLike,t.lineLike));if(re(e))return Qt(W(t.lineLike,e.center,e.radius));if(ie(e))return Qt(R(t.lineLike,e));if(se(e))return wt(t,e);if(oe(e))return Et(t,e)}else if(ee(t)){if($t(e)||te(e))return zt(e,t);if(ee(e))return Mt(t,e);if(ne(e))return Nt(t,e);if(re(e))return Zt(t,e);if(ie(e))return Gt(t,e);if(se(e))return It(t,e);if(oe(e))return St(t,e)}else if(ne(t)){if($t(e)||te(e)||ee(e))return zt(e,t);if(ne(e))return Kt(X(t.planeLike,e.planeLike));if(re(e))return Kt(_(t.planeLike,e.center,e.radius));if(ie(e))return Ut(t,e);if(se(e))return Ot(t,e);if(oe(e))return bt(t,e)}else if(re(t)){if($t(e)||te(e)||ee(e)||ne(e))return zt(e,t);if(re(e))return Kt($(t.center,t.radius,e.center,e.radius));if(ie(e))return Ct();if(se(e))return Ft(t,e);if(oe(e))return Ht()}else if(ie(t)){if($t(e)||te(e)||ee(e)||ne(e)||re(e))return zt(e,t);if(ie(e))return Rt();if(se(e))return Rt(e.asCircle());if(oe(e))return Yt()}else if(se(t)){if($t(e)||te(e)||ee(e)||ne(e)||re(e)||ie(e))return zt(e,t);if(se(e))return _t(e,t);if(oe(e))return Bt()}else if(oe(t)){if($t(e)||te(e)||ee(e)||ne(e)||re(e)||se(e))return zt(e,t);if(oe(e))return Dt()}}const jt=(()=>{const t=y();return(e,n)=>{const{start:r,end:s}=e;if(C(r,s)&&F(r[2],n.z))return e;const i=k();return q(n.getPlane(t),r,s,i)?new rt(O(i)):void 0}})();function wt({lineLike:t},{center:e,radius:n}){const r=e[2];return Qt(W(t,e,n).filter((t=>F(t[2],r))))}function Et({lineLike:t},{sphere:e}){return Qt(S(e,t.start,t.end))}const At=(()=>{const t=N(),e=y(),n={start:k(),end:k(),type:et.LINE};return(r,s,i)=>{const{normal:a,center:f,radius:l}=s,h=o(a,M(r)),d=F(x(r,f),0);if(F(h,1))return d?s:void 0;if(s.getPlane(e),d&&F(h,0)&&v(r)&&v(e)){if(F(l,0))return!i||H(i,f)?new rt(U(f)):void 0;const t=g(f);t[2]+=l;const e=g(f);e[2]-=l;const n=[];return i&&!H(i,t)||n.push(t),i&&!H(i,e)||n.push(e),Qt(n)}if(!z(r,e,t))return;u(n.start,t.origin),c(n.end,t.origin,t.direction);const p=R(n,s);return Qt(i?Y(i,p):p)}})();function Mt(t,e){return F(t.z,e.z)?t:void 0}function Nt({z:t},{planeLike:e}){const[n,r]=e.start,[s,i]=e.end,o=b(n,r,t),u=b(s,i,t);return e.type===K.PLANE?new it(o,u):new ot(o,u)}function Zt(t,e){const[n,r]=e.center;return new at(b(n,r,t.z),e.radius)}function It(t,e){return F(e.center[2],t.z)?e:void 0}const Gt=(()=>{const t=y();return(e,n)=>At(e.getPlane(t),n)})();function St(t,{center:e,radius:n}){const r=Math.abs(e[2]-t.z);if(r>n&&!F(r,n))return;const s=b(e[0],e[1],t.z),i=Math.sqrt(n**2-r**2);return F(i,0)?void 0:new at(s,i)}const Ot=(()=>{const t=y();return(e,{center:n,radius:r})=>{const s=_(e.planeLike,n,r),i=n[2];e.getSlicePlane(t);const o=[];for(const[u,c]of s){const e=[u,c,i];H(t,e)&&o.push(e)}return Qt(o)}})(),Ut=(()=>{const t=y(),e=y();return(n,r)=>At(n.getPlane(t),r,n.getSlicePlane(e))})(),bt=(()=>{const t=y();return(e,{center:n,radius:r})=>{const s=e.getPlane(t),i=j(s,n),o=Math.abs(i);if(o>r&&!F(o,r))return;const u=g(M(s)),c=a(k(),n,u,i),f=Math.sqrt(r**2-i**2);return F(f,0)?new rt(O(w(s,n,k()))):new ft(O(c),f,u,e.getSlicePlane())}})();function Ct(t,e){}function Ft(t,e){const n=s(t.center,e.center);if(F(n,0)&&F(t.radius,e.radius))return e;return Vt($(t.center,t.radius,e.center,e.radius),e.center[2])}function Ht(t,e){}function Rt(t,e){}function Yt(t,e){}function _t(t,e){if(!C(t.center,e.center))return;const n=s(t.center,e.center);if(F(n,0)&&F(t.radius,e.radius))return t;return Vt($(t.center,t.radius,e.center,e.radius),t.center[2])}function Bt(t,e){}function Dt(t,e){}function Jt(t,e){const{planeLike:n,getZ:r}=t,s=[];if($t(e))t.addIfOnTheGround(s,tt(n,e.point));else if(te(e))t.addIfOnTheGround(s,V(n,e.lineLike));else if(re(e))for(const[i,o]of _(n,e.center,e.radius)){const t=r(i,o);null!=t&&s.push(P(i,o,t))}else if(ne(e)||ue(e))for(const[i,o]of X(n,e.planeLike)){const t=r(i,o)??ce;s.push(P(i,o,t))}return Qt(s)}function Kt(t){return Wt(t.map((([t,e])=>{const n=b(t,e,0),r=b(t,e,1);return new it(n,r)})))}function Qt(t){return Wt(t.map((t=>t?new rt(O(t)):void 0)))}function Vt(t,e){return Qt(t.map((([t,n])=>[t,n,e])))}function Wt(e){if(0!==e.length)return 1===e.length?e[0]??void 0:new ut(e.filter(t))}function Xt(t){return t instanceof ut}function $t(t){return t instanceof rt}function te(t){return t instanceof st}function ee(t){return t instanceof dt}function ne(t){return t instanceof mt}function re(t){return t instanceof ct}function se(t){return t instanceof at}function ie(t){return t instanceof ft}function oe(t){return t instanceof qt}function ue(t){return t instanceof xt}const ce=0;export{ft as CircleConstraint,nt as Constraint,xt as DrapedLineConstraint,at as HorizontalCircleConstraint,dt as HorizontalPlaneConstraint,it as LineConstraint,st as LineLikeConstraint,rt as PointConstraint,ot as RayConstraint,ut as SetConstraint,qt as SphereConstraint,ct as VerticalCylinderConstraint,Tt as VerticalHalfPlaneConstraint,yt as VerticalPlaneConstraint,mt as VerticalPlaneLikeConstraint};
