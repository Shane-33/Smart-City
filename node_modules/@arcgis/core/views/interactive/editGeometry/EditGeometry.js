/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import t from"../../../core/Evented.js";import s from"../../../geometry/Polygon.js";import i from"../../../geometry/Polyline.js";import{createCoordinateHelper as r}from"../coordinateHelper.js";import{unnormalize as n,getUnnormalizationInfo as o}from"./unnormalizationHelper.js";class h{constructor(e){this.component=e,this.leftEdge=null,this.rightEdge=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(e){this._pos=e,this.component.unnormalizeVertexPositions()}}class c{constructor(e,t,s){this.component=e,this.leftVertex=t,this.rightVertex=s,this.type="edge",t.rightEdge=this,s.leftEdge=this}}class l{constructor(e,t){this._spatialReference=e,this._viewingMode=t,this.vertices=[],this.edges=[],this.index=null}unnormalizeVertexPositions(){this.vertices.length<=1||n(this.vertices,o(this._spatialReference,this._viewingMode))}updateVertexIndex(e,t){if(0===this.vertices.length)return;const s=this.vertices[0];let i=null,r=e,n=t;do{i=r,i.index=n++,r=i.rightEdge?i.rightEdge.rightVertex:null}while(null!=r&&r!==s);i.leftEdge&&i!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(i),this.vertices.length-1)}getFirstVertex(){return 0===this.vertices.length?null:this.vertices[0]}getLastVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].leftEdge}swapVertices(e,t){const s=this.vertices[e];this.vertices[e]=this.vertices[t],this.vertices[t]=s}iterateVertices(e){if(0===this.vertices.length)return;const t=this.vertices[0];let s=t;do{e(s,s.index),s=null!=s.rightEdge?s.rightEdge.rightVertex:null}while(s!==t&&null!=s)}}class p extends t{constructor(e,t){super(),this.type=e,this.coordinateHelper=t,this._geometry=null,this._dirty=!0,this.components=[]}get geometry(){if(this._dirty){switch(this.type){case"point":this._geometry=this._toPoint();break;case"polyline":this._geometry=this._toPolyline();break;case"polygon":this._geometry=this._toPolygon()}this._dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}notifyChanges(e){this._dirty=!0,this.emit("change",e)}_toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos)}_toPolyline(){const e=[],t=this.coordinateHelper.vectorToArray;for(const s of this.components){if(s.vertices.length<1)continue;const i=[];let r=s.vertices.find((e=>null==e.leftEdge));const n=r;do{i.push(t(r.pos)),r=r.rightEdge?r.rightEdge.rightVertex:null}while(r&&r!==n);e.push(i)}return new i({paths:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}_toPolygon(){const e=[],t=this.coordinateHelper.vectorToArray;for(const s of this.components){if(s.vertices.length<1)continue;const i=[],r=s.vertices[0];let n=r;const o=n;do{i.push(t(n.pos)),n=null!=n.rightEdge?n.rightEdge.rightVertex:null}while(n&&n!==o);s.isClosed()&&i.push(t(r.pos)),e.push(i)}return new s({rings:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(t,s){const i=t.spatialReference,n=r(t.hasZ,t.hasM,i),o=new p(t.type,n);switch(t.type){case"polygon":{const r=t.rings;for(let t=0;t<r.length;++t){const p=r[t],g=new l(i,s);g.index=t;const a=p.length>2&&e(p[0],p[p.length-1]),d=a?p.length-1:p.length;for(let e=0;e<d;++e){const t=n.arrayToVector(p[e]),s=new h(g);g.vertices.push(s),s.pos=t,s.index=e}const u=g.vertices.length-1;for(let e=0;e<u;++e){const t=g.vertices[e],s=g.vertices[e+1],i=new c(g,t,s);g.edges.push(i)}if(a){const e=new c(g,g.vertices[g.vertices.length-1],g.vertices[0]);g.edges.push(e)}o.components.push(g)}break}case"polyline":{const e=t.paths;for(let t=0;t<e.length;++t){const r=e[t],p=new l(i,s);p.index=t;const g=r.length;for(let e=0;e<g;++e){const t=n.arrayToVector(r[e]),s=new h(p);p.vertices.push(s),s.pos=t,s.index=e}const a=p.vertices.length-1;for(let e=0;e<a;++e){const t=p.vertices[e],s=p.vertices[e+1],i=new c(p,t,s);p.edges.push(i)}o.components.push(p)}break}case"point":{const e=new l(i,s);e.index=0;const r=new h(e);r.index=0,r.pos=n.pointToVector(t),e.vertices.push(r),o.components.push(e);break}}return o}}export{l as Component,c as Edge,p as EditGeometry,h as Vertex};
