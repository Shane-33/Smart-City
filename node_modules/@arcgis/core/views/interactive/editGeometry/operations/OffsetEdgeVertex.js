/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{deg2rad as t}from"../../../../core/mathUtils.js";import{c as i,e,g as s}from"../../../../chunks/vec2.js";import{a as n}from"../../../../chunks/vec2f64.js";import{C as r,j as h,E as o,b as a,n as _,g as c,i as l,G as p,c as d}from"../../../../chunks/vec3.js";import{c as g,f as u}from"../../../../chunks/vec3f64.js";import{create as f,fromPositionAndNormal as m,signedDistance as D,copy as E,isPointInside as x,normal as b,intersectLine as I}from"../../../../geometry/support/plane.js";import{angle as V,projectPointSignedLength as M}from"../../../../geometry/support/vector.js";import{intersectLineAndRay as X,LineType as Y}from"../../../support/geometry2dUtils.js";class N{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(t,i,e,s=0,n=Z.IMMEDIATE){this._helper=t,this._planeType=i,this._edge=e,this.distance=s,this._plane=f(),this._offsetPlane=f(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,n===Z.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const t=this._toXYZ(this._edge.leftVertex.pos),i=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),e=this._toXYZ(this._edge.rightVertex.pos),s=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=r(g(),t,e),this._left=this._computeNeighbor(t,i,this._edgeDirection),this._right=this._computeNeighbor(e,s,this._edgeDirection)}_toXYZ(t){return null!=t?this._helper.toXYZ(t):null}_pointToXYZ(t){return this._toXYZ(this._helper.pointToVector(t))}_computeNeighbor(t,i,e){if(null==i)return{start:t,end:i,direction:u(-e[1],e[0],0),isOriginalDirection:!0};const s=r(g(),t,i),n=!this._passesBisectingAngleThreshold(s,e);return{start:t,end:i,direction:n?this._bisectVectorsPerpendicular(e,s):s,isOriginalDirection:!n}}_passesBisectingAngleThreshold(t,i){const e=Math.abs(V(i,t));return e>=P&&e<=Math.PI-P}_bisectVectorsPerpendicular(t,i){const e=h(t,i)<0?t:o(g(),t),s=Math.abs(h(e,i));if(!(s<T||s>1-T))return this._bisectDirection(e,i);const n=a(g(),e,[0,0,1]);return _(n,n)}_bisectDirection(t,i){const e=c(g(),t,i);return _(e,e)}_initializePlane(){const t=this._computeNormalDirection(this._left),i=this._computeNormalDirection(this._right);h(t,i)<0&&o(i,i),m(this._left.start,this._bisectDirection(t,i),this._plane)}_computeNormalDirection(t){const i=a(g(),t.direction,this._edgeDirection);_(i,i);const e=a(g(),this._edgeDirection,i);return this._planeType===y.XY&&(e[2]=0),_(e,e)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(D(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint(D(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))}_updateIntersectDistanceConstraint(t){const r=b(t),h=this._edgeDirection,o=c(g(),this._left.start,this._left.direction),a=c(g(),this._right.start,this._right.direction),_=this._pointInBasis2D(n(),r,h,this._left.start),p=this._pointInBasis2D(n(),r,h,o),d=this._pointInBasis2D(n(),r,h,this._right.start),u=this._pointInBasis2D(n(),r,h,a),[f]=X({start:p,end:_,type:Y.LINE},{start:u,end:d,type:Y.LINE});if(!f)return;const m=i(n(),_,p);e(m,m);const E=i(n(),f,p),x=s(m,E),I=c(g(),o,l(g(),this._left.direction,-x)),V=D(t,I);this._updateDistanceConstraint(V)}_pointInBasis2D(t,i,e,s){return t[0]=M(i,s),t[1]=M(e,s),t}_offset(t,i){Number.isFinite(this._minDistance)&&(i=Math.max(this._minDistance,i)),Number.isFinite(this._maxDistance)&&(i=Math.min(this._maxDistance,i)),E(this._offsetPlane,this._plane),this._offsetPlane[3]-=i;const e=(t,i,e)=>null!=i&&I(this._offsetPlane,t,c(g(),t,i),e),s=g();(t===this._edge.leftVertex?e(this._left.start,this._left.direction,s):e(this._right.start,this._right.direction,s))&&this._helper.copy(this._helper.fromXYZ(s,void 0,this._helper.getM(t.pos)),t.pos)}selectArrowFromStartPoint(t){this._selectedArrow=x(this.plane,this._pointToXYZ(t))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(t){return D(this.plane,this._pointToXYZ(t))}apply(t){this._offset(t,this.distance)}undo(t){this._offset(t,0)}canAccumulate(t){return t instanceof N&&this._edge.leftVertex.index===t._edge.leftVertex.index&&this._edge.rightVertex.index===t._edge.rightVertex.index&&this._edge.component===t._edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&p(b(this._plane),b(t._plane))}accumulate(t,i){const e=this._plane[3]-i._plane[3]+i.distance;this._offset(t,e)}accumulateParams(t){const i=t.distance-t._plane[3];this.distance=i+this._plane[3]}clone(){const t=new N(this._helper,this._planeType,this._edge,this.distance,Z.DEFERRED);return E(t._plane,this._plane),E(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=d(g(),this._edgeDirection),t}_maybeEqualsVec3(t,i){return null==t&&null==i||null!=t&&null!=i&&p(t,i)}_cloneNeighbor({start:t,end:i,direction:e,isOriginalDirection:s}){return{start:d(g(),t),end:null!=i?d(g(),i):null,direction:d(g(),e),isOriginalDirection:s}}}const P=t(15),T=.001;var y,Z;!function(t){t[t.XYZ=0]="XYZ",t[t.XY=1]="XY"}(y||(y={})),function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(Z||(Z={}));export{N as OffsetEdgeVertex,y as PlaneType};
