/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{isArrayLike as e}from"../../../../../core/arrayUtils.js";import{WGLDrawPhase as t,WGLGeometryType as r,WGLSymbologyType as s}from"../enums.js";import{CompareFunction as n}from"../../../../webgl/enums.js";class o{constructor(e,r){this.brushes=e,this.name=r.name,this.drawPhase=r.drawPhase||t.MAP,this._targetFn=r.target,this.effects=r.effects||[],this.enableDefaultDraw=r.enableDefaultDraw??(()=>!0),this.forceDrawByDisplayOrder=!!r.forceDrawByDisplayOrder}render(e){const{context:t,profiler:r}=e,s=this._targetFn(),n=this.drawPhase&e.drawPhase;if(r.recordPassStart(this.name),n){this.enableDefaultDraw()&&this._doRender(e,s),r.recordPassEnd();for(const r of this.effects){if(!r.enable())continue;const n=r.apply,o=r.args?.(),a=t.getViewport(),i=t.getBoundFramebufferObject(),f=e.passOptions;this._bindEffect(e,n,o),this._doRender(e,s,n.defines),this._drawAndUnbindEffect(e,n,a,i,f,o)}}}_doRender(e,t,o){if(null==t)return;const{profiler:a,context:i}=e;if(this.forceDrawByDisplayOrder){for(const r of this.brushes){if(a.recordBrushStart(r.name),null!=r.brushEffect){const s=i.getViewport(),n=i.getBoundFramebufferObject(),a=e.passOptions;this._bindEffect(e,r.brushEffect),this._drawWithBrush(r,e,t,o),this._drawAndUnbindEffect(e,r.brushEffect,s,n,a)}else this._drawWithBrush(r,e,t,o);a.recordBrushEnd()}const f=t,c=e;c.attributeView.bindTextures(e.context);for(const e of f){if(!e.visible)continue;e.commit(c),c.context.setStencilFunction(n.EQUAL,e.stencilRef,255);const t=e.getGeometry(r.MARKER),a=e.getGeometry(r.TEXT);if(t?.records&&a?.records){const n=new Map,i=t.records.getCursor();for(;i.next();)n.set(i.id,[i.getDrawInfo(t,r.MARKER)]);const f=a.records.getCursor();for(;f.next();){const e=n.get(f.id),t=f.getDrawInfo(a,r.TEXT);e?e.push(t):n.set(f.id,[t])}const d=Array.from(n.entries()).sort((([e,t],[r,s])=>r-e));for(const[t,r]of d)for(const n of r){const t=c.painter.getBrush(n.geometryType,s.DEFAULT);t.prepareState(c,o),t.drawGeometry(c,e,n,o)}}else if(t){const n=c.painter.getBrush(r.MARKER,s.DEFAULT);n.prepareState(c,o),t.forEachCommand((t=>{n.drawGeometry(c,e,t,o)}))}else if(a){const t=c.painter.getBrush(r.TEXT,s.DEFAULT);t.prepareState(c,o),a.forEachCommand((r=>{t.drawGeometry(c,e,r,o)}))}}}else for(const r of this.brushes){if(a.recordBrushStart(r.name),null!=r.brushEffect){const s=i.getViewport(),n=i.getBoundFramebufferObject(),a=e.passOptions;this._bindEffect(e,r.brushEffect),this._drawWithBrush(r,e,t,o),this._drawAndUnbindEffect(e,r.brushEffect,s,n,a)}else this._drawWithBrush(r,e,t,o);a.recordBrushEnd()}}_drawWithBrush(t,r,s,n){e(s)?(t.prepareState(r,n),t.drawMany(r,s,n)):s.visible&&(t.prepareState(r,n),t.draw(r,s,n))}_bindEffect(e,t,r){const{profiler:s}=e;s.recordPassStart(this.name+"."+t.name),t.bind(e,r);const n=t.createOptions(e,r);e.passOptions=n}_drawAndUnbindEffect(e,t,r,s,n,o){const{profiler:a,context:i}=e;e.passOptions=n,a.recordBrushStart(t.name),t.draw(e,o),t.unbind(e,o),i.bindFramebuffer(s);const{x:f,y:c,width:d,height:h}=r;i.setViewport(f,c,d,h),a.recordBrushEnd(),a.recordPassEnd()}}export{o as default};
