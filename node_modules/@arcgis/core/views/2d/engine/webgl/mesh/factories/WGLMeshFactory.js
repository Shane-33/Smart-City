/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import"../../../../../../core/has.js";import{isAborted as e}from"../../../../../../core/promiseUtils.js";import{loadLibtess as t}from"../../../../../../geometry/libtess.js";import{isAggregateId as r}from"../../DisplayId.js";import l from"../templates/WGLLabelTemplate.js";import s from"../templates/WGLMarkerTemplate.js";import{isDynamicId as i}from"../templates/WGLTemplateStore.js";class a{constructor(e,t,r){this._geometryType=e,this._idField=t,this._templateStore=r}update(e,t){null!=e.mesh.labels&&(this._labelTemplates=this._createLabelTemplates(e.mesh.labels,t)),this._schema=e}_createLabelTemplates(e,t){const r=new Map;if("simple"===e.type){for(const s of e.classes){const e=l.fromLabelClass(s,t);r.set(s.index,e)}return r}for(const s in e.classes){const i=e.classes[s];for(const e of i){const s=l.fromLabelClass(e,t);r.set(e.index,s)}}return r}get templates(){return this._templateStore}async analyze(l,s,a,o,n,p,m){if(e(m))return;let f;"dictionary"===a?.type&&(f=await a.analyze(this._idField,l.copy(),s,n,p,m));let u=0;for(;l.next();){let e=null;if(e=f?f[u++]:null!=o&&r(l.getDisplayId())&&1!==l.readAttribute("cluster_count")?o.match(this._idField,l,this._geometryType,n,p):a.match(this._idField,l,this._geometryType,n,p),l.setGroupId(e),i(e)){const t=this._templateStore.getDynamicTemplateGroup(e).templates;for(const e of t)e&&e.analyze&&e.analyze(this._templateStore,l,n,p)}}return await t(),this._templateStore.finalize(m)}async analyzeGraphics(r,l,s,a,o,n){if(e(n))return;const p=r.getCursor();for(s&&await s.analyze(this._idField,p.copy(),l,a,o,n);p.next();){let e=p.getGroupId();if(null!=e&&-1!==e||(e=s?.match(this._idField,p,p.geometryType,a,o),p.setGroupId(e)),i(e)){const t=this._templateStore.getDynamicTemplateGroup(e).templates;for(const e of t)e&&e.analyze&&e.analyze(this._templateStore,p,a,o)}p.setGroupId(e)}return await t(),this._templateStore.finalize(n)}writeGraphic(e,t,r,l){const s=t.getGroupId(),a=t.getDisplayId(),o=this._templateStore.getTemplateGroup(s);if(e.featureStart(t.insertAfter,0),null!=a){if(i(s))for(const e of o.templates)e&&e.bindFeature(t,null,null);if(o){for(const s of o.templates)s&&s.write(e,t,r,l);e.featureEnd()}}}writeCursor(e,t,r,l,s,a,o){const n=t.getGroupId(),p=t.getDisplayId(),m=this._templateStore.getTemplateGroup(n),f=m.templates,u=this._getSortKeyValue(t,m);if(e.featureStart(0,u),null==p)return;if(!f)return;if(i(n))for(const i of f)i.bindFeature(t,r,l);for(const i of f)i.write(e,t,s,o);if(!!f.length&&null!=a){const r=a&&this._findLabelRef(f);this._writeLabels(e,t,a,r,s,o)}e.featureEnd()}_getSortKeyValue(e,t){const r=this._schema.mesh.sortKey;if(null==r)return 0;let l=0;return l=!0===r.byRenderer&&null!=t.sortKey?t.sortKey:null!=r.fieldIndex?e.getComputedNumericAtIndex(r.fieldIndex):null!=r.field?e.readAttribute(r.field):e.readAttribute(this._idField),l*="asc"===r.order?1:-1,null==l||isNaN(l)?0:l}_findLabelRef(e){for(const t of e)if(t instanceof s)return t;return null}_writeLabels(e,t,r,l,s,i){for(const a of r)if(null!=a&&a){const{glyphs:r,rtl:o,index:n}=a,p=this._labelTemplates.get(n);if(!p)continue;p.setZoomLevel(s),p.bindReferenceTemplate(l),p.bindTextInfo(r,o),p.write(e,t,null,i)}}}export{a as WGLMeshFactory};
