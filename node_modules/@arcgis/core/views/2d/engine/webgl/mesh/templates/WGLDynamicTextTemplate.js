/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{pt2px as t}from"../../../../../../core/screenUtils.js";import{Alignment as e}from"../../../../../../symbols/cim/enums.js";import{isFeatureValueFn as i}from"../../../../../../symbols/cim/utils.js";import{getXAnchorDirection as s,getYAnchorDirection as o}from"../../alignmentUtils.js";import{premultiplyAlphaRGBA as r}from"../../color.js";import{glyphSize as n,minMaxZoomPrecisionFactor as a}from"../../definitions.js";import{i1616to32 as l}from"../../number.js";import{TextMaterialKey as h}from"../../materialKey/MaterialKey.js";import{getMinMaxZoom as c}from"./util.js";import m from"./WGLBaseTextTemplate.js";import _ from"./WGLDynamicMeshTemplate.js";import{codepoints as f}from"../../../../layers/features/textUtils.js";const y=5;function p(t,e,i,s){return"string"==typeof t.text?t.text:"function"==typeof t.text?t.text(e,i,s)??"":""}class d extends(m(_)){constructor(s,o,n){super(s),this._horizontalAlignment="center",this._verticalAlignment="middle",this._textToGlyphs=new Map,this._minMaxZoom=l(Math.round(o*a),Math.round(n*a));const c=s.scaleFactor||1;this._cimTextLayer=s;const m=s.color;if(i(m)){const t=(t,e,i)=>r(m(t,e,i));this._dynamicPropertyMap.set("_color",t)}else this._color=r(m);const _=s.outlineColor;if(i(_)){const t=(t,e,i)=>r(_(t,e,i));this._dynamicPropertyMap.set("_haloColor",t)}else this._haloColor=r(_);let f;i(s.size)||(f=Math.min(Math.round(t(s.size*s.sizeRatio)),127));const p=(e,o,r)=>i(s.size)?Math.min(Math.round(t(s.size(e,o,r)*s.sizeRatio)),127):f;if(this._dynamicPropertyMap.set("_size",p),i(s.outlineSize)){const e=(e,i,o)=>Math.min(Math.floor(y*t(s.outlineSize(e,i,o)*s.sizeRatio)),127);this._dynamicPropertyMap.set("_haloSize",e)}else this._haloSize=Math.min(Math.floor(y*t(s.outlineSize*s.sizeRatio)),127);let d;i(s.offsetX)||(d=Math.round(t(s.offsetX*s.sizeRatio)));const M=(e,o,r)=>i(s.offsetX)?Math.round(t(s.offsetX(e,o,r)*s.sizeRatio)):d;let u;this._dynamicPropertyMap.set("_xOffset",M),i(s.offsetY)||(u=Math.round(t(s.offsetY*s.sizeRatio)));const g=(e,o,r)=>i(s.offsetY)?Math.round(t(s.offsetY(e,o,r)*s.sizeRatio)):u;if(this._dynamicPropertyMap.set("_yOffset",g),i(s.angle)?this._dynamicPropertyMap.set("_angle",s.angle):this._angle=s.angle,i(s.horizontalAlignment)?this._dynamicPropertyMap.set("_horizontalAlignment",s.horizontalAlignment):this._horizontalAlignment=s.horizontalAlignment,i(s.verticalAlignment)?this._dynamicPropertyMap.set("_verticalAlignment",s.verticalAlignment):this._verticalAlignment=s.verticalAlignment,null!=s.effects){const t=s.effects;i(t)?this._dynamicPropertyMap.set("_effects",t):this._effects=t}if(null!=s.markerPlacement){const t=s.markerPlacement;i(t)?this._dynamicPropertyMap.set("_markerPlacement",t):this._textPlacement=t}i(s.text)?this._dynamicPropertyMap.set("_text",s.text):this._text=s.text,this._backgroundColor=s.backgroundColor&&r(s.backgroundColor),this._borderLineColor=s.borderLineColor&&r(s.borderLineColor),this._borderLineSize=s.borderLineWidth,this._scaleFactor=c;const z=Math.min(Math.round(t(s.referenceSize*s.sizeRatio)),127);this._referenceSize=Math.round(Math.sqrt(256*z)),this._materialKey=s.materialKey;const x=h.load(this._materialKey);x.sdf=!0,this._bitset=(s.alignment===e.MAP?1:0)|(s.colorLocked?1:0)<<1,this._materialKey=x.data,this._decoration="none",this._lineHeight=1,this._lineWidth=512,this._isCIM=!0}static fromCIMText(t,e){const[i,s]=c(t.scaleInfo,e);return new d(t,i,s)}async analyze(t,e,i,s){const o=e.readLegacyFeature(),r=p(this._cimTextLayer,o,i,s),n=await super.analyze(t,e,i,s,f(r));return n?.glyphMosaicItems&&this._textToGlyphs.set(r,n.glyphMosaicItems),n}bindFeature(t,e,i){const r=t.readLegacyFeature();if(this._dynamicPropertyMap.forEach(((t,s)=>{this[s]=t(r,e,i)})),!this._text||0===this._text.length)return void(this._shapingInfo=null);this._size*=this._scaleFactor,this._scale=this._size/n,this._xOffset*=this._scaleFactor,this._yOffset*=this._scaleFactor,this._xAlignD=s(this._horizontalAlignment??"center"),this._yAlignD=o(this._verticalAlignment??"baseline");const a=this._textToGlyphs.get(this._text)??[];this.bindTextInfo(a,!1)}}export{d as default};
