/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import t from"../../../../config.js";import e from"../../../../request.js";import{bidiText as i}from"../../../../core/BidiText.js";import s from"../../../../core/Error.js";import{getFullyQualifiedFontName as r}from"../../../../core/fontUtils.js";import has from"../../../../core/has.js";import o from"../../../../core/Logger.js";import{nextPowerOfTwo as n}from"../../../../core/mathUtils.js";import{throwIfAborted as a,isAbortError as h}from"../../../../core/promiseUtils.js";import{pt2px as c}from"../../../../core/screenUtils.js";import{isSVG as u}from"../../../../core/urlUtils.js";import{s as d}from"../../../../chunks/vec2.js";import{c as l}from"../../../../chunks/vec2f32.js";import m from"../../../../symbols/cim/Rasterizer.js";import{sdfTextureSize as g,textureBindingGlyphAtlas as p,textureBindingSpriteAtlas as f,spritePadding as _,patternFillRasterizationScale as w}from"./definitions.js";import{MosaicType as y}from"./enums.js";import M from"./GlyphMosaic.js";import I from"./GlyphSource.js";import z from"./SDFConverter.js";import T from"./SpriteMosaic.js";import{is3D as R,charCodes as v,isSimple as j,isSVGResource as x,isImageResource as S,isMarkerPlacementInsidePolygon as b,shouldRepeat as P,getUrl as U,getPMSResourceSize as B,isGIF as G,isPNG as C}from"./Utils.js";import{AnimatableTextureResource as A}from"./animatedFormats/AnimatableTextureResource.js";import{resize as q}from"./animatedFormats/utils.js";import{ok as F}from"./util/Result.js";import{keyFromSymbol as E}from"./util/symbolUtils.js";import{QueueProcessor as L}from"../../../support/QueueProcessor.js";import{TextureSamplingMode as N}from"../../../webgl/enums.js";const $=l(),k="arial-unicode-ms-regular",H=o.getLogger("esri.views.2d.engine.webgl.TextureManager");function O(t){const e=Math.round(c(t)*window.devicePixelRatio);return e*(e>=128?2:4)}function Q(t,e){return Math.min(t,O(e))}function V(t,e){if(!t||!e)return{width:0,height:0};const i=t/e;if(i>1){const e=O(t);return{width:e,height:e/i}}const s=O(e);return{width:s*i,height:s}}const Y=(t,e,i)=>H.error(new s(t,e,i));class D{static fromMosaic(t,e){return new D(t,e.page,e.sdf)}constructor(t,e,i){this.mosaicType=t,this.page=e,this.sdf=i}}class J{constructor(i,r,o){this._requestRender=i,this.resourceManager=r,this._allowNonPowerOfTwo=o,this._invalidFontsMap=new Map,this._sdfConverter=new z(g),this._bindingInfos=new Array,this._hashToBindingIndex=new Map,this._ongoingRasterizations=new Map,this._imageRequestQueue=new L({concurrency:10,process:async(t,i)=>{a(i);try{return await e(t,{responseType:"image",signal:i})}catch(r){if(!h(r))throw new s("mapview-invalid-resource",`Could not fetch requested resource at ${t}`,r);throw r}}}),this._spriteMosaic=new T(2048,2048,500),this._glyphSource=new I(`${t.fontsUrl}/{fontstack}/{range}.pbf`),this._glyphMosaic=new M(1024,1024,this._glyphSource),this._rasterizer=new m(r)}dispose(){this._spriteMosaic.dispose(),this._glyphMosaic.dispose(),this._rasterizer.dispose(),this._sdfConverter.dispose(),this._spriteMosaic=null,this._glyphMosaic=null,this._sdfConverter=null,this._hashToBindingIndex.clear(),this._hashToBindingIndex=null,this._bindingInfos=null,this._ongoingRasterizations.clear(),this._ongoingRasterizations=null,this._imageRequestQueue.clear(),this._imageRequestQueue=null}get sprites(){return this._spriteMosaic}get glyphs(){return this._glyphMosaic}async rasterizeItem(t,e,i,s){if(null==t)return Y("mapview-null-resource","Unable to rasterize null resource"),null;switch(t.type){case"text":case"esriTS":{const e=await this._rasterizeText(t,i,s);return e.forEach((t=>this._setTextureBinding(y.GLYPH,t))),{glyphMosaicItems:e}}default:{if(R(t))return Y("mapview-invalid-type",`MapView does not support symbol type: ${t.type}`,t),null;const i=await this._rasterizeSpriteSymbol(t,e,s);return F(i)&&i&&this._setTextureBinding(y.SPRITE,i),{spriteMosaicItem:i}}}}bindTextures(t,e,i,s=!1){if(0===i.textureBinding)return;const r=this._bindingInfos[i.textureBinding-1],o=r.page,n=s?N.LINEAR_MIPMAP_LINEAR:N.LINEAR;switch(r.mosaicType){case y.SPRITE:{const i=this.sprites.getWidth(o),s=this.sprites.getHeight(o),r=d($,i,s);return this._spriteMosaic.bind(t,n,o,f),e.setUniform1i("u_texture",f),void e.setUniform2fv("u_mosaicSize",r)}case y.GLYPH:{const i=this.glyphs.width,s=this.glyphs.height,r=d($,i,s);return this._glyphMosaic.bind(t,n,o,p),e.setUniform1i("u_texture",p),void e.setUniform2fv("u_mosaicSize",r)}default:H.error("mapview-texture-manager",`Cannot handle unknown type ${r.mosaicType}`)}}_hashMosaic(t,e){return 1|t<<1|(e.sdf?1:0)<<2|e.page<<3}_setTextureBinding(t,e){const i=this._hashMosaic(t,e);if(!this._hashToBindingIndex.has(i)){const s=D.fromMosaic(t,e),r=this._bindingInfos.length+1;this._hashToBindingIndex.set(i,r),this._bindingInfos.push(s)}e.textureBinding=this._hashToBindingIndex.get(i)}async _rasterizeText(t,e,s){let o,n;if("cim"in t){const e=t;o=e.fontName,n=e.text}else{const e=t;o=r(e.font),n=e.text}const a=this._invalidFontsMap.has(o),h=e||v(i(n)[0]);try{const t=a?k:o;return has("esri-2d-stabilize-glyphs")&&await this._glyphMosaic.preloadASCIIGlyphCache(t),await this._glyphMosaic.getGlyphItems(t,h,s)}catch(c){return Y("mapview-invalid-resource",`Couldn't find font ${o}. Falling back to Arial Unicode MS Regular`),this._invalidFontsMap.set(o,!0),this._glyphMosaic.getGlyphItems(k,h,s)}}async _rasterizeSpriteSymbol(t,e,i){if(j(t))return;const r=E(t);if(this._spriteMosaic.has(r))return this._spriteMosaic.getSpriteItem(r);if(x(t)||S(t)&&!b(t))return this._handleAsyncResource(r,t,i);const o=w,n=this._rasterizer.rasterizeJSONResource(t,o);if(n){const{size:e,image:i,sdf:s,simplePattern:o,rasterizationScale:a}=n;return this._addItemToMosaic(r,e,{type:"static",data:i},P(t),s,o,a)}return new s("TextureManager","unrecognized or null rasterized image")}async _handleAsyncResource(t,e,i){if(this._ongoingRasterizations.has(t))return this._ongoingRasterizations.get(t);let s;s=x(e)?this._handleSVG(e,t,i):this._handleImage(e,t,i),this._ongoingRasterizations.set(t,s);try{await s,this._ongoingRasterizations.delete(t)}catch{this._ongoingRasterizations.delete(t)}return s}async _handleSVG(t,e,i){const s=[g,g],r=!("cim"in t)||t.cim.asFill,o=await this._sdfConverter.draw(t.path,r,i);return this._addItemToMosaic(e,s,{type:"static",data:new Uint32Array(o.buffer)},!1,!0,!0)}async _handleGIFOrPNG(t,e,i){const r=U(t);await this.resourceManager.fetchResource(r,i);let o=this.resourceManager.getResource(r);if(null==o)return new s("mapview-invalid-resource",`Could not fetch requested resource at ${r}.`);let a=o.width,h=o.height;if(o instanceof HTMLImageElement){"esriPMS"===t.type&&(a=Math.round(Q(o.width,B(t))),h=Math.round(o.height*(a/o.width)));const i="cim"in t?t.cim.colorSubstitutions:void 0,{size:s,sdf:r,image:n}=this._rasterizer.rasterizeImageResource(a,h,o,i);return this._addItemToMosaic(e,s,{type:"static",data:n},P(t),r,!1)}this._allowNonPowerOfTwo||(a=n(o.width+2*_)-2*_,h=n(o.height+2*_)-2*_),a===o.width&&h===o.height||(o=q(o,a,h));const c=t.animatedSymbolProperties||{},u=t.objectId,d=new A(o,this._requestRender,c,u);return this._addItemToMosaic(e,[d.width,d.height],{type:"animated",data:d},P(t),!1,!1)}async _handleImage(t,e,i){if(G(t)||C(t))return this._handleGIFOrPNG(t,e,i);const r=U(t);try{let s;const o=this.resourceManager.getResource(r);if(null!=o&&o instanceof HTMLImageElement)s=o;else{const{data:t}=await this._imageRequestQueue.push(r,{...i});s=t}if(u(r))if("width"in t&&"height"in t){const{width:e,height:i}=V(t.width,t.height);s.width=e,s.height=i}else if("cim"in t){const e=t.cim,{width:i,height:r}=V(e.width??e.scaleX*e.size,e.size);s.width=i,s.height=r}if(!s.width||!s.height)return null;let n=s.width,a=s.height;"esriPMS"===t.type&&(n=Math.round(Q(s.width,B(t))),a=Math.round(s.height*(n/s.width)));const h="cim"in t?t.cim.colorSubstitutions:void 0,{size:c,sdf:d,image:l}=this._rasterizer.rasterizeImageResource(n,a,s,h);return this._addItemToMosaic(e,c,{type:"static",data:l},P(t),d,!1)}catch(Y){if(!h(Y))return new s("mapview-invalid-resource",`Could not fetch requested resource at ${r}. ${Y.message}`)}}_addItemToMosaic(t,e,i,s,r,o,n){return this._spriteMosaic.addSpriteItem(t,e,i,s,r,o,n)}}export{J as default};
