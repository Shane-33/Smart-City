/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{eachAlways as r}from"../../../core/promiseUtils.js";import t from"../../../layers/FeatureLayer.js";import{applyTextFormattingHTML as a,htmlEntities as i}from"./featureUtils.js";const n=["$datastore","$map","$layer","$aggregatedfeatures"],s="esri.widgets.Feature.support.arcadeFeatureUtils",o=e.getLogger(s);function c(e){return"string"==typeof e?a(i(e)):Array.isArray(e)?p(e):"esri.arcade.Dictionary"===e?.declaredClass?l(e):e}function p(e){return`<ul class="esri-widget__list">${e.map((e=>`<li>${"string"==typeof e?a(i(e)):e}</li>`)).join("")}</ul>`}function l(e){return`<table class="esri-widget__table">${e.keys().map((r=>{const t=e.field(r);return`<tr><th>${r}</th><td>${"string"==typeof t?a(i(t)):t}</td></tr>`})).join("")}</table>`}function u({aggregatedFeatures:e,arcadeUtils:r,featureSetVars:a,context:i,viewInfo:n,map:s,graphic:o,interceptor:c}){a.forEach((a=>{const p=a.toLowerCase(),l=n.sr,u={map:s,spatialReference:l,interceptor:c};if("$map"===p&&(i.vars[p]=r.convertMapToFeatureSetCollection(u)),"$layer"===p&&(i.vars[p]=r.convertFeatureLayerToFeatureSet({layer:o.sourceLayer,spatialReference:l,interceptor:c})),"$datastore"===p&&(i.vars[p]=r.convertServiceUrlToWorkspace({url:o.sourceLayer.url,spatialReference:l,interceptor:c})),"$aggregatedfeatures"===p){const a=o.layer,{fields:n,objectIdField:s,geometryType:l,spatialReference:u,displayField:f}=a,g=new t({fields:n,objectIdField:s,geometryType:l,spatialReference:u,displayField:f,..."feature"===a.type?{templates:a.templates,typeIdField:a.typeIdField,types:a.types}:null,source:e});i.vars[p]=r.convertFeatureLayerToFeatureSet({layer:g,spatialReference:u,interceptor:c})}}))}function f(){return import("../../../support/arcadeUtils.js")}function g(e){return"createQuery"in e&&"queryFeatures"in e}async function y({graphic:e,view:r}){const{isAggregate:t,layer:a}=e;if(!t||!a||"2d"!==r?.type)return[];const i=await r.whenLayerView(a);if(!g(i))return[];const n=i.createQuery(),s=e.getObjectId();n.aggregateIds=null!=s?[s]:[];const{features:o}=await i.queryFeatures(n);return o}async function d({expressionInfo:e,arcadeUtils:r,interceptor:t,spatialReference:a,map:i,graphic:s,view:c}){if(!e?.expression)return null;const p=r.createSyntaxTree(e.expression),l=n.filter((e=>r.hasVariable(p,e))),[f]=await Promise.all([y({graphic:s,view:c}),r.loadScriptDependencies(p,!0,l)]),g=r.getViewInfo({spatialReference:a}),d=r.createExecContext(s,g,c?.timeZone);d.interceptor=t,d.useAsync=!0,u({aggregatedFeatures:f,arcadeUtils:r,featureSetVars:l,context:d,viewInfo:g,map:i,graphic:s,interceptor:t});const m=r.createFunction(p,d);return r.executeAsyncFunction(m,d).catch((r=>o.error("arcade-execution-error",{error:r,graphic:s,expressionInfo:e})))}async function m({expressionInfos:e,spatialReference:t,graphic:a,interceptor:i,map:n,view:s}){if(!e?.length)return{};const o=await f(),p={};for(const r of e)p[`expression/${r.name}`]=d({expressionInfo:r,arcadeUtils:o,interceptor:i,spatialReference:t,map:n,graphic:a,view:s});const l=await r(p),u={};for(const r in l)u[r]=c(l[r].value);return u}export{d as createCompiledExpression,m as createCompiledExpressions,f as loadArcadeUtils};
