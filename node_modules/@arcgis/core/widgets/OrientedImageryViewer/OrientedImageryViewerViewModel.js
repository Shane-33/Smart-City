/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../geometry.js";import t from"../../Graphic.js";import{isSome as r}from"../../core/arrayUtils.js";import i from"../../core/Collection.js";import{deprecatedProperty as o}from"../../core/deprecate.js";import s from"../../core/Evented.js";import{isSerializable as a}from"../../core/JSONSupport.js";import n from"../../core/Logger.js";import{clamp as l}from"../../core/mathUtils.js";import{destroyMaybe as h}from"../../core/maybe.js";import{watch as c,once as g,initial as u}from"../../core/reactiveUtils.js";import{createScreenPoint as m}from"../../core/screenUtils.js";import{property as d}from"../../core/accessorSupport/decorators/property.js";import{ensureType as p}from"../../core/accessorSupport/ensureType.js";import"../../core/has.js";import{subclass as y}from"../../core/accessorSupport/decorators/subclass.js";import _ from"../../geometry/Extent.js";import{geographicToWebMercator as v}from"../../geometry/support/webMercatorUtils.js";import f from"../../layers/GraphicsLayer.js";import P from"../../layers/ImageryTileLayer.js";import{searchImages as C}from"../../layers/orientedImagery/queries.js";import{calculateSuitabilities as I}from"../../layers/orientedImagery/core/bestImageUtils.js";import{createCoveragePolygon as b,computePolygonForInspection as w,resizePolygon as F,checkIfPolygonContainsSelectedPoint as M}from"../../layers/orientedImagery/core/coverageUtils.js";import{updateElevation as S,transformPoints as x}from"../../layers/orientedImagery/transformations/groundToImageUtils.js";import{transformPoints as V}from"../../layers/orientedImagery/transformations/imageToGroundUtils.js";import j from"../../layers/support/RasterFunction.js";import{convolutionKernel as O}from"../../layers/support/rasterFunctionConstants.js";import A from"../../layers/support/rasterDatasets/RasterFactory.js";import G from"../../rest/support/AttachmentQuery.js";import D from"../../views/MapView.js";import{getResolutionToScaleFactor as R}from"../../views/2d/viewpointUtils.js";import{ViewEventPriorities as L}from"../../views/input/InputManager.js";import{projectWithEngineOrService as E}from"../../views/support/projectionUtils.js";import{sectorsInOrder as T,sectorsRadii as U}from"./constants.js";import{activePolygonSymbol as k,polygonSymbol as N,activeSourcePointSymbol as H,sourcePointSymbol as J,crossSymbol as z,diamondSymbol as B}from"./symbols.js";import{isTifOrMrf as $,isSceneView as q,isGraphic as W}from"./utils.js";import Z from"../../geometry/Polygon.js";import Q from"../../geometry/SpatialReference.js";import K from"../../geometry/Point.js";const X={click:"view-click",imageClick:"image-click"},Y=e=>/^https?:/i.test(e),ee=e=>"FA"===e;let te=class extends s.EventedAccessor{constructor(e){super(e),this.layer=null,this.shouldShowSelectedImage=!1,this.coverageFrustums=new i,this.coveragePolygons=new i,this.currentCoverageVisible=!0,this.disabled=!1,this.displayMessage=null,this.pointSources=new i,this.previousFeatureAngle=0,this.selectedFeature=null,this.selectedFeatureAngle=0,this.selectedPoint=null,this.features=new i,this.isAdditionalCoverageVisible=!1,this.isAdditionalPointSourcesVisible=!1,this.localPort=null,this.mapImageConversionToolState=!1,this.navigatorSelectedFeature=null,this._additionalCoveragePolygons=new i,this._additionalFeatureGraphics=new i,this._currentCoveragePolygon=null,this._currentImage=null,this._fetchFeaturesController=null,this._imageViewer=null,this._initialCurrentCoveragePolygon=null,this._initialCurrentCoverageUpdate=!0,this._overlays=new f({listMode:"hide",internal:!0}),this._plotPolygons=!1,this._initialPreviousCoveragePolygon=null,this._referencePointOnGround=null,this._referencePointOnImage=null,this._sectorData=null,this._crossSymbol=null,this._panConstraint=null,this._scaleConstraint=null,this._suitabilities=null,this._transformController=new AbortController,this._updateCoverageController=null,this._imageClickHandler=async e=>{if(0===e.button&&this._currentImage&&this._currentImage?.fullExtent){const{xmin:t,xmax:r,ymin:i,ymax:o}=this._currentImage.fullExtent,{x:s,y:a}=e.mapPoint;if(t>s||r<s||o<a||i>a)return;this.plotReferencePointOnImage(e.mapPoint);const n=this.getSelectedFeature();if(n){const t=(await V([e.mapPoint.toJSON()],{feature:n,currentCoveragePolygon:this.getSelectedFeaturePolygon(),imageProperties:this._currentImage.rasterInfo,options:{signal:this._transformController?.signal}}))[0];t&&this.plotReferencePointOnGround(t)}}},this._viewClickHandler=e=>{"mouse"===e.pointerType&&0!==e.button||(e.stopPropagation(),e.preventDefault(),this.loadBestImage(e.mapPoint))},this._mapImageConversionToolViewClickHandler=e=>{e.stopPropagation(),e.preventDefault(),this.plotMapPoint(e.mapPoint)},this.handleSectorClick=this.handleSectorClick.bind(this),this.loadViewer=this.loadViewer.bind(this),this.searchBestImage=this.searchBestImage.bind(this),this.transformAndPlotReferencePointOnImage=this.transformAndPlotReferencePointOnImage.bind(this)}initialize(){this.addHandles([c((()=>this.view?.map),((e,t)=>{t?.layers.remove(this._overlays),e?.layers.add(this._overlays)}),u),c((()=>this.view?.map?.allLayers?.length),(e=>{e&&this.view?.map?.layers.reorder(this._overlays,e-1)}),u),c((()=>this.layer?.visible??!1),(e=>{this._overlays.visible=e}),u),c((()=>[this.state,this.mapImageConversionToolState]),(()=>{if(this.removeHandles(X.click),"disabled"===this.state||null==this.view)return;const e=this.mapImageConversionToolState&&"image-loaded"===this.state?this._mapImageConversionToolViewClickHandler:this._viewClickHandler;this.addHandles(this.view.on("click",e,L.WIDGET),X.click)}),u),c((()=>this.mapImageConversionToolState),(()=>{this.removeHandles(X.imageClick),this.imageLoaded&&this.mapImageConversionToolState&&this.addHandles(this._imageViewer.on("click",this._imageClickHandler),X.imageClick)}))])}destroy(){this._cancelCurrentCoverageUpdate(),this._cancelFetchingFeatures(),this.coverageFrustums.destroy(),this.coveragePolygons.destroy(),this.pointSources.destroy(),this._additionalCoveragePolygons.destroy(),this._additionalFeatureGraphics.destroy(),this._currentImage=h(this._currentImage),this._imageViewer=h(this._imageViewer),this._initialCurrentCoveragePolygon=h(this._initialCurrentCoveragePolygon),this._currentCoveragePolygon=h(this._currentCoveragePolygon),this._crossSymbol=h(this._crossSymbol),this._referencePointOnGround=h(this._referencePointOnGround),this._referencePointOnImage=h(this._referencePointOnImage),this._overlays&&this.view?.map.remove(this._overlays),this._overlays.destroy()}get activeLayer(){return o(n.getLogger(this),"activeLayer",{replacement:"layer"}),this.layer}set activeLayer(e){o(n.getLogger(this),"activeLayer",{replacement:"layer"}),this.layer=e}get brightness(){return this._get("brightness")??0}set brightness(e){this._set("brightness",l(e,-10,10))}get contrast(){return this._get("contrast")??0}set contrast(e){this._set("contrast",l(e,-10,10))}get currentImageView(){return this._imageViewer?.allLayerViews.find((e=>e.layer===this._currentImage))}get featureCount(){return this.features?.length??0}get imageGalleryEnabled(){return $(this.selectedFeature?.attributes.imagePath.trim())}get imageLoaded(){return this._currentImage?.loaded??!1}get updating(){return"loading"===this._currentImage?.loadStatus||!!this._fetchFeaturesController}get referencePoint(){return this._referencePointOnGround?.geometry}get sharpness(){return this._get("sharpness")??0}set sharpness(e){this._set("sharpness",l(e,0,1))}get sectorData(){const{_sectorData:e}=this;if(e)return T.map((t=>e[t]))}get state(){const{layer:e,view:t,_currentImage:r}=this;return this.disabled||!e||t&&!t.ready?"disabled":r?.loadStatus?`image-${r.loadStatus}`:"ready"}get thumbnails(){const{features:e}=this;return e?new i(e.map((({attributes:{imagePath:e,objectId:t}})=>{const r=e.trim();return $(r)?{url:r,objectId:t}:null})).filter(r)):null}set view(e){this._set("view",e)}getCurrentCoveragePolygon(){return this._currentCoveragePolygon}getSelectedFeature(){return this.selectedFeature}getSelectedFeaturePolygon(){return this._initialCurrentCoveragePolygon}handleSectorClick(e){if(isNaN(e))return;const t=this._sectorData?.[T[e]];t?.length&&this._updateSelectedFeature(t.at(0))}handleFeatureClick(e){const{sector:t,featureIndexInSector:r}=e;if(isNaN(r))return;const i=this._sectorData?.[t];i?.length&&this._updateSelectedFeature(i.at(r))}async loadBestImage(e){this.displayMessage=null,this.selectedPoint=e.spatialReference.isGeographic?v(e):e.clone(),this.features.removeAll(),this._additionalCoveragePolygons.removeAll(),this._additionalFeatureGraphics.removeAll(),this._currentCoveragePolygon=h(this._currentCoveragePolygon),this._overlays?.removeAll(),this.selectedFeature=null,await this._fetchFeaturesWithController(e)}loadViewer(e){const t=new Map,r={wkid:0};this._imageViewer=new D({container:e,map:t,spatialReferance:r,constraints:{snapToZoom:!1,rotationEnabled:!1},ui:{components:["zoom"]}}),g((()=>!0===this._imageViewer?.stationary)).then((()=>{this.setMessage("onLoadMessage","info")})),this._imageViewer.addHandles([c((()=>[this._imageViewer?.viewpoint,this._initialCurrentCoveragePolygon]),((e,t)=>{e?.[1]!==t?.[1]&&(this._initialPreviousCoveragePolygon=this._plotPolygons?null:t?.[1]),this._imageViewer?.viewpoint&&this._initialCurrentCoveragePolygon&&(this._cancelCurrentCoverageUpdate(),this.updateCoverage())})),c((()=>this.selectedFeatureAngle),((e,t)=>{this.previousFeatureAngle=t??0}),u),c((()=>this.selectedFeature),(async()=>{const{selectedFeature:e,selectedPoint:t}=this;if(!e&&this._currentImage&&(this._imageViewer?.map.layers.remove(this._currentImage),this._currentImage=h(this._currentImage)),e&&t){this._initialCurrentCoverageUpdate=!0,this._updatePointsAndPolygons(),this._fetchFeaturesController??=new AbortController;const{signal:t}=this._fetchFeaturesController;await this.loadImage(e,{signal:t}).finally((()=>{this._fetchFeaturesController=null}))}}))])}async plotMapPoint(e){return this.plotReferencePoint(e),this.transformAndPlotReferencePointOnImage({feature:this.selectedFeature,selectedLocation:e,options:{signal:this._transformController?.signal}})}resetImage(){this._currentImage=h(this._currentImage),this.setMessage("onLoadMessage","info"),this._cancelCurrentCoverageUpdate(),this._cancelFetchingFeatures()}async searchBestImage(e,t){try{const r=await C(e,t);r&&await this._processFeatureResponse(r,{signal:t?.signal})}catch(r){const e=n.getLogger(this);this.setMessage("imageLoadError","error"),e.error("error occurred while finding best image",r)}}setAdditionalCameraLocationsVisibility(e){this._additionalFeatureGraphics.forEach((t=>{t.visible=e}))}setAdditionalCoverageVisibility(e){this._additionalCoveragePolygons.forEach((t=>{t.visible=e}))}setCurrentCoverageVisibility(e){this._currentCoveragePolygon&&(this._currentCoveragePolygon.visible=e),this._selectedFeatureGraphic&&(this._selectedFeatureGraphic.visible=e)}setMapImageConversionToolState(e){this.mapImageConversionToolState=e}_cancelFetchingFeatures(e){const t=this._fetchFeaturesController;t&&t.abort(e),this._fetchFeaturesController=null}_cancelCurrentCoverageUpdate(){const e=this._updateCoverageController;e&&e.abort("Multiple Coverage Updates: Aborting Current Coverage Update to sync image and coverage"),this._updateCoverageController=null}async _fetchFeatures(e,t){if(!this.view)return;const r=this.layer;if(r){const i={include:r},o=this.view.toScreen(e);if(!o)return;const s=await this.view.hitTest(o,i);this._processHitTestResults(r,s,t)}}async _fetchFeaturesWithController(e){this._cancelFetchingFeatures();const t=new AbortController,{signal:r}=t;this._fetchFeaturesController=t;try{await this._fetchFeatures(e,{signal:r}).finally((()=>{this._fetchFeaturesController=null}))}catch(i){const e=n.getLogger(this);this.setMessage("imageLoadError","error"),e.error("error occurred while fetching features",i)}}_groupFeaturesBySectors(){const{_suitabilities:e,features:t}=this;if(!e||!t)return void(this._sectorData=null);this._sectorData={};for(const a of T)this._sectorData[a]=new i;const r=e.map(((e,t)=>({...e,featureIndex:t})));r.sort(((e,t)=>e.trueSuitability-t.trueSuitability));const o=r.map((({distance:e})=>e)),s=Math.max(...o);r.forEach((e=>{const{distance:r,angle:i,featureIndex:o}=e;let a="FAR";const n=r/s*U[2];n<=U[0]?a="NEAR":n<=U[1]&&(a="");let l="NORTH";if(Math.abs(i)>=135?l="WEST":i<-45&&i>-135?l="SOUTH":i<=45&&(l="EAST"),!this._sectorData)return;const h=U[3]+n*Math.sin(i*Math.PI/180),c=U[3]+n*Math.cos(i*Math.PI/180);let g;const u=t.at(o),m=u===this.selectedFeature,d=this.selectedFeature?.attributes.cameraPitch&&this.selectedFeature?.attributes.cameraPitch<5;if(m&&d)g=-90;else{const e=h-U[3],t=c-U[3],r=t/Math.sqrt(e**2+t**2);let i=180*Math.acos(r)/Math.PI;(e<0&&t<0||e<0&&t>0)&&(i*=-1),g=i}const p=""===a?l:`${a}_${l}`;m&&(g===this.selectedFeatureAngle?this.previousFeatureAngle=g:this.selectedFeatureAngle=g,this.navigatorSelectedFeature=d?null:{x:h,y:c,direction:l});const y=this._sectorData[p];y.add({angle:i,featureIndex:o,x:h,y:c,objectID:u.attributes.objectId,sector:p,featureIndexInSector:y.length})}))}async _processFeatureResponse(e,t){const{selectedPoint:r}=this;if(!r)return;if(!e)return;const i=e;if(!i)return;const{features:o}=i;if(!o.length)return this.setMessage("noImageError","error"),void(this.selectedFeature=null);const s=new Array;this.coveragePolygons.removeAll(),this.coverageFrustums.removeAll(),this.pointSources.removeAll(),o.forEach((e=>{let t;const{polygon:i,frustum:o}=b(e);if(t=i,e.attributes.isInspection&&(t=w(e.attributes)),e.layer.coveragePercent&&(t=F(t,e.layer.coveragePercent)),M(t,r)){s.push(e);const r=t.toJSON(),i=o?.toJSON(),{attributes:n}=e,{cameraHeight:l,cameraHeading:h,location:c,objectId:g}=n,u=a(c)?c.toJSON():c;r.imageID=u.imageID=g,i&&(i.imageID=g),u.z=l,this.pointSources?.push(u),this.coveragePolygons?.push(h>0?r:void 0),this.coverageFrustums?.push(h>0?i:void 0)}}));const n=this.coveragePolygons?.getItemAt(0);if(!s.length)return void this.setMessage("noImageError","error");if(s[0].attributes.elevationSource&&!r.z&&n){const e=await S([r],{feature:s[0],currentCoveragePolygon:new Z(n),options:t});if(e[0]){const t=e[0];r.elevation=t.z}}this._suitabilities=I({features:s,selectedPoint:r,camera:q(this.view)?this.view.camera:null,currentImage:this.selectedFeature}),this._suitabilities?.sort(((e,t)=>e.suitability-t.suitability));const l=this._suitabilities?.map((e=>e.feature)),h=l[0];this._updateFeatures(l),this.selectedFeature=h,this._groupFeaturesBySectors(),this._initialCurrentCoverageUpdate=!0,this._plotPolygons=!0}async _processHitTestResults(e,t,r){const{screenPoint:i,results:[o]}=t,s="graphic"===o?.type&&this.shouldShowSelectedImage,a={layerInstanceOrURL:e,point:o?.mapPoint??this.view?.toMap(i),queryParams:{maximumDistance:e.maximumDistance,objectIds:s?[o.graphic.getAttribute(e.objectIdField)]:void 0},queryFeatures:null};await this.searchBestImage(a,r)}_updateFeatures(e){e.length&&(this.features.removeAll(),this.features.addMany(e))}_updatePointsAndPolygons(){const{coveragePolygons:e,pointSources:r,selectedFeature:i,currentCoverageVisible:o,isAdditionalCoverageVisible:s,isAdditionalPointSourcesVisible:a}=this;if(e&&r&&i){this._additionalCoveragePolygons.removeAll(),this._additionalFeatureGraphics.removeAll(),this._currentCoveragePolygon&&(this._currentCoveragePolygon.destroy(),this._currentCoveragePolygon=null,this._initialCurrentCoveragePolygon=null);for(const r of e)r?.imageID===i?.attributes.objectId?this._initialCurrentCoveragePolygon=new t({attributes:{imageID:r?.imageID},geometry:{type:"polygon",...r},symbol:k,visible:!1}):this._additionalCoveragePolygons.push(new t({attributes:{imageID:r?.imageID},geometry:{type:"polygon",...r},symbol:N,visible:s}));for(const e of r)e.imageID===i?.attributes.objectId?this._selectedFeatureGraphic=new t({attributes:{imageID:e.imageID},geometry:{type:"point",...e},symbol:H,visible:o}):this._additionalFeatureGraphics?.push(new t({attributes:{imageID:e.imageID},geometry:{type:"point",...e},symbol:J,visible:a}))}}_updateSelectedFeature(e){if(!e)return;this.selectedFeature=this.features?.at(e.featureIndex);const t=this.selectedFeature?.attributes.cameraPitch&&this.selectedFeature?.attributes.cameraPitch<5;let r;if(t)r=-90;else{const t=e.x-U[3],i=e.y-U[3],o=i/Math.sqrt(t**2+i**2);let s=180*Math.acos(o)/Math.PI;(t<0&&i<0||t<0&&i>0)&&(s*=-1),r=s}r===this.selectedFeatureAngle?this.previousFeatureAngle=r:this.selectedFeatureAngle=r,this.navigatorSelectedFeature=t?null:{x:e.x,y:e.y,direction:e.sector.includes("_")?e.sector.split("_")[1]:e.sector}}plotReferencePoint(e){"mapPoint"in e?this.plotReferencePointOnGround(e.mapPoint):this.plotReferencePointOnGround(e)}updateCurrentCoveragePolygon(e){if(this._initialCurrentCoverageUpdate)if(this._overlays?.removeAll(),this._initialCurrentCoverageUpdate=!1,e&&(this._currentCoveragePolygon&&this._currentCoveragePolygon.destroy(),e.visible=this.currentCoverageVisible,this._currentCoveragePolygon=e),this.view){this._plotPolygons=!1;const e=this.selectedPoint?new t({geometry:this.selectedPoint.clone(),symbol:z,attributes:{imageID:this.selectedFeature?.attributes.objectId}}):null;this._overlays?.graphics.addMany([...this._additionalCoveragePolygons,...this._additionalFeatureGraphics,this._currentCoveragePolygon,this._selectedFeatureGraphic,e].filter(W))}else if(this._plotPolygons){this._plotPolygons=!1;const e={points:this.pointSources?.filter((e=>e?.imageID!==this.selectedFeature?.attributes.objectId)),frustums:this.coverageFrustums?.filter((e=>e?.imageID!==this.selectedFeature?.attributes.objectId)),polygons:this._additionalCoveragePolygons?.map((e=>e.geometry?.toJSON())),currentPoint:this.pointSources.find((e=>e?.imageID===this.selectedFeature?.attributes.objectId)),currentPolygon:this._currentCoveragePolygon,currentFrustum:this.coverageFrustums?.find((e=>e?.imageID===this.selectedFeature?.attributes.objectId))};this.emit("plot-polygons",{data:e})}else{const e={currentPoint:this.pointSources.find((e=>e?.imageID===this.selectedFeature?.attributes.objectId)),additionalPoint:this.pointSources.find((e=>e?.imageID===this._initialPreviousCoveragePolygon?.attributes.imageID)),currentPolygon:this._currentCoveragePolygon,additionalPolygon:this._initialPreviousCoveragePolygon};this.emit("update-selected-feature",{data:e})}else if(this.view){const t=this._currentCoveragePolygon&&this._overlays?this._overlays.graphics.indexOf(this._currentCoveragePolygon):-1;e&&(this._currentCoveragePolygon&&(this._overlays?.remove(this._currentCoveragePolygon),this._currentCoveragePolygon.destroy()),e.visible=this.currentCoverageVisible,this._currentCoveragePolygon=e,this._overlays?.graphics.add(this._currentCoveragePolygon,t>=0?t:void 0))}else e&&(this._currentCoveragePolygon=e,this.emit("update-current-coverage",{graphic:e.toJSON()}))}async loadImage(e,t){if(!this._imageViewer)return;if(this._imageViewer.graphics.removeAll(),this._currentImage&&this._imageViewer?.map.layers.includes(this._currentImage)&&(this._currentImage?.removeHandles("image-handles"),this._imageViewer?.map.layers.remove(this._currentImage),this._currentImage?.destroy(),this._currentImage=null),!e)return void this.setMessage("noImageError","error");const{horizontalFieldOfView:r,isSpherical:i}=e.attributes;if(360===r||i)return void this.setMessage("unsupportedPanaromicImageryError","error");let o,s,a=e.attributes.imagePath;if(!Y(a)&&!ee(a)){if(!this.localPort)return this.setMessage("noLocalPort","error"),void n.getLogger(this).error("oriented-imagery-viewer:missing-local-port","A value for local port is not set. Local port is needed to load local images.");a=`http://127.0.0.1:${this.localPort}/${a}`}this._referencePointOnGround&&(this._imageViewer?.graphics.remove(this._referencePointOnGround),this._referencePointOnGround.destroy());const l={skipExtensions:["aux.xml","jgw"]};if(ee(a)){const r=new G({objectIds:[e.attributes.objectId]}),i=(await e.layer.queryAttachments(r,t))[`${e.attributes.objectId}`];if(!i[0]?.url)return void this.setMessage("noAttachment","error");if(o=i[0].contentType.split("/")[1]?.toUpperCase(),a=i[0]?.url,s=await A.open({ioConfig:l,url:a,datasetFormat:o,...t}).catch((e=>(this.setMessage("imageLoadError","error",e.message),null))),!s)return}this._currentImage=new P({ioConfig:l,url:a,raster:s,options:t}),this._imageViewer.map.layers.add(this._currentImage);try{const r=await this._currentImage.when();this._imageViewer.extent=r.fullExtent,r.raster.rasterInfo.isPseudoSpatialReference&&(this._imageViewer.rotation=(e.attributes.cameraRoll??0)+(e.attributes.imageRotation??0)),this._panConstraint&&this._imageViewer.constraints.customConstraints.remove(this._panConstraint),this._scaleConstraint&&this._imageViewer.constraints.customConstraints.remove(this._scaleConstraint),this._panConstraint={constrain:(e,t)=>{if(!this._currentImage||!this._imageViewer||!e.targetGeometry)return e;const{xmin:r,xmax:i,ymin:o,ymax:s}=this._currentImage.fullExtent,{extent:a,rotation:n}=this._imageViewer,l=n*Math.PI/180,h=Math.abs(Math.cos(l)*a.width+Math.sin(l)*a.height),c=Math.abs(Math.cos(l)*a.height+Math.sin(l)*a.width),{rasterInfo:g}=this._currentImage;return e.targetGeometry.x=Math.min(Math.max(r+Math.min(g.width,h)/2,e.targetGeometry.x),i-Math.min(g.width,h)/2),e.targetGeometry.y=Math.min(Math.max(o+Math.min(g.height,c)/2,e.targetGeometry.y),s-Math.min(g.height,c)/2),e},applyPanConstraint:e=>{if(!this._currentImage||!this._imageViewer||!e.targetGeometry)return e;const{xmin:t,xmax:r,ymin:i,ymax:o}=this._currentImage.fullExtent,{extent:s,rotation:a}=this._imageViewer,n=a*Math.PI/180,l=Math.abs(Math.cos(n)*s.width+Math.sin(n)*s.height),h=Math.abs(Math.cos(n)*s.height+Math.sin(n)*s.width),{rasterInfo:c}=this._currentImage;return e.targetGeometry.x=Math.min(Math.max(t+Math.min(c.width,l)/2,e.targetGeometry.x),r-Math.min(c.width,l)/2),e.targetGeometry.y=Math.min(Math.max(i+Math.min(c.height,h)/2,e.targetGeometry.y),o-Math.min(c.height,h)/2),e}},this._scaleConstraint={constrain:(e,t)=>{if(this._imageViewer&&this._currentImage){const{width:t,height:r}=this._currentImage.rasterInfo,{width:i,height:o,rotation:s,zoom:a}=this._imageViewer,n=s*Math.PI/180,l=Math.abs(Math.cos(n)*t+Math.sin(n)*r),h=Math.abs(Math.cos(n)*r+Math.sin(n)*t);a<1&&(e.scale=Math.max(e.scale,R(this._imageViewer.spatialReference)*Math.max(l/i,h/o)/2**a))}return e}},this._imageViewer.constraints.customConstraints.addMany([this._panConstraint,this._scaleConstraint]),r.addHandles(c((()=>[this.brightness,this.contrast,this.sharpness]),(([e,t,i])=>{r.loaded&&(r.effect=`contrast(${10*(t+10)}%) brightness(${10*(e+10)}%)`,this.sharpenImage(r,i))}),u)),await this.transformAndPlotSelectedLocation(t)}catch(h){n.getLogger(this).error("oriented-imagery-viewer:load-image",h),this.setMessage("imageLoadError","error",h.message)}}sharpenImage(e,t){const r=[0,-1*t,0,-1*t,5,-1*t,0,-1*t,0],i=new j({functionName:"Convolution",functionArguments:{type:O.userDefined,cols:3,rows:3,kernel:r,convolutionType:O.userDefined}});e.renderer=null,e.rasterFunction=i}async transformAndPlotSelectedLocation(e){const{_currentImage:r,selectedFeature:i,selectedPoint:o}=this;if(!o||!i||!r?.loaded)return;const{pixelSize:s}=r.rasterInfo,a=await x([o],{feature:i,imageProperties:r.rasterInfo,currentCoveragePolygon:this.getSelectedFeaturePolygon(),options:e});if(!a.length)return;const n=a[0];if(!n)return;const l=p(_,await E(r.fullExtent,p(Q,this._imageViewer?.spatialReference),null,e?.signal));n.x=n.x*s.x+l.xmin,n.y=l.ymax-n.y*s.y,n.spatialReference=l.spatialReference,this._crossSymbol&&(this._imageViewer?.graphics.remove(this._crossSymbol),this._crossSymbol.destroy()),this._crossSymbol=new t({geometry:K.fromJSON(n),symbol:z}),this._imageViewer?.graphics.add(this._crossSymbol)}async transformAndPlotReferencePointOnImage(e){if(!this._imageViewer)return;const t=this._currentImage;if(!t)return;const{feature:r,selectedLocation:i,options:o}=e,{pixelSize:s,isPseudoSpatialReference:a,transform:n}=t.rasterInfo,l=await x([i],{feature:r,imageProperties:t.rasterInfo,currentCoveragePolygon:this.getSelectedFeaturePolygon(),options:o});if(!l.length)return;let h=l[0];const c=await E(t.fullExtent,this._imageViewer.spatialReference,null,o?.signal);return a?(h.x=h.x*s.x+c.xmin,h.y=c.ymax-h.y*s.y,h.spatialReference=c.spatialReference):h=n.forwardTransform(new K(h)),this.plotReferencePointOnImage(h),{x:h.x,y:h.y}}plotReferencePointOnGround(e){this._referencePointOnGround&&(this._overlays?.remove(this._referencePointOnGround),this._referencePointOnGround.destroy()),this._referencePointOnGround=new t({geometry:{type:"point",...e.toJSON()},symbol:B}),this.view?this._overlays?.add(this._referencePointOnGround):this.emit("plot-ground-point",{data:{point:this._referencePointOnGround?.geometry}})}plotReferencePointOnImage(e){this._imageViewer&&(this._referencePointOnImage&&(this._imageViewer.graphics.remove(this._referencePointOnImage),this._referencePointOnImage.destroy()),this._referencePointOnImage=new t({geometry:{type:"point",...a(e)?e.toJSON():e},symbol:B}),this._imageViewer.graphics.add(this._referencePointOnImage))}setMessage(e,t,r){this.displayMessage={key:e,type:t,data:r}}async updateCoverage(){const e=new AbortController,{signal:r}=e;this._updateCoverageController=e;const{_imageViewer:i}=this;if(this._currentImage?.loaded&&i){const{width:e,height:o}=this._currentImage.rasterInfo,{xmin:s,xmax:a,ymin:n,ymax:l}=this._currentImage.fullExtent,h=[[0,0],[Math.min(i.width,e),0],[Math.min(i.width,e),Math.min(i.height,o)],[0,Math.min(i.height,o)]].map((e=>i.toMap(m(e[0],e[1]))));h.forEach((e=>{e.x=s<=e.x&&e.x<=a?e.x:Math.abs(s-e.x)>Math.abs(a-e.x)?a:s,e.y=n<=e.y&&e.y<=l?e.y:Math.abs(n-e.y)>Math.abs(l-e.y)?l:n}));const c=await V(h,{feature:this.getSelectedFeature(),currentCoveragePolygon:this.getSelectedFeaturePolygon(),imageProperties:this._currentImage.rasterInfo,options:{signal:r}});if(c&&!r.aborted){const e=[c.map((e=>[e.x,e.y,1]))];e[0].push(e[0][0]);const r=new Z({hasZ:!0,rings:e,spatialReference:c[0].spatialReference});this.updateCurrentCoveragePolygon(new t({attributes:{imageID:this.selectedFeature?.attributes.objectId},geometry:r,symbol:k,visible:this.currentCoverageVisible}))}}}};e([d()],te.prototype,"activeLayer",null),e([d()],te.prototype,"layer",void 0),e([d()],te.prototype,"shouldShowSelectedImage",void 0),e([d({type:Number})],te.prototype,"brightness",null),e([d({type:Number})],te.prototype,"contrast",null),e([d()],te.prototype,"coverageFrustums",void 0),e([d()],te.prototype,"coveragePolygons",void 0),e([d()],te.prototype,"currentCoverageVisible",void 0),e([d({readOnly:!0})],te.prototype,"currentImageView",null),e([d()],te.prototype,"disabled",void 0),e([d()],te.prototype,"displayMessage",void 0),e([d()],te.prototype,"pointSources",void 0),e([d()],te.prototype,"previousFeatureAngle",void 0),e([d()],te.prototype,"selectedFeature",void 0),e([d()],te.prototype,"selectedFeatureAngle",void 0),e([d()],te.prototype,"selectedPoint",void 0),e([d({readOnly:!0})],te.prototype,"featureCount",null),e([d()],te.prototype,"features",void 0),e([d({readOnly:!0})],te.prototype,"imageGalleryEnabled",null),e([d({readOnly:!0})],te.prototype,"imageLoaded",null),e([d()],te.prototype,"isAdditionalCoverageVisible",void 0),e([d()],te.prototype,"isAdditionalPointSourcesVisible",void 0),e([d({type:Number})],te.prototype,"localPort",void 0),e([d()],te.prototype,"mapImageConversionToolState",void 0),e([d()],te.prototype,"navigatorSelectedFeature",void 0),e([d({readOnly:!0})],te.prototype,"updating",null),e([d()],te.prototype,"referencePoint",null),e([d({type:Number})],te.prototype,"sharpness",null),e([d({readOnly:!0})],te.prototype,"sectorData",null),e([d({readOnly:!0})],te.prototype,"state",null),e([d({readOnly:!0})],te.prototype,"thumbnails",null),e([d({value:null})],te.prototype,"view",null),e([d()],te.prototype,"_additionalCoveragePolygons",void 0),e([d()],te.prototype,"_additionalFeatureGraphics",void 0),e([d()],te.prototype,"_currentCoveragePolygon",void 0),e([d()],te.prototype,"_currentImage",void 0),e([d()],te.prototype,"_fetchFeaturesController",void 0),e([d()],te.prototype,"_imageViewer",void 0),e([d()],te.prototype,"_initialCurrentCoveragePolygon",void 0),e([d()],te.prototype,"_initialCurrentCoverageUpdate",void 0),e([d()],te.prototype,"_overlays",void 0),e([d()],te.prototype,"_plotPolygons",void 0),e([d()],te.prototype,"_initialPreviousCoveragePolygon",void 0),e([d()],te.prototype,"_referencePointOnGround",void 0),e([d()],te.prototype,"_referencePointOnImage",void 0),e([d()],te.prototype,"_selectedFeatureGraphic",void 0),e([d()],te.prototype,"_sectorData",void 0),te=e([y("esri.widgets.OrientedImageryViewer.OrientedImageryViewerViewModel")],te);const re=te;export{re as default};
