/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../../../Graphic.js";import t from"../../../geometry/Polygon.js";import{addressToLocations as o}from"../../../rest/locator/addressToLocations.js";import{locationToAddress as r}from"../../../rest/locator/locationToAddress.js";import{suggestLocations as n}from"../../../rest/locator/suggestLocations.js";import s from"../../../rest/support/AddressToLocationsParameters.js";import c from"../../../rest/support/LocationToAddressParameters.js";import i from"../../../rest/support/SuggestLocationsParameters.js";import{createExtentFromGeometry as a,scaleExtent as u}from"./geometryUtils.js";const l="Single Line Input",m=3e5;function f(e,t){return e.location?v(e,t):h(e,t)}function d(e,t){if(t.localSearchDisabled)return null;const o=e?.scale;return"number"==typeof o&&o<=m?e?.extent?.center:null}async function g(e,t){const{source:o,spatialReference:r,view:s,suggestTerm:c,maxSuggestions:a,sourceIndex:u}=e,l=new i,{apiKey:m,url:f}=o,g=w(o,s),p=t?.signal;if(!f)return null;m&&(l.apiKey=m),o.categories&&(l.categories=o.categories),r&&(l.outSpatialReference=r);const y=d(s,o);y&&(l.location=y);if(!c.trim())return null;const{prefix:x="",suffix:S=""}=o,v=`${x}${c}${S}`;return l.text=v,g&&(l.searchExtent=g),l.maxSuggestions=a,o.countryCode&&(l.countryCode=o.countryCode),n(f,l,{signal:p}).then((e=>I(e,u)))}function p(e){return!!e&&/(?:geocode\-api\.arcgis\.com\/arcgis\/rest\/services\/world\/geocodeserver).*/i.test(e)}function y(e){return!!e&&/(?:\/servers\/[\da-z\.-]+\/rest\/services\/world\/geocodeserver).*/i.test(e)}function x(e){return!!e&&/(?:arcgis\.com\/arcgis\/rest\/services\/world\/geocodeserver).*/i.test(e)}const S="https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer";async function v(e,t){const{source:o,spatialReference:n,location:s,sourceIndex:i,view:a}=e,{apiKey:u,url:l,zoomScale:m,defaultZoomScale:f}=o;if(null==l)return[];const d=a?.scale,g=t?.signal,p=new c;p.location=s,u&&(p.apiKey=u),n&&(p.outSpatialReference=n);try{return K([await r(l,p,{signal:g})],{sourceIndex:i,scale:d,view:a,zoomScale:m,defaultZoomScale:f})}catch(y){return[]}}function w(e,t){const{filter:o,withinViewEnabled:r}=e,n=t?.scale,s=t?.extent,c=o?.geometry;return a(c,t,n)||(r&&s?s:void 0)}async function h(e,t){const{source:r,suggestResult:n,spatialReference:c,view:i,maxResults:a,sourceIndex:u}=e,m=r?.zoomScale,f=r?.defaultZoomScale,g=n.text?.trim();if(!g)return null;const p=!n.key&&r.prefix?r.prefix:"",y=!n.key&&r.suffix?r.suffix:"",x=`${p}${n.text}${y}`,S=new s,{apiKey:v,url:h}=r,j=i?.scale,I=w(r,i),$=t?.signal;if(v&&(S.apiKey=v),!h)return null;r.categories&&(S.categories=r.categories),r.locationType&&(S.locationType=r.locationType),c&&(S.outSpatialReference=c);const L=d(i,r);L&&(S.location=L),S.maxLocations=a,I&&(S.searchExtent=I),r.countryCode&&(S.countryCode=r.countryCode);const{key:R}=n,T=`${R}`;return R&&(S.magicKey=T),S.address={},S.address[r.singleLineFieldName||l]=x,r.outFields&&(S.outFields=r.outFields),o(h,S,{signal:$}).then((e=>K(e,{key:T,scale:j,sourceIndex:u,view:i,zoomScale:m,defaultZoomScale:f})))}function j(e,t){return{text:e.text,key:e.magicKey,sourceIndex:t}}function I(e,t){return e.map((e=>j(e,t)))}function $(o,r){const{key:n,scale:s,sourceIndex:c,view:i,zoomScale:l,defaultZoomScale:m}=r,{attributes:f,extent:d,location:g,address:p}=o,y=new e({geometry:g,attributes:f}),x=d||g,S=a(x,i,s),v="number"==typeof l?u(S,i,l):"number"==typeof m&&"point"===x?.type?u(S,i,m):S,w=g?`${g.x},${g.y}`:"",h=p||w,j=y.clone();return null!=v&&(j.geometry=t.fromExtent(v)),{extent:v,feature:y,target:j,key:n,name:h,sourceIndex:c}}function K(e,t){return e.filter(Boolean).map((e=>$(e,t)))}export{d as getLocation,f as getResults,g as getSuggestions,x as isArcGISWorldGeocoder,p as isMeteredArcGISWorldGeocoder,y as isProxiedArcGISWorldGeocoder,S as meteredArcGISLocatorUrl};
