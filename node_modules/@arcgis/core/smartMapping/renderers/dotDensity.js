/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import e from"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import r from"../../core/Error.js";import{getResolutionForScale as t}from"../../geometry/support/scaleUtils.js";import i from"../../renderers/support/AuthoringInfo.js";import s from"../heuristics/outline.js";import{roundValue as a}from"./support/dotDensityUtils.js";import{errorCallback as n,createColors as o,getSymbolOutlineFromScheme as l,verifyBasicFieldValidity as d,getBasemapInfo as u}from"./support/utils.js";import m from"../statistics/spatialStatistics.js";import p from"../statistics/summaryStatisticsForAttributes.js";import y from"../statistics/support/attributeDensity.js";import{verifyBinningParams as c}from"../support/binningUtils.js";import{getFieldsList as f}from"../support/utils.js";import{LayerType as b,binningCapableLayerTypes as g,createLayerAdapter as w,getLayerTypeLabels as v}from"../support/adapters/support/layerUtils.js";import{cloneScheme as h,getSchemes as S}from"../symbology/dotDensity.js";const j=500;async function V(e){const t=e.view;if(!(e?.layer&&t&&e.attributes?.length))throw new r("dot-density-renderer:missing-parameters","'layer', 'view' and 'attributes' parameters are required");if(e.attributes.length>8)throw new r("dot-density-renderer:invalid-parameters","Dot density renderer does not support more than 8 attributes");e.forBinning&&c(e,"dot-density-renderer");const i={...e,view:t,layer:e.layer,attributes:e.attributes},s=[b.FeatureLayer,b.OGCFeatureLayer,b.GeoJSONLayer,b.WFSLayer],a=e.forBinning?g:s,n=w(i.layer,a,e.forBinning);if(!n)throw new r("dot-density-renderer:invalid-parameters","'layer' must be one of these types: "+v(a).join(", "));i.layer=n,i.dotBlendingEnabled??=!0,i.dotValueOptimizationEnabled??=!0;const o=null!=i.signal?{signal:i.signal}:null;await Promise.all([t.when(),n.load(o)]);if("polygon"!==n.geometryType)throw new r("dot-density-renderer:not-supported","Dot density renderer is supported for polygon layers only");const l=[],u=i.attributes;for(const r of u){const e=await f({field:r.field,valueExpression:r.valueExpression});l.push(...e)}const m=d(n,l.filter(Boolean),"dot-density-renderer:invalid-parameters");if(m)throw m;return i}async function D(e){let r=e.dotDensityScheme,t=null,i=null;const s=await u(e.basemap,e.view);if(t=null!=s.basemapId?s.basemapId:null,i=null!=s.basemapTheme?s.basemapTheme:null,r)return{scheme:h(r),basemapId:t,basemapTheme:i};const a=S({numColors:e.attributes.length,basemapTheme:i});return a&&(r=a.primaryScheme,t=a.basemapId,i=a.basemapTheme),{scheme:r,basemapId:t,basemapTheme:i}}async function x(e){const{view:i,layer:s,attributes:n,signal:o}=e,l=await s.getSampleFeatures({view:i,sampleSize:j,returnGeometry:!0,signal:o}),[d,u]=await Promise.all([m({features:l,geometryType:s.geometryType}),p({layer:s,attributes:n,includeZeros:!1,includeNegatives:!1,view:i,signal:o})]),y=null!=d&&"avgSize"in d&&d.avgSize,c=u.avg;if(!y)throw new r("dot-density-renderer:insufficient-info","Average polygon size is invalid");if(!c)throw new r("dot-density-renderer:insufficient-info","Average attribute value is invalid");const f=t(i.scale,i.spatialReference);return{dotValue:a(c/(y*y/(f*f)*.1))||1,referenceScale:i.scale,minSliderValue:1,maxSliderValue:a(c)}}async function E(e){const{view:i,layer:s,attributes:n,signal:o}=e,l=[];for(const r of n){const e=await f({field:r.field,valueExpression:r.valueExpression});l.push(...e)}const d=await s.getSampleFeatures({view:i,sampleSize:j,requiredFields:l,returnGeometry:!0,signal:o}),u=await y({features:d,attributes:n,includeZeros:!1,includeNegatives:!1,view:i});if(!u.avgDensity||!u.minDensity||!u.maxDensity)throw new r("dot-density-renderer:insufficient-info","Invalid density values");const m=t(i.scale,i.spatialReference),p=m*m,c=a(u.minDensity*p),b=a(u.maxDensity*p),g=10;let w=a(u.avgDensity*p*g)||1;return w>b&&(w=b),{dotValue:w,referenceScale:i.scale,minSliderValue:c,maxSliderValue:b}}async function T(t){const a=await V(t),d=a.layer,u=d.geometryType,m=await D(a),p=m?.scheme;if(!p)throw new r("dot-density-renderer:insufficient-info","Unable to find dot-density scheme");const y=a.view,c={layer:d,view:y,attributes:a.attributes,signal:a.signal},f={layer:a.layer,view:y,signal:a.signal},[b,g]=await Promise.all([a.trueDensity?E(c):x(c),a.outlineOptimizationEnabled?s(f).catch(n):null]),{dotValue:w,referenceScale:v,minSliderValue:h,maxSliderValue:S}=b,j=o(p.colors,a.attributes.length),T=a.attributes.map(((e,r)=>({field:e.field,valueExpression:e.valueExpression,label:e.label,valueExpressionTitle:e.valueExpressionTitle,color:j[r]}))),I=new e({attributes:T,dotBlendingEnabled:a.dotBlendingEnabled,outline:g?l(p,u,g.opacity):null,dotValue:w,referenceScale:a.dotValueOptimizationEnabled?v:null,legendOptions:a.legendOptions});return g&&g.visualVariables&&g.visualVariables.length&&(I.visualVariables=g.visualVariables.map((e=>e.clone()))),I.authoringInfo=new i({type:"dot-density",minSliderValue:h,maxSliderValue:S}),{renderer:I,dotDensityScheme:p,basemapId:m.basemapId,basemapTheme:m.basemapTheme}}export{T as createRenderer};
