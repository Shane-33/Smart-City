/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import i from"../../core/Error.js";import{toPt as a}from"../../core/screenUtils.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import{substitute as s}from"../../intl/substitute.js";import r from"../../renderers/support/AuthoringInfo.js";import l from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as o}from"../../renderers/support/utils.js";import t from"../../renderers/visualVariables/SizeVariable.js";import{TransformationType as m}from"../../renderers/visualVariables/support/sizeVariableUtils.js";import u from"../heuristics/ageUnit.js";import p from"../heuristics/outline.js";import d from"../heuristics/sizeRange.js";import{getSummaryStatistics as c,getClassBreaks as y,errorCallback as f,formatDate as b,updateAgeRendererAuthoringInfoVV as w,verifyBasicFieldValidity as v,getDataRange as h,getSizeRangeForAxis as z,createSymbol as g,getSymbolOutlineFromScheme as T,getSymbolSizeFromScheme as x,getBasemapInfo as S}from"./support/utils.js";import{getAgeExpressions as E,verifyDates as V,supportedAgeUnits as j}from"../statistics/support/ageUtils.js";import{verifyBinningParams as k}from"../support/binningUtils.js";import{getFieldsList as I,getNormalizationType as q,isAnyDateField as O}from"../support/utils.js";import{binningCapableLayerTypes as F,featureCapableLayerTypes as B,createLayerAdapter as U,getLayerTypeLabels as D}from"../support/adapters/support/layerUtils.js";import{cloneScheme as M,getSchemes as R}from"../symbology/size.js";const C=2**53-1;async function A(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k(e,"size-visual-variable");const a={...e};if("90-10"===a.theme)throw new i("size-visual-variable:not-supported","Only 'high-to-low', 'above', 'below' themes are supported.");const n=e.forBinning?F:B,s=U(a.layer,n,e.forBinning);if(!s)throw new i("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+D(n).join(", "));a.layer=s,"height"===a.axis&&(a.sizeOptimizationEnabled=!1);const r=null!=a.signal?{signal:a.signal}:null;await s.load(r);const l=s.geometryType;if("mesh"===l)throw new i("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(a.worldScale){if("polyline"===l||"polygon"===l)throw new i("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!a.view||"3d"!==a.view.type)throw new i("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}const o=await I({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),t=v(s,o,"size-visual-variable:invalid-parameters");if(t)throw t;return a}async function L(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k(e,"size-continuous-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const n=e.forBinning?F:B,s=U(a.layer,n,e.forBinning);if(!s)throw new i("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+D(n).join(", "));a.layer=s;const r=null!=a.signal?{signal:a.signal}:null;await s.load(r);const l=s.geometryType,o=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="polygon"===l&&a.outlineOptimizationEnabled,"mesh"===l)throw new i("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(o&&("polyline"===l||"polygon"===l))throw new i("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=await I({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),m=v(s,t,"size-continuous-renderer:invalid-parameters");if(m)throw m;return a}async function P(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&k(e,"size-class-breaks-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0,a.classificationMethod??="equal-interval",a.normalizationType=q(a);const n=e.forBinning?F:B,s=U(a.layer,n,e.forBinning);if(!s)throw new i("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+D(n).join(", "));a.layer=s;if(!(null!=a.minValue&&null!=a.maxValue)&&(null!=a.minValue||null!=a.maxValue))throw new i("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const r=null!=a.signal?{signal:a.signal}:null;await s.load(r);const l=s.geometryType,o=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="polygon"===l&&a.outlineOptimizationEnabled,"mesh"===l)throw new i("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(o&&("polyline"===l||"polygon"===l))throw new i("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=await I({field:a.field,normalizationField:a.normalizationField}),m=v(s,t,"size-class-breaks-renderer:invalid-parameters");if(m)throw m;return a}function W(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}function $(e){const i={...e},a=!!i.symbolType?.includes("3d-volumetric"),n=i;return n.worldScale=a,a&&(n.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,n}async function H(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const a={...e};a.symbolType??="2d",a.defaultSymbolEnabled??=!0;const n=U(a.layer,B);if(!n)throw new i("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+D(B).join(", "));a.layer=n;const s=null!=a.signal?{signal:a.signal}:null;await n.load(s);const r=n.geometryType,l=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="polygon"===r&&a.outlineOptimizationEnabled,"mesh"===r)throw new i("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===r||"polygon"===r))throw new i("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=V(n,a.startTime,a.endTime,"size-age-renderer:invalid-parameters");if(o)throw o;if(a.unit&&!j.includes(a.unit))throw new i("size-age-renderer:invalid-unit",`Supported units are: ${j.join(", ")}`);return a}async function _(e){let i=e.sizeScheme,a=null,n=null;const s=await S(e.basemap,e.view);if(a=null!=s.basemapId?s.basemapId:null,n=null!=s.basemapTheme?s.basemapTheme:null,i)return{scheme:M(i),basemapId:a,basemapTheme:n};const r=R({basemapTheme:n,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return r&&(i=r.primaryScheme,a=r.basemapId,n=r.basemapTheme),{scheme:i,basemapId:a,basemapTheme:n}}function G(e,i){let a;switch(i){case"point":case"multipoint":{const i=e;a=[i.minSize,i.maxSize];break}case"polyline":{const i=e;a=[i.minWidth,i.maxWidth];break}case"polygon":{const i=e;a=[i.marker.minSize,i.marker.maxSize];break}}return a}function J(e,i){e.transformationType===m.ClampedLinear&&"below"===i&&e.flipSizes()}async function K(e,a,n,s){const{theme:o,field:m,normalizationField:u,minValue:p,maxValue:d,axis:c}=e,y=e.layer,f=m&&!("function"==typeof m)?y.getField(m):null,b=O(f),w=y.geometryType,v=await _({basemap:e.basemap,geometryType:w,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),g=v.scheme;if(!g)throw new i("size-visual-variable:insufficient-info","Unable to find size scheme");const T=s&&[s.minSize,s.maxSize]||G(g,w),{minDataValue:x,maxDataValue:S,defaultValuesUsed:E}=h(a,n,o,b,"above"===o||"below"===o),V=[],j="height"===c,k=j?c:void 0,I=T[0];let q=T[1];if(j&&"number"==typeof I&&"number"==typeof q){const e=z({minSize:I,maxSize:q},k);V.push(new t({axis:"width-and-depth",minSize:e.minSize})),q=e.maxSize}const F=new t({field:m,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:u,axis:k,minSize:I,maxSize:q,minDataValue:x,maxDataValue:S,legendOptions:e.legendOptions});J(F,o),V.unshift(F);const B=new l({type:"size",theme:o,minSliderValue:null!=p?p:a.min,maxSliderValue:null!=d?d:a.max}),U=new r({visualVariables:[B]});return{basemapId:v.basemapId,basemapTheme:v.basemapTheme,visualVariables:V,statistics:a,defaultValuesUsed:E,sizeScheme:M(g),authoringInfo:U}}async function N(i,a,s,r,l){const o=await n("esri/smartMapping/t9n/smartMapping"),t=l.layer,m=l.field,u=t.geometryType,p=l.defaultSymbolEnabled,d=M(i.sizeScheme),c="polygon"===u,y=c?d.marker:d,f=c?d.background:null,b=c?"point":u,w=a?.opacity,v=i.visualVariables.map((e=>e.clone()));a?.visualVariables?.length&&v.push(...a.visualVariables.map((e=>e.clone())));return{renderer:new e({backgroundFillSymbol:f&&g(u,{type:l.symbolType,color:f.color,outline:T(f,u,w)}),classBreakInfos:[{minValue:-C,maxValue:C,symbol:g(b,{type:l.symbolType,color:y.color,size:x(y,b),outline:T(y,b,w)})}],defaultLabel:p?o.other:null,defaultSymbol:p?g(b,{type:l.symbolType,color:y.noDataColor,size:x(y,b,!0),outline:T(y,b,w)}):null,field:m,normalizationField:r,normalizationType:s,valueExpression:l.valueExpression,valueExpressionTitle:l.valueExpressionTitle,visualVariables:v,authoringInfo:i.authoringInfo&&i.authoringInfo.clone()}),visualVariables:i.visualVariables.map((e=>e.clone())),statistics:i.statistics,defaultValuesUsed:i.defaultValuesUsed,sizeScheme:M(i.sizeScheme),basemapId:i.basemapId,basemapTheme:i.basemapTheme}}function Q(e,i){const n=a(e.minSize),s=(a(e.maxSize)-n)/(i>=4?i-1:i),r=[];for(let a=0;a<i;a++)r.push(n+s*a);return r}async function X(i,a){const s=await n("esri/smartMapping/t9n/smartMapping"),l=i.layer,t=i.defaultSymbolEnabled,m=l.geometryType,u="polygon"===m,p=i.symbolType?.includes("3d-volumetric"),d=await _({basemap:i.basemap,geometryType:m,sizeScheme:i.sizeScheme,worldScale:p,view:i.view}),c=d.scheme,{result:y,outlineResult:f}=a,b=y?.classBreakInfos??[],w=i.classificationMethod,v=i.normalizationType,h=u?c.marker:c,S=u?c.background:null,E=u?"point":m,V=G(h,E),j=p?z({minSize:V[0],maxSize:V[1]},"height"):null,k=Q({minSize:V[0],maxSize:j?j.maxSize:V[1]},b.length),I=f?.opacity,q=new e({backgroundFillSymbol:S&&g(m,{type:i.symbolType,color:S.color,outline:T(S,m,I)}),classBreakInfos:b.map(((e,a)=>({minValue:e.minValue,maxValue:e.maxValue,symbol:g(E,{type:i.symbolType,color:h.color,size:k[a],widthAndDepth:j&&j.minSize,outline:T(h,E,I)}),label:e.label}))),defaultLabel:t?s.other:null,defaultSymbol:t?g(E,{type:i.symbolType,color:h.noDataColor,size:x(h,E,!0),widthAndDepth:j&&j.minSize,outline:T(h,E,I)}):null,field:i.field,valueExpression:i.valueExpression,valueExpressionTitle:i.valueExpressionTitle,normalizationType:v,normalizationField:i.normalizationField,normalizationTotal:"percent-of-total"===v?y?.normalizationTotal:void 0,legendOptions:i.legendOptions,authoringInfo:new r({type:"class-breaks-size",classificationMethod:w,standardDeviationInterval:i.standardDeviationInterval})});return"standard-deviation"!==w&&o({classBreakInfos:q.classBreakInfos,classificationMethod:w,normalizationType:v,round:!0}),f?.visualVariables?.length&&(q.visualVariables=f.visualVariables.map((e=>e.clone()))),{renderer:q,sizeScheme:M(c),classBreaksResult:y,defaultValuesUsed:!!a.defaultValuesUsed,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}async function Y(e){const i=await A(e),{view:a,field:n,valueExpression:s,minValue:r,maxValue:l,layer:o,normalizationField:t,signal:m,statistics:u}=i,p=t?"field":void 0,[b,w,v]=await Promise.all([u??c({layer:o,field:n,valueExpression:s,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:p,normalizationField:t,minValue:r,maxValue:l,view:a,signal:m}),"90-10"===i.theme?y({layer:o,field:n,normalizationField:t,valueExpression:s,classificationMethod:"quantile",minValue:r,maxValue:l,view:a,numClasses:10,signal:m}):null,i.sizeOptimizationEnabled?d({view:a,layer:o,signal:m}).catch(f):null]);return K(i,b,w?.result,v)}async function Z(e){const i=await L(e),a={layer:i.layer,view:i.view,signal:i.signal},[n,s]=await Promise.all([Y($(i)),i.outlineOptimizationEnabled?p(a).catch(f):null]),r=i.normalizationField;return N(n,s,r?"field":void 0,r,i)}async function ee(e){const i=await P(e);return X(i,await y(W(i),i.outlineOptimizationEnabled))}async function ie(e){const i=await H(e),{defaultSymbolEnabled:a,view:r,startTime:l,endTime:o,symbolType:t,minValue:m,maxValue:d,signal:c}=i,y=i.layer,v={layer:i.layer,view:i.view,signal:c},[h,z]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await u({view:r,layer:y,startTime:l,endTime:o,minValue:m,maxValue:d,signal:c}),i.outlineOptimizationEnabled?p(v).catch(f):null]),{unit:g,statistics:T}=h,x=E({layer:y,startTime:l,endTime:o,unit:g}).valueExpression,S=await n("esri/smartMapping/t9n/smartMapping"),V=s(S[`ageInfo_${g}`],{unit:g,startTime:b(l,g,y,r),endTime:b(o,g,y,r)}),j=await Y($({layer:y,basemap:i.basemap,valueExpression:x,symbolType:t,statistics:T,legendOptions:{title:V},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:m,maxValue:d,signal:c})),k={layer:y,valueExpression:x,defaultSymbolEnabled:a,symbolType:t},I=await N(j,z,null,null,k),q=I.renderer.authoringInfo?.visualVariables;return q?.forEach((e=>w(e,l,o,g))),{...I,unit:g}}export{ie as createAgeRenderer,ee as createClassBreaksRenderer,Z as createContinuousRenderer,Y as createVisualVariables};
