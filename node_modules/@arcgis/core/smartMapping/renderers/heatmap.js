/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../../Color.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import r from"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import a from"../../core/Error.js";import t from"../../renderers/support/AuthoringInfo.js";import s from"../../renderers/support/HeatmapColorStop.js";import{gaussianBlurRadiusPxToKernelDensityRadiusPt as o}from"../../renderers/support/heatmapUtils.js";import{verifyBasicFieldValidity as n,createColors as i,getBasemapInfo as m}from"./support/utils.js";import p from"../statistics/heatmapStatistics.js";import{getFieldsList as l}from"../support/utils.js";import{LayerType as d,createLayerAdapter as f,getLayerTypeLabels as u}from"../support/adapters/support/layerUtils.js";import{cloneScheme as c,getSchemes as h}from"../symbology/heatmap.js";const w=.01;async function y(e){if(!e?.layer||!e.view)throw new a("heatmap-renderer:missing-parameters","'layer' and 'view' parameters are required");const r={...e,layer:e.layer,view:e.view};r.radius??=null==r.blurRadius?18:o(r.blurRadius),r.minRatio??=.01,r.maxRatio??=1,r.fadeRatio??=.2,r.fadeToTransparent??=!0;const t=[d.CSVLayer,d.FeatureLayer,d.OGCFeatureLayer,d.GeoJSONLayer,d.StreamLayer,d.WFSLayer],s=f(r.layer,t);if(!s)throw new a("heatmap-renderer:invalid-parameters","'layer' must be one of these types: "+u(t).join(", "));r.layer=s;const i=null!=r.signal?{signal:r.signal}:null;await s.load(i);const m=await l({field:r.field}),p=n(s,m,"heatmap-renderer:invalid-parameters");if(p)throw p;return r}async function b(e){let r=e.scheme,a=null,t=null;const s=await m(e.basemap,e.view);if(a=null!=s.basemapId?s.basemapId:null,t=null!=s.basemapTheme?s.basemapTheme:null,r)return{scheme:c(r),basemapId:a,basemapTheme:t};const o=h({basemapTheme:t});return o&&(r=o.primaryScheme,a=o.basemapId,t=o.basemapTheme),{scheme:r,basemapId:a,basemapTheme:t}}async function j(a,o){const{fieldOffset:n}=a,{field:m,basemap:p,radius:l,fadeToTransparent:d,heatmapScheme:f,view:u}=o,{scheme:h,basemapId:y,basemapTheme:j}=await b({basemap:p,scheme:f,view:u}),g=h.colors,I=g.length,T=!a.count,v=T?[0,.04]:[a.min,a.max];let S;const L=o.fadeRatio??0,x=o.maxRatio??0,C=o.minRatio??0,O=(x-C)/(I-1),D=g[0],U=d?C:w,E=[new s({ratio:0,color:new e([D.r,D.g,D.b,0])}),new s({ratio:w,color:new e([D.r,D.g,D.b,0])}),new s({ratio:U,color:new e([D.r,D.g,D.b,U])})];i(g,I).forEach(((e,r)=>{const a=C+O*r;E.push(new s({ratio:a,color:e}))})),d&&(R(E,L),S=new t({fadeRatio:L}));const F=new r({authoringInfo:S,radius:l,colorStops:E,field:m,minDensity:v[0],maxDensity:v[1]});return null!=n&&(F.fieldOffset=n),{renderer:F,statistics:a,defaultValuesUsed:T,scheme:c(h),basemapId:y,basemapTheme:j}}function R(e,r){const a=10*(1-r)+1,t=e.length-3,s=e[2].color.a;e.forEach(((e,o)=>{if(o<=2)return;const{color:n}=e,i=(o-3)/t;n.a=0===r?1:Math.min(Math.max(i*a+i+s,s),1)}))}async function g(e){const r=await y(e);return j(r.statistics??await p({layer:r.layer,field:r.field,fieldOffset:r.fieldOffset,radius:r.radius,view:r.view,signal:r.signal}),r)}function I(e){const{fadeRatio:r,renderer:a}=e,s=a.clone(),o=r??(s?.authoringInfo?.fadeRatio||0);return R(s.colorStops,o),s.authoringInfo?s.authoringInfo.fadeRatio=o:s.authoringInfo=new t({fadeRatio:o}),s}export{g as createRenderer,I as updateRenderer};
