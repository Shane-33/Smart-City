/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import e from"../../core/Accessor.js";import{property as s}from"../../core/accessorSupport/decorators/property.js";import"../../core/accessorSupport/ensureType.js";import"../../core/arrayUtils.js";import"../../core/has.js";import{subclass as o}from"../../core/accessorSupport/decorators/subclass.js";import{f as i,a}from"../../chunks/mat3f64.js";import{f as r,c as l}from"../../chunks/vec3f64.js";import{m as n,t as h}from"../../chunks/mat3.js";import{j as m,q as u,f as g,t as c}from"../../chunks/vec3.js";import p from"../../geometry/Point.js";import d from"../../geometry/SpatialReference.js";import{WGS84ECEFSpatialReference as f}from"../../geometry/spatialReferenceEllipsoidUtils.js";import{projectBuffer as v}from"../../geometry/projection/projectBuffer.js";import{earth as _}from"../../geometry/support/Ellipsoid.js";import{VideoMetadataEntryId as A}from"./videoUtils.js";const M=Math.PI/180;let y=class extends e{constructor(t){super(),this.averageElevation=0,this.imageHeight=0,this.imageWidth=0,this.metadataSupportsTransforms=!1,this.platformHeadingAngle=0,this.platformPitchAngle=0,this.platformRollAngle=0,this.sensorHeadingAngle=0,this.sensorAltitude=0,this.sensorHorizontalFieldOfView=0,this.sensorLatitude=0,this.sensorLongitude=0,this.sensorPitchAngle=0,this.sensorRollAngle=0,this.sensorVerticalFieldOfView=0,this.vttMetadata=new Map,this._createMat3FromValues=t=>{const e=t[0],s=t[1],o=t[2];return i(e[0],s[0],o[0],e[1],s[1],o[1],e[2],s[2],o[2])},this._multiplyMat3=(t,e)=>{const s=a();return n(s,t,e),s},this._transposeMat3=t=>{const e=a();return h(e,t),e},this._calculateCameraFovForward=()=>this._createMat3FromValues([[0,0,1],[Math.tan(.5*this.sensorHorizontalFieldOfView*M),0,0],[0,Math.tan(.5*this.sensorVerticalFieldOfView*M),0]]),this._calculateCameraFovReverse=()=>this._createMat3FromValues([[0,1/Math.tan(.5*this.sensorHorizontalFieldOfView*M),0],[0,0,1/Math.tan(.5*this.sensorVerticalFieldOfView*M)],[1,0,0]]),this._calculateCameraLook=()=>this._getRotationMatrixZYX(this.sensorHeadingAngle*M,this.sensorPitchAngle*M,this.sensorRollAngle*M),this._calculateImageDimensionsForward=()=>this._createMat3FromValues([[2/this.imageWidth,0,-1],[0,-2/this.imageHeight,-1],[0,0,1]]),this._calculateImageDimensionsReverse=()=>this._createMat3FromValues([[this.imageWidth/2,0,this.imageWidth/2],[0,-this.imageHeight/2,-this.imageHeight/2],[0,0,1]]),this._calculatePlatformPositionMatrix=()=>{const t=Math.sin(this.sensorLatitude*M),e=Math.cos(this.sensorLatitude*M),s=Math.sin(this.sensorLongitude*M),o=Math.cos(this.sensorLongitude*M);return this._createMat3FromValues([[-t*o,-s,-e*o],[-t*s,o,-e*s],[e,0,-t]])},this._calculatePlatformOrientation=()=>this._getRotationMatrixZYX(this.platformHeadingAngle*M,this.platformPitchAngle*M,this.platformRollAngle*M),this._extractValues=t=>{this.imageWidth=t.get(A.EsriVideoWidth)?.value,this.imageHeight=t.get(A.EsriVideoHeight)?.value;const e=t.get(A.SensorEllipsoidHeight)?.value;this.sensorAltitude=e??t.get(A.SensorTrueAltitude)?.value,this.sensorLatitude=t.get(A.SensorLatitude)?.value,this.sensorLongitude=t.get(A.SensorLongitude)?.value,this.sensorHeadingAngle=t.get(A.SensorAzimuthAngle)?.value,this.sensorPitchAngle=t.get(A.SensorElevationAngle)?.value,this.sensorRollAngle=t.get(A.SensorRollAngle)?.value,this.sensorHorizontalFieldOfView=t.get(A.SensorHorizontalFOV)?.value,this.sensorVerticalFieldOfView=t.get(A.SensorVerticalFOV)?.value,this.platformHeadingAngle=t.get(A.PlatformHeadingAngle)?.value,this.platformPitchAngle=t.get(A.PlatformPitchAngle)?.value,this.platformRollAngle=t.get(A.PlatformRollAngle)?.value,this.averageElevation=t.get(A.FrameCenterElevation)?.value||0},this._getRotationMatrixZYX=(t,e,s)=>{const o=Math.cos(t),i=Math.sin(t),a=Math.cos(e),r=Math.sin(e),l=Math.cos(s),n=Math.sin(s);return this._createMat3FromValues([[o*a,o*r*n-l*i,i*n+o*l*r],[a*i,o*l+i*r*n,l*i*r-o*n],[-r,a*n,a*l]])},this._initCameraSensor=()=>{const t=this._calculateCameraFovForward(),e=this._calculateCameraFovReverse(),s=this._calculateCameraLook(),o=this._calculateImageDimensionsForward(),i=this._calculateImageDimensionsReverse(),a=this._calculatePlatformPositionMatrix(),r=this._calculatePlatformOrientation(),l=this._multiplyMat3(this._multiplyMat3(a,r),s);this._imageToEarthTransform=this._multiplyMat3(this._multiplyMat3(l,t),o);const n=this._multiplyMat3(i,e);this._earthToImageTransform=this._multiplyMat3(n,this._transposeMat3(l)),this._platformPositionEcef=this._projectPointToECEF(this.sensorLongitude,this.sensorLatitude,this.sensorAltitude||this.averageElevation)},this._metadataSupportsTransforms=t=>{if(!t?.size)return!1;const e=t.get(A.EsriVideoWidth)?.value??0,s=t.get(A.EsriVideoHeight)?.value??0;if(e<=0||s<=0)return!1;const o=t.get(A.SensorEllipsoidHeight)?.value,i=t.get(A.SensorTrueAltitude)?.value,a=t.get(A.SensorLatitude)?.value,r=t.get(A.SensorLongitude)?.value;if(null==o&&null==i||null==a||null==r)return!1;const l=t.get(A.PlatformHeadingAngle)?.value,n=t.get(A.PlatformPitchAngle)?.value,h=t.get(A.PlatformRollAngle)?.value;if(null==l||null==n||null==h)return!1;const m=t.get(A.SensorHorizontalFOV)?.value,u=t.get(A.SensorVerticalFOV)?.value;if(null==m||null==u)return!1;const g=t.get(A.SensorAzimuthAngle)?.value,c=t.get(A.SensorElevationAngle)?.value,p=t.get(A.SensorRollAngle)?.value;return null!=g&&null!=c&&null!=p},this._projectPointToECEF=(t,e,s)=>{const o=[];return v([t,e,s],d.WGS84,0,o,f,0,1),new p({x:o[0],y:o[1],z:o[2],spatialReference:f})},this._projectImageVectorToEllipsoid=(t,e)=>{const s=_.semiMajorAxis+e,o=_.semiMinorAxis+e,i=o/s,a=s/o,{x:n,y:h,z:g}=this._platformPositionEcef,c=g??this.averageElevation,p=r(n,h,a*c),d=m(t,t),f=m(t,p),v=m(p,p)-s*s,A=(-f-Math.sqrt(f*f-d*v))/d;if(A<0)return[NaN,NaN,NaN];const M=l();return u(M,p,t,A),M[2]=M[2]*i,M};const e=t?.videoMetadata;this._set("metadataSupportsTransforms",this._metadataSupportsTransforms(e)),this.metadataSupportsTransforms&&(this._extractValues(e),this._initCameraSensor())}transformGeoToImage(t,e,s){const o=this._platformPositionEcef;if(!o)return[0,0];const{x:i,y:a,z:n}=o,h=r(i,a,n),m=this._projectPointToECEF(t,e,s||this.averageElevation),u=l(),p=r(m.x,m.y,m.z);g(u,p,h),c(u,u,this._earthToImageTransform);const d=u[0],f=u[1],v=u[2];let _=r(NaN,NaN,NaN);return isNaN(v)||(_=r(d/v,f/v,v/v)),[_[0],_[1]]}transformImageToGeo(t,e){const s=r(t,e,1),o=l();c(o,s,this._imageToEarthTransform);const i=this._projectImageVectorToEllipsoid(o,this.averageElevation);let a;if(!isNaN(i[0])){const t=[];v([i[0],i[1],i[2]],f,0,t,d.WGS84,0,1),a=new p({x:t[0],y:t[1],z:t[2],spatialReference:d.WGS84})}return a}};t([s()],y.prototype,"averageElevation",void 0),t([s()],y.prototype,"imageHeight",void 0),t([s()],y.prototype,"imageWidth",void 0),t([s({readOnly:!0})],y.prototype,"metadataSupportsTransforms",void 0),t([s()],y.prototype,"platformHeadingAngle",void 0),t([s()],y.prototype,"platformPitchAngle",void 0),t([s()],y.prototype,"platformRollAngle",void 0),t([s()],y.prototype,"sensorHeadingAngle",void 0),t([s()],y.prototype,"sensorAltitude",void 0),t([s()],y.prototype,"sensorHorizontalFieldOfView",void 0),t([s()],y.prototype,"sensorLatitude",void 0),t([s()],y.prototype,"sensorLongitude",void 0),t([s()],y.prototype,"sensorPitchAngle",void 0),t([s()],y.prototype,"sensorRollAngle",void 0),t([s()],y.prototype,"sensorVerticalFieldOfView",void 0),t([s()],y.prototype,"vttMetadata",void 0),y=t([o("esri.layers.video.VideoCameraSensorModel")],y);const V=y;export{V as default};
