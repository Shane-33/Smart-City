/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{difference as e,isSome as a}from"../../core/arrayUtils.js";import r from"../../core/Error.js";import{updateOrigins as t}from"../../core/accessorSupport/originUtils.js";import{save as o,getLayerJSON as s,setCommonItemProperties as n,saveAs as l,getPortalItem as i,addItem as c,ensureLayerConfig as u,ensureItemConfig as p,createErrorMessage as y}from"./utils.js";import{parse as m}from"../support/arcgisLayerUrl.js";import{fetchFeatureService as f}from"../support/fetchService.js";import{isLayerWithFeatureLayerSource as d}from"../support/layerUtils.js";import{layerLookupMap as h}from"../support/lazyLayerLoader.js";import{createForItemWrite as w}from"../../portal/support/jsonContext.js";import{getWGS84ExtentForItem as v,removeTypeKeyword as I,TypeKeyword as T,toggleTypeKeword as S,addTypeKeyword as b}from"../../portal/support/portalItemUtils.js";const L="Feature Service",P="feature-layer-utils",E=`${P}-save`,$=`${P}-save-as`,A=`${P}-saveall`,N=`${P}-saveall-as`;function g(e){return{isValid:d(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function x(e){const a=[],r=[];for(const{layer:t,layerJSON:o}of e)t.isTable?r.push(o):a.push(o);return{layers:a,tables:r}}function j(e){return x([e])}async function O(e,a){return/\/\d+\/?$/.test(e.url)?j(a[0]):U(a,e)}async function U(e,a){if(!a)return e.reverse(),x(e);const{layer:{url:r,customParameters:t,apiKey:o}}=e[0];let s=await a.fetchData("json");null!=s?.layers&&null!=s?.tables||(s=await F(s,{url:r??"",customParameters:t,apiKey:o},e.map((e=>e.layer.layerId))));for(const n of e)K(n.layer,n.layerJSON,s);return s}async function F(e,a,r){e||={},e.layers||=[],e.tables||=[];const{url:t,customParameters:o,apiKey:s}=a,{serviceJSON:n,layersJSON:l}=await f(t,{customParameters:o,apiKey:s}),i=J(e.layers,n.layers,r),c=J(e.tables,n.tables,r);e.layers=i.itemResources,e.tables=c.itemResources;const u=[...i.added,...c.added],p=l?[...l.layers,...l.tables]:[];return await M(e,u,t,p),e}function J(a,r,t){const o=e(a,r,((e,a)=>e.id===a.id));a=a.filter((e=>!o.removed.some((a=>a.id===e.id))));const s=o.added;return s.forEach((({id:e})=>{a.push({id:e})})),{itemResources:a,added:s.filter((({id:e})=>!t.includes(e)))}}async function M(e,a,r,t){const o=await R(a),s=a.map((({id:e,type:a})=>new(o.get(a))({url:r,layerId:e,sourceJSON:t.find((({id:a})=>a===e))})));await Promise.allSettled(s.map((e=>e.load()))),s.forEach((a=>{const{layerId:r,loaded:t,defaultPopupTemplate:o}=a;if(!t||null==o)return;const s={id:r,popupInfo:o.toJSON()};"ArcGISFeatureLayer"!==a.operationalLayerType&&(s.layerType=a.operationalLayerType),K(a,s,e)}))}async function R(e){const a=[];e.forEach((({type:e})=>{const r=D(e),t=h[r];a.push(t())}));const r=await Promise.all(a),t=new Map;return e.forEach((({type:e},a)=>{t.set(e,r[a])})),t}function D(e){let a;switch(e){case"Feature Layer":case"Table":a="FeatureLayer";break;case"Oriented Imagery Layer":a="OrientedImageryLayer"}return a}function K(e,a,r){e.isTable?Y(r.tables,a):Y(r.layers,a)}function Y(e,a){const r=e.findIndex((({id:e})=>e===a.id));-1===r?e.push(a):e[r]=a}function _(e,a){if(!e.length)throw new r(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function z(e,a){const t=e.map((e=>e.portalItem.id));if(new Set(t).size>1)throw new r(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function G(e,a){const t=e.map((e=>e.layerId));if(new Set(t).size!==t.length)throw new r(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function B(e){_(e,A),await Promise.all(e.map((e=>e.load())));for(const a of e)u(a,A,g),p({layer:a,itemType:L,errorNamePrefix:A});z(e,A),G(e,A)}async function k(e,a){const{url:r,layerId:t,title:o,fullExtent:s,isTable:n}=e,l=m(r);a.url="FeatureServer"===l?.serverType?r:`${r}/${t}`,a.title||=o,a.extent=null,n||null==s||(a.extent=await v(s)),I(a,T.METADATA),I(a,T.MULTI_LAYER),b(a,T.SINGLE_LAYER),n&&b(a,T.TABLE)}function C(e,a){for(const n of e){const t=n.parsedUrl.path,o=m(t),s=o?.url.path;if(!s)throw new r(`${a}:invalid-parameters`,y(n,`has unsupported url pattern: ${t}`),{layer:n});const l=o?.serverType;if("FeatureServer"!==l&&"MapServer"!==l)throw new r(`${a}:invalid-parameters`,y(n,`has unsupported server type: ${l}`),{layer:n});if("MapServer"===l&&e.length>1)throw new r(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=m(e[0].parsedUrl.path),o=t?.url.path,s=e.every((e=>{const a=m(e.parsedUrl.path);return a?.url.path===o}));if(!s)throw new r(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function V(e){_(e,N),await Promise.all(e.map((e=>e.load())));for(const a of e)u(a,N,g);C(e,N),G(e,N)}async function q(e,r){let t=0,o=0;for(const{isTable:a}of r)a?o++:t++;const s=r[0].parsedUrl.path,l=m(s);if(e.url="FeatureServer"===l?.serverType?l.url.path:s,e.title||=l.title,e.extent=null,t>0){const t=r.map((e=>e.fullExtent)).filter(a).reduce(((e,a)=>e.clone().union(a)));t&&(e.extent=await v(t))}I(e,T.METADATA),S(e,T.MULTI_LAYER,r.length>1),S(e,T.SINGLE_LAYER,1===r.length),S(e,T.TABLE,o>0&&0===t),n(e)}async function H(e,a){return o({layer:e,itemType:L,validateLayer:g,createItemData:(e,a)=>O(a,[e]),errorNamePrefix:E},a)}async function Q(e,a){await B(e);const r=e[0].portalItem,o=w(r),l=await Promise.all(e.map((e=>s(e,o,a)))),i=await O(r,e.map(((e,a)=>({layer:e,layerJSON:l[a]}))));return n(r),await r.update({data:i}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),t(o),r.clone()}async function W(e,a,r){return l({layer:e,itemType:L,validateLayer:g,createItemData:(e,a)=>Promise.resolve(j(e)),errorNamePrefix:$,newItem:a,setItemProperties:k},r)}async function X(e,a,r){await V(e);const o=i({itemType:L,errorNamePrefix:N,newItem:a}),n=w(o),l=await Promise.all(e.map((e=>s(e,n,r)))),u=await U(e.map(((e,a)=>({layer:e,layerJSON:l[a]}))));await q(o,e),await c(o,u,r);for(const t of e)t.portalItem=o.clone();return t(n),o}export{H as save,Q as saveAll,X as saveAllAs,W as saveAs};
