/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as t,websceneRasterRendererTypes as r,read as i}from"../../rasterRenderers.js";import n from"../../request.js";import s from"../../core/Error.js";import o from"../../core/Logger.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import{ensureClass as l}from"../../core/accessorSupport/ensureType.js";import"../../core/arrayUtils.js";import"../../core/has.js";import{reader as u}from"../../core/accessorSupport/decorators/reader.js";import{subclass as c}from"../../core/accessorSupport/decorators/subclass.js";import{getInfo as d}from"../../geometry/support/spatialReferenceUtils.js";import{sanitizeUrl as m}from"../support/arcgisLayerUrl.js";import{url as h}from"../support/commonProperties.js";import p from"../support/DimensionalDefinition.js";import f from"../support/MultidimensionalSubset.js";import y from"../support/RasterFunction.js";import b from"../support/RasterJobHandler.js";import g from"../support/TileInfo.js";import F from"../support/rasterDatasets/FunctionRaster.js";import{getDefaultMultidimensionalDefinition as J,hasExcludedVariableOrDimension as R,getDefaultVariablInfo as _,isMultiSliceOrRangeDefinition as I,getSubsetVariablesFromMdInfo as S}from"../support/rasterDatasets/multidimensionalUtils.js";import{snapToRaster as x,clip as w}from"../support/rasterFunctions/clipUtils.js";import{create as v}from"../support/rasterFunctions/rasterFunctionHelper.js";import{load as j,projectExtent as D,projectPolygon as H}from"../support/rasterFunctions/rasterProjectionHelper.js";import{computeStatisticsHistograms as T}from"../support/rasterFunctions/stretchUtils.js";import{convertVectorFieldData as N}from"../support/rasterFunctions/vectorFieldUtils.js";import{normalizeRendererJSON as O,getVariableRasterInfo as z,getDefaultInterpolation as P,getDefaultBandCombination as C,createDefaultRenderer as E}from"../../renderers/support/rasterRendererHelper.js";import A from"../../renderers/support/RasterSymbolizer.js";import M from"../../rest/support/ImageHistogramParameters.js";import{createFlowMesh as U}from"../../views/2d/engine/flow/dataUtils.js";import k from"../../geometry/SpatialReference.js";import q from"../../geometry/Point.js";const B=o.getLogger("esri.layers.mixins.ImageryTileMixin"),V=o=>{let V=class extends o{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===e[0]?.raster?.datasetFormat}get fullExtent(){return this.rasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",m(e,B))}set renderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("renderer",e),this.updateRenderer())}readRenderer(e,t,r){const n=t?.layerDefinition?.drawingInfo?.renderer;return i(n,r)||void 0}async convertVectorFieldData(e,t){if(null==e||!this.rasterInfo)return null;const r=this._rasterJobHandler.instance,i=this.rasterInfo.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:i},t):N(e,i)}async computeStatisticsHistograms(e,t){e=l(M,e).clone();const{rasterInfo:r}=this,{geometry:i}=e;if(null==i)throw new s("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let n=i;const{spatialReference:o}=r;i.spatialReference.equals(o)||(await j(),n="extent"===i.type?D(i,o):H(i,o));const a=e.pixelSize??new q({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:o}),{extent:u,width:c,height:d}=x(r,n,a),m=await this.fetchPixels(u,c,d,{...t,interpolation:"nearest"});if(null==m.pixelBlock)throw new s("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const h=await w(m.pixelBlock,u,n),p=this._rasterJobHandler.instance;return p?p.computeStatisticsHistograms({pixelBlock:h},t):T(h)}async createFlowMesh(e,t){const r=this._rasterJobHandler.instance;return r?r.createFlowMesh(e,t):U(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.rasterInfo??{};if(null==t)return e;let r=e.multidimensionalDefinition||this.multidimensionalDefinition;r?.length||(r=J(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const i=e.timeExtent||this.timeExtent;if(null!=r&&null!=i&&(null!=i.start||null!=i.end)){r=r.map((e=>e.clone()));const n=t.variables.find((({name:e})=>e===r[0].variableName))?.dimensions?.find((({name:e})=>"StdTime"===e)),s=r.find((({dimensionName:e})=>"StdTime"===e));if(!n||!s)return{...e,multidimensionalDefinition:null};const{start:o,end:a}=i,l=null==o?null:o.getTime(),u=null==a?null:a.getTime(),c=l??u,d=u??l;if(null!=n.values){const e=n.values.filter((e=>{if(Array.isArray(e)){if(c===d)return e[0]<=c&&e[1]>=c;const t=e[0]<=c&&e[1]>c||e[0]<d&&e[1]>=d,r=e[0]>=c&&e[1]<=d||e[0]<c&&e[1]>d;return t||r}return c===d?e===c:e>=c&&e<=d}));if(e.length){const t=e.sort(((e,t)=>{const r=Array.isArray(e)?e[0]:e,i=Array.isArray(e)?e[1]:e,n=Array.isArray(t)?t[0]:t,s=Array.isArray(t)?t[1]:t;if(c===d)return r-n;return Math.abs(i-d)-Math.abs(s-d)}))[0];s.values=[t]}else r=null}else if(n.hasRegularIntervals&&n.extent){const[e,t]=n.extent;c>t||d<e?r=null:s.values=c===d?[c]:[Math.max(e,c),Math.min(t,d)]}}return null!=r&&R(r,this.multidimensionalSubset)?{...e,multidimensionalDefinition:null}:{...e,multidimensionalDefinition:r}}async updateRasterFunction(){if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const e=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&e&&this._set("rasterFunction",y.fromJSON(e)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let e,t=this.raster,r=!1;"Function"===t.datasetFormat?(e=t.primaryRasters.rasters,t=e[0],r=!0):e=[t];const{rasterFunction:i}=this;if(i){const r={raster:t};e.length>1&&e.forEach((e=>r[e.url]=e));const n=v(i.functionDefinition?.toJSON()??i.toJSON(),r),s=new F({rasterFunction:n});s.rasterJobHandler=this._rasterJobHandler.instance,await s.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=s}else this.raster=t,this._cachedRasterFunctionJson=null,await t.when();if(this._cachedRendererJson=null,!r&&!i)return;const{bandIds:n}=this,{bandCount:s}=this.raster.rasterInfo,o=n?.length?n.some((e=>e>=s)):s>=3;n&&(o||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:e,symbolizer:t}=this;if(!e||!t||!this.renderer)return;const{rasterInfo:r}=this.raster,i=_(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),n=i?.name,s=O({...this.renderer.toJSON(),variableName:n});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(s))return;const o=this._rasterJobHandler.instance;o&&(t.rasterInfo=z(r,n),t.rendererJSON=s,t.bind(),await o.updateSymbolizer(t),this._cachedRendererJson=s)}async applyRenderer(e,t){const r=e?.pixelBlock;if(!(null!=r&&r.pixels&&r.pixels.length>0))return null;let i;await this.updateRenderer();const n=this._rasterJobHandler.instance,s=this.bandIds??[];return i=n?await n.symbolize({...e,simpleStretchParams:t,bandIds:s}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:s}),i}getTileUrl(e,t,r){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${r}`:""}getCompatibleTileInfo(e,t,r=!1){if(!this.loaded||null==t)return null;if(r&&e.equals(this.spatialReference))return this.tileInfo;const i=d(e);return g.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,r,i={}){if(L(this),i.requestAsImageElement){const s=this.getTileUrl(e,t,r);return n(s,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:i.signal}).then((e=>e.data))}const{rasterInfo:s}=this;if(null!=s.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition){const n=i.tileInfo||s.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,r,n),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(i={...i,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,r,i)}async fetchPixels(e,t,r,i={}){return null!=this.rasterInfo.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),r=Math.round(r),this.raster.fetchPixels(e,t,r,i))}async identify(e,t={}){const{raster:r,rasterInfo:i}=this;if(null!=i.multidimensionalInfo){if(!(i.hasMultidimensionalTranspose&&!!(I(t.multidimensionalDefinition)||t.transposedVariableName||t.timeExtent))&&null==(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition)return{location:e,value:null}}const n=this.multidimensionalSubset?.areaOfInterest;if(n&&!n.contains(e))throw new s("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return r.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.rasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.rasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,r=t?.[0]?.variableName;return e.variables.some((e=>e.name===r&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date(24*(e-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(e){const t=e??this.rasterInfo?.multidimensionalInfo;return S(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=J(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new b;return this._rasterJobHandler.connectionPromise=e.initialize().then((async()=>{L(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){L(this);const{raster:e}=this,t=P(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(e="no"){L(this);const{rasterInfo:t}=this.raster;!this.bandIds&&t.bandCount>1&&(this.bandIds=C(t));const r=_(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=r?.name;if(!this.renderer||"override"===e){const e=E(t,{bandIds:this.bandIds,variableName:i}),r=t.statistics,n=r&&r.length>0?r[0]:null,s=n?.max??0,o=n?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===e.type&&(s>1e24||o<-1e24)&&(e.dynamicRangeAdjustment=!0,e.statistics=null,"none"===e.stretchType&&(e.stretchType="min-max")),this.renderer=e}const n=O({...this.renderer.toJSON(),variableName:i}),s=z(t,i);this.symbolizer?(this.symbolizer.rendererJSON=n,this.symbolizer.rasterInfo=s):this.symbolizer=new A({rendererJSON:n,rasterInfo:s});const o=this.symbolizer.bind();if(o.success){if("auto"===e){const{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type){const e=E(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer("override")}else if("raster-stretch"===t.type){const e=this.bandIds?.length,r=t.statistics?.length;!t.dynamicRangeAdjustment&&r&&e&&r!==e&&this._configDefaultRenderer("override")}}}else B.warn("imagery-tile-mixin",o.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}};function L(e){if(!e.raster||!e.rasterInfo)throw new s("imagery-tile","no raster")}return e([a({clonable:!1})],V.prototype,"_cachedRendererJson",void 0),e([a({clonable:!1})],V.prototype,"_cachedRasterFunctionJson",void 0),e([a({clonable:!1})],V.prototype,"_compatibleFullExtent",void 0),e([a({clonable:!1})],V.prototype,"_isConstructedFromFunctionRaster",void 0),e([a({clonable:!1})],V.prototype,"_rasterJobHandler",void 0),e([a()],V.prototype,"bandIds",void 0),e([a({json:{origins:{service:{read:{source:"copyrightText"}}}}})],V.prototype,"copyright",void 0),e([a({json:{read:!1}})],V.prototype,"fullExtent",null),e([a()],V.prototype,"interpolation",void 0),e([a()],V.prototype,"ioConfig",void 0),e([a({type:[p],json:{write:!0}})],V.prototype,"multidimensionalDefinition",null),e([a({type:f,json:{write:!0}})],V.prototype,"multidimensionalSubset",void 0),e([a()],V.prototype,"raster",void 0),e([a({type:y,json:{name:"renderingRule",write:!0}})],V.prototype,"rasterFunction",null),e([a()],V.prototype,"rasterInfo",void 0),e([a()],V.prototype,"sourceJSON",void 0),e([a({readOnly:!0,type:k,json:{read:!1}})],V.prototype,"spatialReference",void 0),e([a({type:g})],V.prototype,"tileInfo",void 0),e([a(h)],V.prototype,"url",null),e([a({types:t,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:r,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],V.prototype,"renderer",null),e([u("renderer")],V.prototype,"readRenderer",null),e([a({clonable:!1})],V.prototype,"symbolizer",void 0),V=e([c("esri.layers.ImageryTileMixin")],V),V};export{V as ImageryTileMixin};
