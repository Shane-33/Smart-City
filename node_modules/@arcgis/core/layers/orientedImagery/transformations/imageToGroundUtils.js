/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{z as e}from"../../../chunks/vec3f64.js";import{u as t,g as a}from"../../../chunks/vec3.js";import r from"../../../geometry/Point.js";import{project as n}from"../../../geometry/projection.js";import{geographicToWebMercator as i,webMercatorToGeographic as s}from"../../../geometry/support/webMercatorUtils.js";import x from"../core/ExposurePoint.js";import{transformPoints as c,updateElevation as y}from"./groundToImageUtils.js";import{ltpToGeographic as o,computeHFOVAndVFOV as l,projectiveTransform2 as f,scaleWithFactor as z,scaleAndAddWithFactor as p,calculateRotationMatrix as m,transformMat3 as u,projectiveTransform as R,getPlaneLineIntersectionPoint as w}from"./utils.js";import h from"../../../geometry/SpatialReference.js";import g from"../../../geometry/Polygon.js";const P=Math.PI/180;function b(e,t){if(!e)return Promise.resolve([]);const a=t.feature;let r=a.attributes;return r instanceof x||(r=x.fromJSON(a),r&&(a.attributes=r)),M(e,t)}function M(e,t){const{attributes:a}=t.feature;return a.isSpherical||360===a.horizontalFieldOfView?[]:S(e,t)}async function S(e,t){const{feature:a,imageProperties:x}=t,{attributes:z}=a;let p=new r(z.location);if(4===z.cameraOrientation?.type){const e=z.cameraOrientation;p=new r(o(p,[e.latitude,e.longitude,e.ellipsoidRadius,e.squaredEccentricity]))}let m=!1;p.spatialReference.isWGS84&&(m=!0,p=i(p));const u=p.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*p.y/6378137))):1,R=d(t,p,u),w=4===z.cameraOrientation?.type?R.map((e=>s(new r(e)))):R,h=await c(w,t,!0),P=await Promise.all(h);P.forEach((e=>{e.z=1,e.x=e.x*x.pixelSize.x+x.extent.xmin,e.y=x.extent.ymax-e.y*x.pixelSize.y}));const b=l(z.horizontalFieldOfView,z.verticalFieldOfView,z.cameraRoll??0).vfov;return Promise.all(e.map((async e=>{e.z=1;let a,i=f(e,P,w);if(a=4===z.cameraOrientation?.type?(await c([s(new r({...i,spatialReference:p.spatialReference}))],t,!0))[0]:(await c([new r({...i,spatialReference:p.spatialReference})],t,!0))[0],!a)return null;a.x=a.x*x.pixelSize.x+x.extent.xmin,a.y=x.extent.ymax-a.y*x.pixelSize.y;let o,l=Math.abs(e.x-a.x)+Math.abs(e.y-a.y);if(l>1){const r=await H(e,a,P,w,p,i,t);i=r.point,l=r.error}if(z.elevationSource){let a=await v(t);if(a?.extent){let l=F(a,p,i);if(!l)return null;const f={x:l.x,y:l.y,z:l.z,hasZ:!0,spatialReference:p.spatialReference},R=new r(f);if(l){const f=n(R,t.currentCoveragePolygon.geometry?.spatialReference),w=y([f],t,!1);let h;h=w instanceof Promise?await w:w,R.z=l.z=h[0].z;const P=await c([4===z.cameraOrientation?.type?s(R):R],t);if(!P[0])return null;P[0].x=P[0].x*x.pixelSize.x+x.extent.xmin,P[0].y=x.extent.ymax-P[0].y*x.pixelSize.y;let M=Math.abs(e.x-P[0].x)+Math.abs(e.y-P[0].y);if(o=l.z,M>1){let f=0;const R=async w=>{if(M>1){const h=w.width/10,P=w.height/10;if(!w||h<1||P<1)return i=O(i,p,u,o,z.cameraPitch,b,m),i;const S=[{x:l.x-h,y:l.y-P,spatialReference:p.spatialReference},{x:l.x+h,y:l.y-P,spatialReference:p.spatialReference},{x:l.x+h,y:l.y+P,spatialReference:p.spatialReference},{x:l.x-h,y:l.y+P,spatialReference:p.spatialReference}].map((e=>new r(e))),d=await y(S,t,!1);if(a=new g({rings:[[[d[0].x,d[0].y,d[0].z],[d[1].x,d[1].y,d[1].z],[d[2].x,d[2].y,d[2].z],[d[3].x,d[3].y,d[3].z],[d[0].x,d[0].y,d[0].z]]],spatialReference:p.spatialReference}),l=F(a,p,i),l){const y=n(new r({x:l.x,y:l.y,z:l.z,spatialReference:p.spatialReference}),t.currentCoveragePolygon.geometry?.spatialReference),w=await c([4===z.cameraOrientation?.type?s(y):y],t);if(w[0])return w[0].x=w[0].x*x.pixelSize.x+x.extent.xmin,w[0].y=x.extent.ymax-w[0].y*x.pixelSize.y,M=Math.abs(e.x-w[0].x)+Math.abs(e.y-w[0].y),o=l.z,M<=1||8===f?O(i,p,u,o,z.cameraPitch,b,m):(f+=1,R(a.extent))}return O(i,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)}return O(i,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)};return R(a.extent)}return O(i,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)}return O(i,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)}}return O(i,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)})))}function O(a,n,i,x,c,y,o){const l=Math.sqrt((a.z-n.z)**2+(Math.sqrt((a.x-n.x)**2+(a.y-n.y)**2)/i)**2)*i,f=z(t(e(),[a.x,a.y,a.z],[n.x,n.y,n.z]),1/l,1/i);if(a.z<x||c+y/2<90){const e=Math.abs((n.z-x)/-f[2])*i,t=p([n.x,n.y,n.z],f,e,i);a={x:t[0],y:t[1],z:t[2]}}else a.z=x;return a.spatialReference=n.spatialReference,a=new r(a),o&&(a=s(a)),a}function d(n,i,s){const{feature:x}=n,{attributes:c}=x,y=2*Math.tan(c.verticalFieldOfView*P/2)*c.farDistance*s,o=2*Math.tan(c.horizontalFieldOfView*P/2)*c.farDistance*s,l=m("HPR",[c.cameraHeading,c.cameraPitch,c.cameraRoll??0]),f=u([0,0,-1],l),R=p([i.x,i.y,i.z],f,c.farDistance*s,s),w=u([0,1,0],l),h=u([1,0,0],l),g=z(w,y/2,s),b=z(h,o/2,s),M=t(e(),g,b),S=a(e(),g,b);return[a(e(),R,M),a(e(),R,S),t(e(),R,M),t(e(),R,S)].map((e=>{const[t,a,n]=e;return new r({x:t,y:a,z:n,spatialReference:i.spatialReference})}))}function v(e){const{feature:t}=e,a=j(e);if(!a)return Promise.resolve(null);const r=t.attributes.location.spatialReference.isWGS84?new h({wkid:102100}):t.attributes.location.spatialReference;return y(a,e,!1).then((e=>{const t=e.map((e=>n(e,r)));return new g({hasZ:!0,rings:[t.map((e=>[e.x,e.y,e.z]))],spatialReference:r})}))}function j(e){if(!e.currentCoveragePolygon.geometry)return null;const{xmin:t,xmax:a,ymin:n,ymax:i,spatialReference:s}=e.currentCoveragePolygon.geometry.extent.toJSON();return[new r({x:t,y:i,spatialReference:s}),new r({x:a,y:i,spatialReference:s}),new r({x:a,y:n,spatialReference:s}),new r({x:t,y:n,spatialReference:s})]}async function H(e,t,a,n,i,x,y){const{feature:{attributes:o},imageProperties:l}=y;let f=Math.abs(e.x-t.x)+Math.abs(e.y-t.y);if(f>1)for(let z=0;z<9;z++)if(f>1){let t,p={x:e.x-f,y:e.y-f,z:1},m={x:e.x+f,y:e.y-f,z:1},u={x:e.x+f,y:e.y+f,z:1},w={x:e.x-f,y:e.y+f,z:1};p=R(p,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),m=R(m,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),u=R(u,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),w=R(w,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),p.spatialReference=i.spatialReference,m.spatialReference=i.spatialReference,u.spatialReference=i.spatialReference,w.spatialReference=i.spatialReference,t=4===o.cameraOrientation?.type?await c([s(new r(p)),s(new r(m)),s(new r(u)),s(new r(w))],y,!0):await c([new r(p),new r(m),new r(u),new r(w)],y,!0);const h=await Promise.all(t);h.forEach((e=>{e.z=0,e.x=e.x*l.pixelSize.x+l.extent.xmin,e.y=l.extent.ymax-e.y*l.pixelSize.y}));const g=R(e,h[0],h[1],h[2],h[3],p,m,u,w);let P;if(P=4===o.cameraOrientation?.type?(await c([s(new r({x:g.x,y:g.y,z:g.z,spatialReference:i.spatialReference}))],y,!0))[0]:(await c([new r({x:g.x,y:g.y,z:g.z,spatialReference:i.spatialReference})],y,!0))[0],f=Math.abs(e.x-P.x)+Math.abs(e.y-P.y),f<=1||8===z){x=g;break}}return{error:f,point:x}}function F(e,t,a){const r={x:e.rings[0][0][0],y:e.rings[0][0][1],z:e.rings[0][0][2]},n={x:e.rings[0][1][0],y:e.rings[0][1][1],z:e.rings[0][1][2]},i={x:e.rings[0][1][0],y:e.rings[0][1][1],z:e.rings[0][1][2]},s={x:e.rings[0][2][0],y:e.rings[0][2][1],z:e.rings[0][2][2]},x=(s.z-i.z)*(n.y-r.y)-(s.y-i.y)*(n.z-r.z),c=-((s.z-i.z)*(n.x-r.x)-(n.z-r.z)*(s.x-i.x)),y=(s.y-i.y)*(n.x-r.x)-(n.y-r.y)*(s.x-i.x),o=-(x*r.x+c*r.y+y*r.z);return w(t.toJSON(),a,x,c,y,o)}export{b as transformPoints};
