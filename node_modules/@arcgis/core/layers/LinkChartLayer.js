/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import"../geometry.js";import t from"../core/Collection.js";import a from"../core/Error.js";import i from"../core/Logger.js";import{throwIfAborted as o}from"../core/promiseUtils.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import"../core/accessorSupport/ensureType.js";import"../core/arrayUtils.js";import"../core/has.js";import{subclass as s}from"../core/accessorSupport/decorators/subclass.js";import{encodeGeohash as r}from"../geohash/geohashUtils.js";import h from"./Layer.js";import{convertFromGeometry as l}from"./graphics/featureConversionUtils.js";import c from"./graphics/OptimizedGeometry.js";import{KnowledgeGraphLayerDataManager as d,mockOidFieldName as p,mockOriginIdFieldName as u,mockDestinationIdFieldName as y,mockLayoutGeometryFieldName as m,geohashEncodingPrecision as f}from"./knowledgeGraph/KnowledgeGraphLayerDataManager.js";import g from"./knowledgeGraph/KnowledgeGraphSublayer.js";import{getRelationshipEndNodeIds as k}from"./knowledgeGraph/supportUtils.js";import{BlendLayer as C}from"./mixins/BlendLayer.js";import{ScaleRangeLayer as L}from"./mixins/ScaleRangeLayer.js";import{LCSimpleLayout as M,LCSmartTreeLayout as b,LCRadialTreeLayout as w,LCHierarchicalLayout as x,LCCommunityLayout as D,LCForceDirectedLayout as E,NodeFlag as T,load as G}from"../libs/linkchartlayout/LinkChartLayout.js";import{fetchKnowledgeGraph as N}from"../rest/knowledgeGraphService.js";import I from"../rest/knowledgeGraph/EntityType.js";import R from"../rest/knowledgeGraph/RelationshipType.js";import _ from"../geometry/Extent.js";import A from"../geometry/Point.js";import v from"../geometry/Polyline.js";const S=(e,t,a)=>(e.has(t)||e.set(t,a()),e.get(t));let j=class extends(C(L(h))){constructor(e){if(super(e),this.dataPreloadedInLocalCache=!1,this.defaultLinkChartConfig=null,this._currentLinkChartConfig={layoutMode:"RADIAL_TREE",xScaleFactor:1,yScaleFactor:1},this._graphTypeLookup=new Map,this.knowledgeGraph=null,this.layers=new t,this.linkChartDiagramLookup=new Map,this.linkChartExtent=new _({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7}),this.linkChartGeohashLookup=new Map,this.memberEntityTypes=null,this.memberRelationshipTypes=null,this.sublayerIdsCache=new Map,this.tables=new t,this.type="link-chart",this._originalInclusionList=e.inclusionModeDefinition,e.dataPreloadedInLocalCache&&!e.inclusionModeDefinition)throw new a("knowledge-graph:linkchart-layer-constructor","If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it")}normalizeCtorArgs(e){return{url:e.url,title:e.title,dataPreloadedInLocalCache:e.dataPreloadedInLocalCache,defaultLinkChartConfig:e.defaultLinkChartConfig}}_initializeLayerProperties(e){if(!this.title&&this.url){const e=this.url.split("/");this.title=e[e.length-2]}const t=new Set;let o=[],n=[];if(e.inclusionModeDefinition&&(!e.inclusionModeDefinition.namedTypeDefinitions||e.inclusionModeDefinition.namedTypeDefinitions.size<1))throw new a("knowledge-graph:composite-layer-constructor","If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");e.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&this._graphTypeLookup.set(e.name,e)})),e.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&this._graphTypeLookup.set(e.name,e)})),e.inclusionModeDefinition?.generateAllSublayers?(o=e.knowledgeGraph.dataModel.entityTypes??[],n=e.knowledgeGraph.dataModel.relationshipTypes??[]):e.inclusionModeDefinition?.namedTypeDefinitions&&e.inclusionModeDefinition?.namedTypeDefinitions.size>0?e.inclusionModeDefinition?.namedTypeDefinitions.forEach(((a,s)=>{if(!this._graphTypeLookup.get(s))return i.getLogger(this).warn(`A named type, ${s}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(s);this._graphTypeLookup.get(s)instanceof R||"strictOrigin"in this._graphTypeLookup.get(s)?t.has(s)||(t.add(s),n.push(this._graphTypeLookup.get(s))):this._graphTypeLookup.get(s)instanceof I||"properties"in this._graphTypeLookup.get(s)?t.has(s)||(t.add(s),o.push(this._graphTypeLookup.get(s))):(i.getLogger(this).warn(`A named type, ${s}, was in the inclusion list that wasn't properly modeled and will be removed`),e.inclusionModeDefinition?.namedTypeDefinitions.delete(s))})):(o=e.knowledgeGraph.dataModel.entityTypes??[],n=e.knowledgeGraph.dataModel.relationshipTypes??[]);const s=new d({knowledgeGraph:e.knowledgeGraph,inclusionModeDefinition:e.inclusionModeDefinition});this.knowledgeGraph=e.knowledgeGraph,this.memberEntityTypes=o,this.memberRelationshipTypes=n,this.dataManager=s}load(e){return this.addResolvingPromise(new Promise((t=>{N(this.url).then((a=>{if(this._initializeLayerProperties({knowledgeGraph:a,inclusionModeDefinition:this._originalInclusionList}),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size||(this.dataManager.inclusionModeDefinition={generateAllSublayers:!1,namedTypeDefinitions:new Map},this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e.name,{useAllData:!0})})),this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e.name,{useAllData:!0})}))),this.dataPreloadedInLocalCache)this.loadLayerAssumingLocalCache(),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e=>{e.useAllData=!1,e.members?.forEach((e=>{let t;t=e.linkChartLocation instanceof c?e.linkChartLocation:e.linkChartLocation?l(e.linkChartLocation):null,this.linkChartDiagramLookup.set(e.id,t),t&&2===t.coords.length&&0===t.lengths.length?this.linkChartGeohashLookup.set(e.id,r(t.coords[1],t.coords[0],f)):this.linkChartGeohashLookup.set(e.id,"")})),this.addResolvingPromise(this._initializeDiagram().then((async()=>{this.layers.forEach((async e=>{await e.refreshCachedQueryEngine()})),this.tables.forEach((async e=>{await e.refreshCachedQueryEngine()}))})))}));else{const t="GEOGRAPHIC"===this.defaultLinkChartConfig?.layoutMode;this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0,!1,t,!0).then((async()=>{o(e);const t=[],a=[];this.loadLayerAssumingLocalCache(),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1,this.dataManager.inclusionModeDefinition.namedTypeDefinitions.forEach((e=>{e.useAllData=!1}))),await this._initializeDiagram(),this.layers.forEach((e=>{a.push(e.refreshCachedQueryEngine()),t.push(new Promise((t=>{e.on("layerview-create",(()=>{t(null)}))})))})),this.tables.forEach((e=>{a.push(e.refreshCachedQueryEngine())})),await Promise.all(a)})))}t(null)}))}))),Promise.resolve(this)}async addRecords(e,t){let a=[];t?.cascadeAddRelationshipEndNodes&&this.dataManager.knowledgeGraph.dataModel&&(a=await k(e,this.dataManager.knowledgeGraph));const i=e.concat(a).filter((e=>!this.sublayerIdsCache.get(e.typeName)?.has(e.id)));await this._handleNewRecords(i)}async removeRecords(e,{cascadeRemoveRelationships:t=!0,recalculateLayout:a=!1}={cascadeRemoveRelationships:!0,recalculateLayout:!1}){let i=[];for(const n of e)!1===this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(n.typeName)?.useAllData&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(n.typeName)?.members?.has(n.id)&&i.push(n);if(t){const e=new Set,t=[];for(const a of i)if(this.dataManager.nodeConnectionsLookup.has(a.id))for(const t of this.dataManager.nodeConnectionsLookup.get(a.id))e.add(t);for(const a of e)this.dataManager.memberIdTypeLookup.has(a)&&t.push({id:a,typeName:this.dataManager.memberIdTypeLookup.get(a)});i=i.concat(t)}this.dataManager.removeFromLayer(i);for(const n of i)this.sublayerIdsCache.get(n.typeName)?.delete(n.id),this.linkChartDiagramLookup.delete(n.id);a&&await this.calculateLinkChartLayout(this._currentLinkChartConfig.layoutMode,{xScaleFactor:this._currentLinkChartConfig.xScaleFactor,yScaleFactor:this._currentLinkChartConfig.xScaleFactor});const o=[];return this.layers.forEach((e=>{o.push(e.refreshCachedQueryEngine())})),await Promise.all(o),this._refreshNamedTypes(),i}async expand(e){const t=await this.dataManager.getConnectedRecordIds(e),a=t.filter((e=>!this.sublayerIdsCache.get(e.typeName)?.has(e.id)));return await this._handleNewRecords(t),{records:a}}loadLayerAssumingLocalCache(){this.memberRelationshipTypes.forEach((e=>{const t=new g({objectType:e,parentCompositeLayer:this,graphType:"relationship",title:e.name});t.geometryType?this.layers.push(t):this.tables.push(t),this.dataManager.sublayerCaches.has(e.name)||this.dataManager.sublayerCaches.set(e.name,new Map)})),this.memberEntityTypes.forEach((e=>{const t=new g({objectType:e,parentCompositeLayer:this,graphType:"entity",title:e.name});t.geometryType?this.layers.push(t):this.tables.push(t),this.dataManager.sublayerCaches.has(e.name)||this.dataManager.sublayerCaches.set(e.name,new Map)})),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{const a=S(this.sublayerIdsCache,t,(()=>new Set));e.members?.forEach((e=>{if(a.add(e.id),e.linkChartLocation)if(e.linkChartLocation instanceof c)this.linkChartDiagramLookup.set(e.id,e.linkChartLocation),2===e.linkChartLocation.coords.length&&0===e.linkChartLocation.lengths.length?this.linkChartGeohashLookup.set(e.id,r(e.linkChartLocation.coords[1],e.linkChartLocation.coords[0],f)):this.linkChartGeohashLookup.set(e.id,"");else{const t=l(e.linkChartLocation);this.linkChartDiagramLookup.set(e.id,e.linkChartLocation?t:null),"x"in e.linkChartLocation&&"y"in e.linkChartLocation?this.linkChartGeohashLookup.set(e.id,r(e.linkChartLocation.x,e.linkChartLocation.y,f)):this.linkChartGeohashLookup.set(e.id,"")}}))}))}async calculateLinkChartLayout(e="RADIAL_TREE",t){const o=[],n=[];this.dataManager.sublayerCaches.forEach(((e,t)=>{this.dataManager.entityTypeNames.has(t)?e.forEach((e=>{o.push({typeName:t,feature:e})})):this.dataManager.relationshipTypeNames.has(t)&&e.forEach((e=>{n.push({typeName:t,feature:e})}))})),this.linkChartDiagramLookup=new Map;const s=new Map,h=new Map,c=new Map,d=new Map,g=new Uint8Array(o.length),k=new Float64Array(o.length),C=new Float64Array(o.length),L=new Uint32Array(n.length),N=new Uint32Array(n.length),I=[],R="FORCE_DIRECTED",S=t?.xScaleFactor??1,j=t?.yScaleFactor??1,P=new _({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7});let F,z="FORCE_DIRECTED",O=0,U=0;switch(z="GEOGRAPHIC"===e?R:e,z){case"FORCE_DIRECTED":F=E.apply;break;case"COMMUNITY":F=D.apply;break;case"HIERARCHICAL":F=x.apply;break;case"RADIAL_TREE":F=w.apply;break;case"SMART_TREE":F=b.apply;break;default:F=M.apply}o.forEach((({typeName:a,feature:i})=>{if(t?.lockedNodeLocations?.has(i.attributes[p])){"GEOGRAPHIC"===e&&this.dataManager.geographicLookup.has(a)?g[O]=T.IsGeographic:g[O]=T.None;const o=t.lockedNodeLocations.get(i.attributes[p]);k[O]=o.x,C[O]=o.y}else if("GEOGRAPHIC"===e&&this.dataManager.geographicLookup.has(a)){g[O]=T.IsGeographic;let e=null;const t=i.attributes[this.dataManager.geographicLookup.get(a).name],o=this.dataManager.geographicLookup.get(a)?.geometryType;switch(o){case"esriGeometryPoint":k[O]=t?.x,C[O]=t?.y;break;case"esriGeometryPolygon":e=t?.centroid,null!=e?.x&&null!=e?.y?(k[O]=e.x,C[O]=e.y):g[O]=T.IsMovable;break;case"esriGeometryPolyline":case"esriGeometryMultipoint":e=t?.extent?.center,null!=e?.x&&null!=e?.y?(k[O]=e.x,C[O]=e.y):g[O]=T.IsMovable;break;default:g[O]=T.IsMovable}(null==k[O]||null==C[O]||Number.isNaN(k[O])||Number.isNaN(C[O]))&&(g[O]=T.IsMovable,k[O]=0,C[O]=0)}else g[O]=T.IsMovable,k[O]=0,C[O]=0;d.set(i.attributes[p],O),I[O]={feature:i,typeName:a},O++}));let Q=!1;n.forEach((e=>{const t=d.get(e.feature.attributes[u]),a=d.get(e.feature.attributes[y]);void 0!==t&&void 0!==a?(L[U]=t,N[U]=a,U++):(Q=!0,this.linkChartDiagramLookup.set(e.feature.attributes[u],null),this.linkChartGeohashLookup.set(e.feature.attributes[u],null))})),Q&&i.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null"),await G();if(!F(g,k,C,L,N))throw new a("knowledge-graph:layout-failed","Attempting to arrange the records in the specified layout failed");for(let a=0;a<I.length;a++){if(g[a]===T.IsMovable&&(k[a]=k[a]*S,C[a]=C[a]*j),C[a]>84.9999&&(C[a]=84.9999),C[a]<-84.9999&&(C[a]=-84.9999),k[a]>179.9999&&(k[a]=179.9999),k[a]<-179.9999&&(k[a]=-179.9999),I[a].feature.attributes[m]=new A(k[a],C[a]),s.has(I[a].typeName)){const e=s.get(I[a].typeName);e?.set(I[a].feature.attributes[p],I[a].feature)}else{const e=new Map;e.set(I[a].feature.attributes[p],I[a].feature),s.set(I[a].typeName,e)}c.set(I[a].feature.attributes[p],I[a].feature);const e=l(I[a].feature.attributes[m]);this.linkChartDiagramLookup.set(I[a].feature.attributes[p],I[a].feature.attributes[m]?e:null),this.linkChartGeohashLookup.set(I[a].feature.attributes[p],r(I[a].feature.attributes[m].y,I[a].feature.attributes[m].x,f)),I[a].feature.attributes[m].x<P.xmin&&(P.xmin=I[a].feature.attributes[m].x),I[a].feature.attributes[m].x>P.xmax&&(P.xmax=I[a].feature.attributes[m].x),I[a].feature.attributes[m].y<P.ymin&&(P.ymin=I[a].feature.attributes[m].y),I[a].feature.attributes[m].y>P.ymax&&(P.ymax=I[a].feature.attributes[m].y)}return this.linkChartExtent.xmin=P.xmin,this.linkChartExtent.xmax=P.xmax,this.linkChartExtent.ymin=P.ymin,this.linkChartExtent.ymax=P.ymax,n.forEach((e=>{const t=I[d.get(e.feature.attributes[u])]?.feature.attributes[m],a=I[d.get(e.feature.attributes[y])]?.feature.attributes[m];if(!t||!a)return;const i=new v({paths:[[t.x,t.y],[a.x,a.y]]});if(e.feature.attributes[m]=i,h.has(e.typeName)){const t=h.get(e.typeName);t?.set(e.feature.attributes[p],e.feature)}else{const t=new Map;t.set(e.feature.attributes[p],e.feature),h.set(e.typeName,t)}c.set(e.feature.attributes[p],e.feature);const o=l(e.feature.attributes[m]);this.linkChartDiagramLookup.set(e.feature.attributes[p],e.feature.attributes[m]?o:null),this.linkChartGeohashLookup.set(e.feature.attributes[p],"")})),this._currentLinkChartConfig={layoutMode:e,xScaleFactor:S,yScaleFactor:j},{nodes:s,links:h,idMap:c}}async applyNewLinkChartLayout(e="RADIAL_TREE",t){const a=[];await this.calculateLinkChartLayout(e,t),this.layers.forEach((e=>{a.push(e.refreshCachedQueryEngine())})),await Promise.all(a),this._refreshNamedTypes()}getCurrentNodeLocations(){const e=new Map;return this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((t=>{t?.members?.forEach((t=>{const a=t.linkChartLocation;let i;const o=t.id;a&&(i="x"in a?{x:a.x,y:a.y}:{x:a.coords[0],y:a.coords[1]},e.set(o,new A({x:i.x,y:i.y})))}))})),e}async synchronizeInclusionListWithCache(){return new Promise((e=>{this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{if(e.useAllData=!1,e.members&&e.members.size>0){if(!this.dataManager.sublayerCaches.get(t))return;const a=new Set(Array.from(this.dataManager.sublayerCaches.get(t).keys()));Array.from(e.members.keys()).filter((e=>!a.has(e))).forEach((t=>{e.members?.delete(t)}))}})),e()}))}async refreshLinkChartCache(e){await this.dataManager.refreshCacheContent(e);const t=[];this.layers.forEach((e=>{t.push(e.refreshCachedQueryEngine())})),await Promise.all(t),this._refreshNamedTypes()}async _handleNewRecords(e){const t=[];this.dataManager.addToLayer(e);for(const a of e)this.sublayerIdsCache.has(a.typeName)||(this.sublayerIdsCache.set(a.typeName,new Set),t.push(a.typeName)),this.sublayerIdsCache.get(a.typeName).add(a.id);for(const a of t)if(this._graphTypeLookup.has(a)){const e=this._graphTypeLookup.get(a),t="endPoints"in e?"relationship":"entity",i=new g({objectType:e,parentCompositeLayer:this,graphType:t,title:a});"entity"===t?this.dataManager.entityTypeNames.add(a):this.dataManager.relationshipTypeNames.add(a),i.geometryType?this.layers.push(i):this.tables.push(i),this.dataManager.sublayerCaches.set(a,new Map)}await this.dataManager.refreshCacheContent(e.map((e=>e.id))),await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode,{xScaleFactor:this._currentLinkChartConfig.xScaleFactor,yScaleFactor:this._currentLinkChartConfig.xScaleFactor})}async _initializeDiagram(){this.defaultLinkChartConfig?this.defaultLinkChartConfig.doNotRecalculateLayout?(this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e=>{e?.members?.forEach((e=>{const t=e.linkChartLocation;let a;const i=e.id;if(!t)return;a="x"in t?{x:t.x,y:t.y}:{x:t.coords[0],y:t.coords[1]};const o=l(a);this.linkChartDiagramLookup.set(i,o),this.linkChartGeohashLookup.set(i,r(a.x,a.y,f)),this.linkChartExtent.xmin>a.x&&(this.linkChartExtent.xmin=a.x),this.linkChartExtent.xmax<a.x&&(this.linkChartExtent.xmax=a.x),this.linkChartExtent.ymin>a.y&&(this.linkChartExtent.ymin=a.y),this.linkChartExtent.ymax<a.y&&(this.linkChartExtent.ymax=a.y)}))})),this.memberRelationshipTypes.forEach((e=>{e.name&&this.dataManager.sublayerCaches.get(e.name)?.forEach((e=>{const t=this.linkChartDiagramLookup.get(e.attributes[u]),a=this.linkChartDiagramLookup.get(e.attributes[y]);if(t&&a){const i=l(new v({paths:[[t.coords[0],t.coords[1]],[a.coords[0],a.coords[1]]]}));this.linkChartDiagramLookup.set(e.attributes[p],i)}else this.linkChartDiagramLookup.set(e.attributes[p],null);this.linkChartGeohashLookup.set(e.attributes[p],"")}))}))):await this.calculateLinkChartLayout(this.defaultLinkChartConfig.layoutMode,{xScaleFactor:this.defaultLinkChartConfig.xScaleFactor,yScaleFactor:this.defaultLinkChartConfig.yScaleFactor,lockedNodeLocations:this.getCurrentNodeLocations()}):await this.calculateLinkChartLayout("RADIAL_TREE",{lockedNodeLocations:this.getCurrentNodeLocations()})}_refreshNamedTypes(){for(const e of this.layers)e.emit("refresh",{dataChanged:!0});for(const e of this.tables)e.emit("refresh",{dataChanged:!0})}};e([n()],j.prototype,"dataPreloadedInLocalCache",void 0),e([n()],j.prototype,"defaultLinkChartConfig",void 0),e([n()],j.prototype,"dataManager",void 0),e([n()],j.prototype,"knowledgeGraph",void 0),e([n()],j.prototype,"layers",void 0),e([n()],j.prototype,"linkChartDiagramLookup",void 0),e([n()],j.prototype,"linkChartExtent",void 0),e([n()],j.prototype,"linkChartGeohashLookup",void 0),e([n()],j.prototype,"memberEntityTypes",void 0),e([n()],j.prototype,"memberRelationshipTypes",void 0),e([n()],j.prototype,"sublayerIdsCache",void 0),e([n()],j.prototype,"tables",void 0),e([n({json:{read:!1}})],j.prototype,"type",void 0),j=e([s("esri.layers.LinkChartLayer")],j);const P=j;export{P as default};
