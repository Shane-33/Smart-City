/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{id as r}from"../../kernel.js";import e from"../../request.js";import n from"../../core/Error.js";import{throwIfAbortError as t}from"../../core/promiseUtils.js";import{parse as o}from"./arcgisLayerUrl.js";import a from"../../portal/Portal.js";import i from"../../portal/PortalItem.js";async function l(r,e){const t=o(r);if(!t)throw new n("invalid-url","Invalid scene service url");const a={...e,sceneServerUrl:t.url.path,layerId:t.sublayer??void 0};if(a.sceneLayerItem??=await s(a),null==a.sceneLayerItem)return f(a.sceneServerUrl.replace("/SceneServer","/FeatureServer"),a);const i=await y(a);if(!i?.url)throw new n("related-service-not-found","Could not find feature service through portal item relationship");const l=await f(i.url,a);return l.portalItem=i,l}async function s(r){const e=(await c(r)).serviceItemId;if(!e)return null;const n=new i({id:e,apiKey:r.apiKey}),o=await u(r);null!=o&&(n.portal=new a({url:o}));try{return n.load({signal:r.signal})}catch(l){return t(l),null}}async function c(r){if(r.rootDocument)return r.rootDocument;const n={query:{f:"json",token:r.apiKey},responseType:"json",signal:r.signal};try{const t=await e(r.sceneServerUrl,n);r.rootDocument=t.data}catch{r.rootDocument={}}return r.rootDocument}async function u(n){const o=r?.findServerInfo(n.sceneServerUrl);if(o?.owningSystemUrl)return o.owningSystemUrl;const a=n.sceneServerUrl.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const r=(await e(a,{query:{f:"json"},responseType:"json",signal:n.signal})).data.owningSystemUrl;if(r)return r}catch(i){t(i)}return null}async function f(r,t){const a=o(r);if(!a)throw new n("invalid-feature-service-url","Invalid feature service url");const i=a.url.path,l=t.layerId;if(null==l)return{serverUrl:i};const s=c(t),u=r=>{const n={query:{f:"json"},responseType:"json",authMode:r,signal:t.signal};return e(i,n)},f=u("anonymous").catch((()=>u("no-prompt"))),[y,m]=await Promise.all([f,s]),p=m?.layers,d=y.data&&y.data.layers;if(!Array.isArray(d))throw new Error("expected layers array");if(Array.isArray(p))for(let e=0;e<Math.min(p.length,d.length);e++){if(p[e].id===l)return{serverUrl:i,layerId:d[e].id}}else if(null!=l&&l<d.length)return{serverUrl:i,layerId:d[l].id};throw new Error("could not find matching associated sublayer")}async function y({sceneLayerItem:r,signal:e}){if(!r)return null;try{const n=(await r.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:e})).find((r=>"Feature Service"===r.type))||null;if(!n)return null;const t=new i({portal:n.portal,id:n.id});return await t.load(),t}catch(n){return t(n),null}}export{l as findAssociatedFeatureService};
