/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../request.js";import i from"../../../core/Error.js";import{JSONSupport as o}from"../../../core/JSONSupport.js";import r from"../../../core/Logger.js";import{EsriPromiseMixin as n}from"../../../core/Promise.js";import{onAbort as s}from"../../../core/promiseUtils.js";import{property as l}from"../../../core/accessorSupport/decorators/property.js";import{ensureClass as a}from"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import{subclass as c}from"../../../core/accessorSupport/decorators/subclass.js";import{sanitizeUrl as m}from"../arcgisLayerUrl.js";import{url as f}from"../commonProperties.js";import u from"../DimensionalDefinition.js";import h from"../LOD.js";import p from"../RasterStorageInfo.js";import d from"../TileInfo.js";import{isMultiSliceOrRangeDefinition as x,getSliceIndex as y,createSlices as g,getSliceIds as I}from"./multidimensionalUtils.js";import{getRasterId as R,getBlock as w,putBlock as S,deleteBlock as k,decreaseRefCount as T}from"./RawBlockCache.js";import{convertNoDataToMask as b}from"../rasterFormats/pixelRangeUtils.js";import{decode as v}from"../rasterFormats/RasterCodec.js";import{mosaic as P,approximateTransform as B,getLocalArithmeticNorthRotations as M}from"../rasterFunctions/pixelUtils.js";import{load as _,getWorldWidth as W,projectPoint as C,snapPyramid as j,shiftExtent as H,getWorldWrapCount as z,projectExtent as L,getProjectionOffsetGrid as E,getRasterDatasetAlignmentInfo as D,projectResolution as F}from"../rasterFunctions/rasterProjectionHelper.js";import{convertToLocalDirections as O,uvComponentToVector as A}from"../rasterFunctions/vectorFieldUtils.js";import G from"../../../geometry/Extent.js";import q from"../../../geometry/Point.js";const J=8,N=256;let V=class extends(n(o)){constructor(){super(...arguments),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=_();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:d.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=W(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}set url(e){this._set("url",m(e,r.getLogger(this)))}async open(e){throw new i("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,i,o={}){const r=o.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,t,i,r);return this.fetchPixels(n,r.size[0],r.size[1],o)}async identify(e,t={}){e=a(q,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:o}=t,{rasterInfo:r}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:s}=r;let{transposedVariableName:l}=t;const c=null!=s&&n&&(null!=o||x(i));if(c&&!l){l=null!=i&&i.length>0?i[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:l}}t=this._getRequestOptionsWithSliceId(t);const{spatialReference:m,extent:f}=r,{datumTransformation:u}=t;let h=C(e,m,u);if(!f.intersects(h))return{location:h,value:null};if(null!=r.transform){const e=r.transform.inverseTransform(h);if(!r.nativeExtent.intersects(e))return{location:e,value:null};h=e}let p=0;const d=null!=l&&null!=s&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(d)return e.identify(h,t);const{pixelSize:i}=r,o=3,n=i.x*o/2,s=i.y*o/2,l=new G({xmin:h.x-n,xmax:h.x+n,ymin:h.y-s,ymax:h.y+s,spatialReference:m}),a={interpolation:"nearest"},{pixelBlock:c}=await e.fetchPixels(l,o,o,a),{pixelBlock:f}=await this.fetchPixels(l,o,o,a);if(null==c)return{location:h,value:null};const u=Math.floor(o*o*.5),p=!c.mask||c.mask[u]?c.pixels.map((e=>e[u])):null;let x;return null!=f&&(x=!f.mask||f.mask[u]?f.pixels.map((e=>e[u])):void 0),{location:h,value:p,processedValue:x,pyramidLevel:0}}if(!d)if(t.srcResolution){p=j(t.srcResolution,r,this.ioConfig.sampling).pyramidLevel}else if(p=await this.computeBestPyramidLevelForLocation(e,t),null==p)return{location:h,value:null};const y=this.identifyPixelLocation(h,p,null,d);if(null===y)return{location:h,value:null};const{row:g,col:I,rowOffset:k,colOffset:T,blockWidth:b}=y,v=l??t.sliceId,P=R(this.url,v),B=`${p}/${g}/${I}`;let M=w(P,null,B);null==M&&(M=this.fetchRawTile(p,g,I,t),S(P,null,B,M));const _=await M;if(!_?.pixels?.length)return{location:h,value:null};const W=k*b+T;return this._processIdentifyResult(_,{srcLocation:h,position:W,pyramidLevel:p,useTransposedTile:!!d,requestSomeSlices:c,identifyOptions:t})}async fetchPixels(e,t,i,o={}){e=H(e),o=this._getRequestOptionsWithSliceId(o);const{_hasNoneOrGCSShiftTransform:r}=this;if(o.requestRawData&&r)return this._fetchPixels(e,t,i,o);const n=W(e.spatialReference),s=z(e);if(null==n||0===s||1===s&&this._isGlobalWrappableSource&&r)return this._fetchPixels(e,t,i,o);if(s>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:a,xmax:c}=e,m=Math.round(n/(c-a)*t),f=m-Math.round((n/2-a)/(c-a)*t);let u=0;const h=[];for(let y=0;y<=s;y++){const r=new G({xmin:0===y?a:-n/2,xmax:y===s?c-n*y:n/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===y?m-f:y===s?t-u:m;u+=p,h.push(p);const d=o.disableWrapAround&&y>0?null:this._fetchPixels(r,p,i,o);l.push(d)}const p=(await Promise.all(l)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};if(this.rasterJobHandler){d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},o)).pixelBlock}else d=P(p,x,{blockWidths:h});return{extent:e,srcExtent:L(e,this.rasterInfo.spatialReference,o.datumTransformation),pixelBlock:d}}async fetchRawPixels(e,t,i,o={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const r=await this._fetchRawTiles(e,t,i,o),{nativeExtent:n,nativePixelSize:s,storageInfo:l}=this.rasterInfo,a=2**e,c=s.x*a,m=s.y*a,f=new G({xmin:n.xmin+c*t.x,xmax:n.xmin+c*(t.x+i.width-1),ymin:n.ymax-m*(t.y+i.height-1),ymax:n.ymax-m*t.y,spatialReference:n.spatialReference});if(!r)return{extent:f,srcExtent:f,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=r;if(1===u.length&&null!=u[0]&&u[0].width===i.width&&u[0].height===i.height)return{extent:f,srcExtent:f,pixelBlock:r.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,d=e>0?l.pyramidBlockHeight:l.blockHeight,x={x:t.x%p,y:t.y%d};let y;if(this.rasterJobHandler){y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:i,clipOffset:x,clipSize:i,coefs:null,sampleSpacing:null,interpolation:o.interpolation,alignmentInfo:null,blockWidths:null},o)).pixelBlock}else y=P(u,h,{clipOffset:x,clipSize:i});return{extent:f,srcExtent:f,pixelBlock:y}}fetchRawTile(e,t,o,r){throw new i("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return L(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?v(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,i,o=0){const{customFetchParameters:r}=this.ioConfig,{range:n,query:s,headers:l}=i;o=o??i.retryCount??this.ioConfig.retryCount;const a=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await t(e,{...i,query:{...s,...r},headers:{...l,...a}})}catch(c){if(o>0)return o--,this.request(e,i,o);throw c}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:y(e,t)}getTileExtentFromTileInfo(e,t,i,o){const r=o.lodAt(e);return this.getTileExtent({x:r.resolution,y:r.resolution},t,i,o.origin,o.spatialReference,o.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:o}=this.rasterInfo;if(!e.tileInfo){const r=[],n=e.maximumPyramidLevel||0;let s=Math.max(o.x,o.y),l=1/.0254*96*s;for(let e=0;e<=n;e++)r.unshift(new h({level:n-e,resolution:s,scale:l})),s*=2,l*=2;const a=new q({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new d({origin:a,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:r}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,o){const{width:r,height:n,nativeExtent:s,pixelSize:l,spatialReference:a}=e,c=new q({x:s.xmin,y:s.ymax,spatialReference:a});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(r,n))/Math.LN2-8)));const m=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],o);e.storageInfo=new p({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:m})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,o,r,n=0,s=2){if(1===r.length&&n>0){r=[...r];let{x:e,y:t}=r[0];for(let i=0;i<n;i++)e*=s,t*=s,r.push({x:e,y:t})}const l=[],{x:a,y:c}=o;for(let m=0;m<r.length;m++){const{x:o,y:n}=r[m];l.push({minCol:Math.floor((e.xmin-a+.1*o)/t/o),maxCol:Math.floor((e.xmax-a-.1*o)/t/o),minRow:Math.floor((c-e.ymax+.1*n)/i/n),maxRow:Math.floor((c-e.ymin-.1*n)/i/n)})}return l}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const r=o**e;return{x:t.x*r,y:t.y*r}}identifyPixelLocation(e,t,i,o){const{spatialReference:r,nativeExtent:n,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=s,m=o&&null!=c?c.tileSize[0]:s.blockWidth,f=o&&null!=c?c.tileSize[1]:s.blockHeight,u=C(e,r,i);if(!n.intersects(u))return null;if(t<0||t>l)return null;const h=this.getPyramidPixelSize(t),{x:p,y:d}=h,x=(a.y-u.y)/d/f,y=(u.x-a.x)/p/m,g=Math.min(f-1,Math.floor((x-Math.floor(x))*f)),I=Math.min(m-1,Math.floor((y-Math.floor(y))*m));return{pyramidLevel:t,row:Math.floor(x),col:Math.floor(y),rowOffset:g,colOffset:I,blockWidth:m,srcLocation:u}}getTileExtent(e,t,i,o,r,n){const[s,l]=n,a=o.x+i*s*e.x,c=a+s*e.x,m=o.y-t*l*e.y,f=m-l*e.y;return new G({xmin:a,xmax:c,ymin:f,ymax:m,spatialReference:r})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const o=this.rasterInfo.storageInfo.blockBoundary[e];return!o||o.maxRow<t||o.maxCol<i||o.minRow>t||o.minCol>i}async _fetchPixels(e,t,i,o={}){let r=z(e);if(r>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,t,i,o),{pyramidLevel:s,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:m,ul:f}=n;if(0===c||0===m)return{extent:e,srcExtent:a,pixelBlock:null};const{rasterInfo:u}=this,h=u.transform,p="gcs-shift"===h?.type,d=null!=W(e.spatialReference);!p&&d||(r=z(n.srcExtent,p));const x=await this._fetchRawTiles(s,f,{width:c,height:m,wrapCount:r},o);if(!x)return{extent:e,srcExtent:a,pixelBlock:null};const y=u.storageInfo,g=s>0?y.pyramidBlockWidth:y.blockWidth,I=s>0?y.pyramidBlockHeight:y.blockHeight;let{x:R,y:w}=u.pixelSize;if(s>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=y;if(null!=e&&e[s-1])({x:R,y:w}=e[s-1]);else{const e=t**s;R*=e,w*=e}}const S=u.spatialReference,k=new q({x:R,y:w,spatialReference:S}),T=g===c&&I===m&&f.x%g==0&&f.y%I==0,b=new q({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),v=!e.spatialReference.equals(S),C=S.isGeographic?1e-9:1e-4,{datumTransformation:j}=o;if(!v&&T&&1===x.pixelBlocks.length&&g===t&&I===i&&this._isSameResolution(l,b,C))return{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:x.pixelBlocks[0]};const H=d&&null!=W(a.spatialReference)&&this._hasNoneOrGCSShiftTransform,L=o.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");L&&!this.rasterJobHandler&&await _();const D=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:b.toJSON(),datumTransformation:j,rasterTransform:h,hasWrapAround:r>0||H,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:L},o):E({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:b,datumTransformation:j,rasterTransform:h,hasWrapAround:r>0||H,isAdaptive:!1,includeGCSGrid:L});let F;const A=!o.requestRawData,G={rows:D.spacing[0],cols:D.spacing[1]},J=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,x.extent.xmin):void 0,{pixelBlocks:N,mosaicSize:V,isPartiallyFilled:U}=x;let $=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:N,srcMosaicSize:V,destDimension:A?{width:t,height:i}:null,coefs:A?D.coefficients:null,sampleSpacing:A?G:null,projectDirections:L,gcsGrid:L?D.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:o.interpolation,alignmentInfo:J,blockWidths:null},o);({pixelBlock:F,localNorthDirections:$}=e)}else{const e=P(N,V,{alignmentInfo:J});F=A?B(e,{width:t,height:i},D.coefficients,G,o.interpolation):e,L&&D.gcsGrid&&($=M({width:t,height:i},D.gcsGrid),F=O(F,this.rasterInfo.dataType,$))}return o.requestRawData||L?{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:F,transformGrid:D,localNorthDirections:$,isPartiallyFilled:U}:{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:F}}async _fetchRawTiles(e,t,i,o){const{origin:r,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:a,y:c}=t,{width:m,height:f,wrapCount:u}=i;const h=this._getRasterTileAlignmentInfo(e,0);o.buffer&&(a-=o.buffer.cols,c-=o.buffer.rows,m+=2*o.buffer.cols,f+=2*o.buffer.rows);let p=0,d=0,x=0;if(u&&null!=h){({worldColumnCountFromOrigin:d,originColumnOffset:x,rightPadding:p}=h);d*h.blockWidth-p>=a+m&&(p=0)}const y=Math.floor(a/s),g=Math.floor(c/l),I=Math.floor((a+m+p-1)/s),R=Math.floor((c+f+p-1)/l),w=n[e];if(!w)return null;const{minRow:S,minCol:k,maxCol:T,maxRow:b}=w;if(0===u&&(R<S||I<k||g>b||y>T))return null;const v=new Array;let P=!1;const B=null==this.ioConfig.allowPartialFill?o.allowPartialFill:this.ioConfig.allowPartialFill;for(let z=g;z<=R;z++)for(let t=y;t<=I;t++){let i=t;if(!o.disableWrapAround&&u&&null!=h&&d<=t&&(i=t-d-x),z>=S&&i>=k&&b>=z&&T>=i){const t=this._fetchRawTile(e,z,i,o);B?v.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{P=!0,e(null)}))}))):v.push(t)}else v.push(Promise.resolve(null))}if(0===v.length)return null;const M=await Promise.all(v),_={height:(R-g+1)*l,width:(I-y+1)*s},{spatialReference:W}=this.rasterInfo,C=this.getPyramidPixelSize(e),{x:j,y:H}=C;return{extent:new G({xmin:r.x+y*s*j,xmax:r.x+(I+1)*s*j,ymin:r.y-(R+1)*l*H,ymax:r.y-g*l*H,spatialReference:W}),pixelBlocks:M,mosaicSize:_,isPartiallyFilled:P}}_isSameResolution(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i}_fetchRawTile(e,t,i,o){const r=this.rasterInfo.storageInfo.blockBoundary[e];if(!r)return Promise.resolve(null);const{minRow:n,minCol:l,maxCol:a,maxRow:c}=r;if(t<n||i<l||t>c||i>a)return Promise.resolve(null);const m=R(this.url,o.sliceId),f=`${e}/${t}/${i}`;let u=w(m,o.registryId,f);if(null==u){const r=new AbortController;u=this.fetchRawTile(e,t,i,{...o,signal:r.signal}),S(m,o.registryId,f,u,r),u.catch((()=>k(m,o.registryId,f)))}return o.signal&&s(o,(()=>{T(m,o.registryId,f)})),u}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if(!(2===t&&"vector-magdir"===i||"vector-uv"===i)||2!==e?.length||!e[0]?.length)return null;const o=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[r,n]=e,s=[],l=[];for(let a=0;a<o;a++){const[e,t]=A([r[a],n[a]]);s.push(e),l.push(t)}return[s,l]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=D(this.rasterInfo)),null==this._rasterTileAlighmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,o={}){const r={datumTransformation:o.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};o.srcResolution&&(r.srcResolution=o.srcResolution,this._updateSourceDataInfo(e,r));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:a}=r,c=s/t,m=l/i,f=a<n&&c*m>=16,u=a===n&&this._requireTooManySrcTiles(s,l,t,i);if(f||u||(0===s||0===l)){const s=new q({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=F(s,this.rasterInfo.spatialReference,e,r.datumTransformation);const u=!l||o.srcResolution&&l.x+l.y<o.srcResolution.x+o.srcResolution.y;if(f&&o.srcResolution&&u){const e=Math.round(Math.log(Math.max(c,m))/Math.LN2)-1;if(n-a+3>=e){const t=2**e;l={x:o.srcResolution.x*t,y:o.srcResolution.y*t}}}l&&(r.srcResolution=l,this._updateSourceDataInfo(e,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,t,i)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(e,t,i,o){const{tileInfo:r}=this.rasterInfo.storageInfo;return Math.ceil(e/r.size[0])*Math.ceil(t/r.size[1])>=N||e/i>J||t/o>J}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,o=i.spatialReference,{srcResolution:r,datumTransformation:n}=t,{pyramidLevel:s,pyramidResolution:l,excessiveReading:a}=j(r,i,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||L(e,o,n);if(null==c)return;const m=i.transform;m&&(c=m.inverseTransform(c)),t.srcExtent=c;const{x:f,y:u}=i.storageInfo.origin,h=Math.floor((c.xmin-f)/l.x+.1),p=Math.floor((u-c.ymax)/l.y+.1),d=Math.floor((c.xmax-f)/l.x-.1),x=Math.floor((u-c.ymin)/l.y-.1),y=c.width<.1*l.x?0:d-h+1,g=c.height<.1*l.y?0:x-p+1;t.pyramidLevel=s,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=g,t.ul={x:h,y:p}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:o,pyramidLevel:r,useTransposedTile:n}=t,s=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[o]))return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!n){const t=e.pixels.map((e=>e[o])),n={location:i,value:t,pyramidLevel:r},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(n.magdirValue=s.map((e=>e[0]))),n}let a=e.pixels.map((e=>e.slice(o*s,o*s+s))),c=this._computeMagDirValues(a);const{requestSomeSlices:m,identifyOptions:f}=t;let h=g(l,f.transposedVariableName);if(m){const e=I(h,f.multidimensionalDefinition,f.timeExtent);a=a.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),h=e.map((e=>h[e]))}const p=e.noDataValues||this.rasterInfo.noDataValue,d={pixels:a,pixelType:e.pixelType};let x;null!=p&&(b(d,p),x=d.mask);return{location:i,value:null,dataSeries:h.map(((e,t)=>{const i={value:0===x?.[t]?null:a.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new u({...e,isSlice:!0})))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i})),pyramidLevel:r}}};e([l()],V.prototype,"_rasterTileAlighmentInfo",void 0),e([l({readOnly:!0})],V.prototype,"_isGlobalWrappableSource",null),e([l({readOnly:!0})],V.prototype,"_hasNoneOrGCSShiftTransform",null),e([l()],V.prototype,"rasterJobHandler",null),e([l(f)],V.prototype,"url",null),e([l({type:String,json:{write:!0}})],V.prototype,"datasetName",void 0),e([l({type:String,json:{write:!0}})],V.prototype,"datasetFormat",void 0),e([l()],V.prototype,"hasUniqueSourceStorageInfo",void 0),e([l()],V.prototype,"rasterInfo",void 0),e([l()],V.prototype,"ioConfig",void 0),e([l()],V.prototype,"sourceJSON",void 0),V=e([c("esri.layers.support.rasterDatasets.BaseRaster")],V);const U=V;export{U as default};
