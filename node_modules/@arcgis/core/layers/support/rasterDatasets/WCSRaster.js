/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../core/Error.js";import i from"../../../core/Logger.js";import{isAbortError as s}from"../../../core/promiseUtils.js";import{property as n}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import{subclass as o}from"../../../core/accessorSupport/decorators/subclass.js";import{isAxesOrderReversedForWkid as r}from"../../ogc/crsUtils.js";import a from"../DimensionalDefinition.js";import l from"./BaseRaster.js";import{parse as c}from"./multipartParser.js";import{parseCapabilities as d}from"./wcsCapabilitiesParser.js";import{standardizeInterpolations as p,parseCoverages as u}from"./wcsCoverageParser.js";import{getFormat as h}from"../rasterFormats/RasterCodec.js";import{clip as f}from"../rasterFunctions/pixelUtils.js";import g from"../../../geometry/Extent.js";const m=["nearest neighbor","bilinear","bicubic"],w=["nearest","linear","cubic"],v="response is not a supported multipart/related mediaType with inline tiff,  switching to compability mode",y="response is not a supported multipart mediaType with inline tiff",x="response is base64 encoded which may impact layer display performance",I="server returns an exception";let C=class extends l{constructor(){super(...arguments),this.datasetFormat="WCSServer"}async open(e){await this.init();const i=e?.signal,s=await this._getCapabilities(i);if(this.capabilities=s,!this.version){let e=s.capabilitiesVersion?.slice(0,3);"2.0"===e||"1.1"===e||"1.0"===e?this.version=s.capabilitiesVersion:(e=s.supportedVersions.find((e=>"2.0.1"===e))||s.supportedVersions.find((e=>"2.0"===e.slice(0,3)))||s.supportedVersions.find((e=>"1.1"===e.slice(0,3)))||s.supportedVersions.find((e=>"1.0"===e.slice(0,3)))||"1.0.0",this.version=e)}const n=s.coverages.filter((e=>null==e.coverageSubType||""===e.coverageSubType||e.coverageSubType?.toLowerCase().startsWith("rectifiedgrid")));null==this.coverageId&&(this.coverageId=n[0].id);const o=n.find((e=>e.id===this.coverageId));if(null==o)throw new t("wcsraster-open",`the coverageId ${this.coverageId} does not exist in capabilities`);const r=await this._describeCoverage(i);this.coverageInfo=r[0],"2.0"===this.version.slice(0,3)&&(this.coverageInfo.lonLatEnvelope=o.lonLatEnvelope,this.coverageInfo.supportedInterpolations=p(s.supportedInterpolations)),this.datasetName=this.coverageInfo.title;const{rasterInfo:a}=this.coverageInfo;if(this.createRemoteDatasetStorageInfo(a,512,512),this._set("rasterInfo",a),null==a.spatialReference)throw new t("wcsraster-open",`coverage without spatial referernce is not supported: ${this.coverageId}`);const{pixelType:l,bandCount:c}=await this._getPixelTypeAndBandCount(i);a.pixelType=l,1===a.bandCount&&c>1&&(a.bandCount=c),this.updateTileInfo()}async fetchRawTile(e,i,s,n={}){if(this.isBlockOutside(e,i,s))return null;const{nativePixelSize:o,spatialReference:r}=this.rasterInfo,a=2**e,l=o.x*a,c=o.y*a,{blockWidth:d,blockHeight:p}=this.getBlockWidthHeight(e),{origin:u}=this.rasterInfo.storageInfo.tileInfo,h=this.getTileExtent({x:l,y:c},i,s,u,r,[d,p]),g=this.rasterInfo.extent,m=h.xmax>g.xmax,w=h.ymin<g.ymin,v=m||w;let y=h,x=d,I=p;if(v&&(y=h.clone().intersection(g),null!=y&&(m&&(x=Math.floor((y.xmax-y.xmin)/l),y.xmax=y.xmin+l*x),w&&(I=Math.floor((y.ymax-y.ymin)/c),y.ymin=y.ymax-c*I))),null==y||x<=1||I<=1)return null;const C=await this._getCoverage(y,x,I,a,n);if(!C)return null;const{coverageDescription:b}=this.coverageInfo;let{noDataValue:$,multidimensionalInfo:S}=this.rasterInfo;const{multidimensionalDefinition:T}=n;if(null!=S&&null!=T&&T.length){const e=T[0].variableName;if("2.0"===b.version){const t=b.rangeType[0].find((t=>t.name===e));$=t?.nilValue}else if("1.1"===b.version){const t=b.range.find((t=>t.identifier===e));$=t?.nullValues}}const j=await this.decodePixelBlock(C,{width:x,height:I,planes:null,pixelType:null,noDataValue:Array.isArray($)?$[0]:$});if(null==j)return null;if(j&&(j.width!==x||j.height!==I))throw new t("wcsraster-fetch",`the reponse has unexpected dimension width: ${j.width}, height: {pixelBlock.height}`);return v?f(j,{x:0,y:0},{width:p,height:p}):j}async _getCapabilities(e){const i={service:"WCS",request:"GetCapabilities"};this.version&&(i.version=this.version,i.acceptVersions=this.version);try{const{data:t}=await this.request(this.url,{query:i,responseType:"xml",signal:e});return d(t)}catch(n){if(!s(n))throw new t("wcslayer:open","wcs capabilities is not valid or supported");throw n}}async _describeCoverage(e){const i={service:"WCS",request:"DescribeCoverage",version:this.version},n=this.version?.slice(0,3);"1.0"===n?i.coverage=this.coverageId:"1.1"===n?i.identifiers=this.coverageId:"2.0"===n&&(i.coverageId=this.coverageId);try{const{data:t}=await this.request(this.url,{query:i,responseType:"xml",signal:e});return u(t,this.version)}catch(o){if(!s(o))throw new t("wcslayer:open","wcs coverage description is not valid or supported");throw o}}async _getPixelTypeAndBandCount(e){const{pixelSize:s,extent:n,multidimensionalInfo:o}=this.rasterInfo,r=n.center,l=new g({xmin:r.x-s.x,xmax:r.x+s.x,ymin:r.y-s.y,ymax:r.y+s.y,spatialReference:n.spatialReference});let c=[];if(null!=o){const e=o.variables[0];c=[],e.dimensions.forEach((t=>{c.push(new a({variableName:e.name,dimensionName:t.name,values:t.hasRegularIntervals?t.extent[0]:t.values?.[0],isSlice:!0}))}))}const{coverageDescription:d}=this.coverageInfo,p={interpolation:"nearest",multidimensionalDefinition:c,signal:e},{version:u}=d,{ioConfig:h}=this,f="2.0"===u&&null==h.allowAnyMediaType||"1.1"===u&&null==h.use2GridOffsets;let m;try{m=await this._getCoverage(l,2,2,1,p,!0)}catch(y){if(!f)throw y;if("1.1"===u){if(!y.details?.isResolutionMismatch)throw y;h.use2GridOffsets=!0}}if(!m&&f&&("2.0"===u&&(h.allowAnyMediaType=!0),m=await this._getCoverage(l,2,2,1,p),m&&i.getLogger(this).warn("wcsraster:getcoverage",v)),!m)throw new t("wcsraster-open","unable to determine pixel type");const w=await this.decodePixelBlock(m,{width:2,height:2,planes:null,pixelType:null});if(null==w)throw new t("wcsraster-open","unable to determine pixel type");return{pixelType:w.pixelType,bandCount:w.getPlaneCount()??0}}async _getCoverage(e,s,n,o,r,a=!1){const{coverageDescription:l}=this.coverageInfo,{version:d}=l,p="2.0"===d?this._getCoverage201Parameters(e,s,n,o,r,l):"1.1"===d?this._getCoverage110Parameters(e,s,n,r,l):this._getCoverage100Parameters(e,s,n,r),u="2.0"===d?await this.request(this._constructWCS201Url(p),{signal:r.signal,responseType:"array-buffer"}):await this.request(this.url,{query:p,signal:r.signal,responseType:"array-buffer"});if("1.0"===d)return u.data;if("2.0"===d&&!1!==this.ioConfig.allowAnyMediaType){if("tiff"===h(u.data))return a&&(this.ioConfig.allowAnyMediaType=!0,i.getLogger(this).warn("wcsraster:getcoverage",v)),u.data}const f=c(u);if(f.isMultipart&&f.data){const e=f.data.find((e=>e.contentType?.toLowerCase().includes("image")&&null!=e.contentData));return a&&"base64"===e?.contentTransferEncoding&&i.getLogger(this).warn("wcsraster:getcoverage",x),e?.contentData}const g=new Uint8Array(u.data,0,Math.min(u.data.byteLength,2e3)),m=String.fromCharCode.apply(null,g).toLowerCase().includes("exception"),w=m&&String.fromCharCode.apply(null,g).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");if(m)throw new t("wcsraster:getcoverage",I,{isResolutionMismatch:w});throw new t("wcsraster:getcoverage",y)}_getInterpolationIndex(e){return e&&this.coverageInfo.supportedInterpolations?.includes(e)?"nearest"===e?0:"bilinear"===e?1:"cubic"===e?2:0:0}_getCoverage100Parameters(e,t,i,s){const n=`${e.xmin},${e.ymin},${e.xmax},${e.ymax}`,o=e.spatialReference.wkid,r=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().includes("tiff")))||"GEOTIFF",{bandIds:a,interpolation:l}=s,c=this._getInterpolationIndex(l),d=a?a.map((e=>this.coverageInfo.bandNames[e])):null,p=m[c],{multidimensionalDefinition:u}=s;let h;if(null!=u&&null!=this.rasterInfo.multidimensionalInfo){const e=u.find((e=>"StdTime"===e.dimensionName));let t=e?.values;t&&t.length>0&&(t[0]instanceof Array&&(t=t[0]),h=t.map((e=>this._convertToISOTime(e))).join(","))}return{service:"WCS",request:"GetCoverage",version:this.version,coverage:this.coverageId,format:r,crs:`EPSG:${o}`,bbox:n,width:t,height:i,time:h,interpolation:p,band:d?.join(",")}}_getCoverage110Parameters(e,t,i,s,n){const{multidimensionalDefinition:o,bandIds:a,interpolation:l}=s,c=e.spatialReference.wkid,d=`urn:ogc:def:crs:EPSG::${c}`,p=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().includes("tiff")))||"image/tiff",u=this._getInterpolationIndex(l),h=w[u],f=null==l||0===this.coverageInfo.supportedInterpolations?.indexOf(l),g=n.domain.spatialDomain,m=g.origin.x<=g.envelope.xmin&&g.origin.y<=g.envelope.ymin,v=e.width/t,y=e.height/i*(m?1:-1),x=m?[e.xmin,e.ymin]:[e.xmin,e.ymax],I=g.useEPSGAxis&&r(c),C=I?`${x[1]},${x[0]}`:`${x[0]},${x[1]}`,b=this.ioConfig.use2GridOffsets,$=I?b?`${y},${v}`:`${y},0,0,${v}`:b?`${v},${y}`:`${v},0,0,${y}`,S=v/2,T=e.xmin+S,j=e.xmax-S,_=Math.abs(y)/2,L=e.ymin+_,D=e.ymax-_,E=I?`${L},${T},${D},${j},${d}`:`${T},${L},${j},${D},${d}`,P=n.range.find((e=>e.axis.some((e=>e.identifier.toLowerCase().includes("band")))));let R,A=P&&h&&a?f?`${P.identifier}[${P.axis[0].identifier}[${a.join(",")}]]`:`${P.identifier}:${h}[${P.axis[0].identifier}[${a.join(",")}]]`:null;if(null!=o&&o.length)for(let r=0;r<o.length;r++){let e=o[r].values;const t=o[r].dimensionName?.toLowerCase(),i=o[r].variableName?.toLowerCase();if(e.length>0)if(e[0]instanceof Array&&(e=e[0]),"stdtime"===t)R=e.map((e=>this._convertToISOTime(e))).join(",");else{const s=n.range.find((e=>e.identifier.toLowerCase()===i));if(s){const i=s.axis.find((e=>e.identifier.toLowerCase()===t));i&&(A=f?s.identifier+"["+i.identifier+"["+e.join(",")+"]]":s.identifier+":"+h+"["+i.identifier+"["+e.join(",")+"]]")}}}return{service:"WCS",request:"GetCoverage",version:this.version,identifier:this.coverageId,format:p,crs:`EPSG:${c}`,boundingbox:E,gridCS:"urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS",gridType:"urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs",gridOrigin:C,gridOffsets:$,gridBaseCRS:d,timeSequence:R,rangeSubset:A}}_convertToISOTime(e,t=!1){return(t?new Date(24*(e-25569)*60*60*1e3):new Date(e)).toISOString()}_getCoverage201Parameters(e,t,i,s,n,o){const{multidimensionalDefinition:r,interpolation:a}=n,l=this._getInterpolationIndex(a);let c=null;const{supportedInterpolations:d}=this.capabilities;if(d?.length)switch(l){case 0:c=d.find((e=>e.toLowerCase().includes("nearest")));break;case 1:c=d.find((e=>e.toLowerCase().includes("linear")));break;case 2:c=d.find((e=>e.toLowerCase().includes("cubic")||e.toLowerCase().includes("quadratic")))}const p=(this.coverageInfo.supportedFormats||[]).find((e=>e.toLowerCase().includes("tiff")))||"image/tiff",{bandNames:u}=this.coverageInfo,{boundedBy:h,domainSet:f,rangeType:g}=o,m=h.isEastFirst?0:1,w=1-m,{axisLabels:v}=h,y=v[m],x=v[w],I=`http://www.opengis.net/def/crs/EPSG/0/${e.spatialReference.wkid}`,C=I,b=[];b.push(`${y}(${e.xmin},${e.xmax})`),b.push(`${x}(${e.ymin},${e.ymax})`);const $=[];if(v.length>2)for(let D=2;D<v.length;D++){const e=f.origin[D];if(v[D].toLowerCase().includes("time")){let t=e.toString();h.uomLabels?.[D].toLowerCase().includes("ole")&&($.push(v[D]),t=this._convertToISOTime(e,!0)),b.push(v[D]+",http://www.opengis.net("+t+")")}else b.push(v[D]+",http://www.opengis.net("+e+")")}let S=null;if(null!=r&&r.length){const e=[];g.forEach((t=>t.forEach((t=>e.push(t.name)))));const t=[];for(let i=0;i<r.length;i++){const s=v.find((e=>e===r[i].dimensionName)),n=e.find((e=>e===r[i].variableName));if(t.includes(n)||t.push(n),s){let e=r[i].values;if(e.length>0){Array.isArray(e[0])&&(e=e[0]);let t="";t=s.toLowerCase().includes("time")?e.map((e=>this._convertToISOTime(e))).join(","):e.join(",");const i=b.findIndex((e=>0===e.indexOf(s+",http://www.opengis.net")));-1===i&&b.push(s+",http://www.opengis.net("+t+")"),-1===i||b[i].includes("("+t+")")||b.splice(i,1,s+",http://www.opengis.net("+t+")")}}}t.length&&(S=t.join(","))}else if(u?.length>=2){S=(n.bandIds?n.bandIds.map((e=>u[e])):u).join(",")}const T=b.join("&subset="),j=!o.domainSet.hasSameAxisLabelsAsBoundedBy&&!1!==this.ioConfig.allowScaleFactor,_=j?null:`${y}(${t}),${x}(${i})`,L=j?1/s:null;return{service:"WCS",request:"GetCoverage",version:this.version,coverageId:this.coverageId,rangesubset:S,interpolation:c,scaleSize:_,scaleFactor:L,subset:T,format:p,mediaType:this.ioConfig.allowAnyMediaType?null:"multipart/related",outputcrs:I,subsettingcrs:C}}_constructWCS201Url(e){const t={...this.ioConfig.customFetchParameters,...e},i=[];Object.keys(t).forEach((e=>{const s=t[e];null!=s&&("subset"===e?"string"==typeof s&&s.split("&subset=").forEach((e=>{e&&i.push(`subset=${encodeURIComponent(e)}`)})):i.push(`${e}=${encodeURIComponent(s)}`))}));return`${encodeURI(this.url)}?${i.join("&")}`}};e([n({type:String,json:{write:!0}})],C.prototype,"datasetFormat",void 0),e([n()],C.prototype,"tileType",void 0),e([n({type:String,json:{write:!0}})],C.prototype,"version",void 0),e([n({type:String,json:{write:!0}})],C.prototype,"coverageId",void 0),C=e([o("esri.layers.support.rasterDatasets.WCSRaster")],C);const b=C;export{b as default};
