/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import n from"../core/Error.js";import{throwIfAborted as e,waitTick as r}from"../core/promiseUtils.js";import{trackAccess as t}from"../core/accessorSupport/tracking.js";import{SimpleObservable as l}from"../core/accessorSupport/tracking/SimpleObservable.js";import{c as o}from"../chunks/vec3f64.js";import{isSphericalECEF as i,isSphericalPCPF as u}from"./ellipsoidUtils.js";import s from"./Extent.js";import a from"./Multipoint.js";import{l as c,p as f,i as p}from"../chunks/pe.js";import m from"./Point.js";import h from"./Polygon.js";import g from"./Polyline.js";import R from"./SpatialReference.js";import{projectBuffer as j}from"./projection/projectBuffer.js";import{getProjector as y,projectorCache as d,getWGS84ComparableLonLatProjector as x}from"./projection/projectors.js";import{projectXYZToVector as w}from"./projection/projectXYZToVector.js";import z from"./support/GeographicTransformation.js";import{equals as M,isValid as Z}from"./support/spatialReferenceUtils.js";import{getGeometryZScaler as v}from"./support/zscale.js";let A=null,S=null,G=null,P={};const k=new l;function E(){return!!A&&p()}function T(){return!!E()||(t(k),_(),!1)}function _(n){return null==G&&(G=Promise.all([c(),import("../chunks/geometryEngineBase.js").then((n=>n.g)),import("./geometryAdapters/hydrated.js")])),G.then((([,r,{hydratedAdapter:t}])=>{e(n),S=t,A=r.default,A._enableProjection(f),k.notify()}))}function b(n,e,r=null,t=null){return Array.isArray(n)?0===n.length?[]:B(S,n,n[0].spatialReference,e,r,t):B(S,[n],n.spatialReference,e,r,t)[0]}function B(n,e,r,t,l=null,o=null){if(null==r||null==t)return e;if(D(r,t,l))return e.map((n=>H(n,r,t)));if(null==l&&i(r)){return e.map((n=>H(n,r,R.WGS84))).map((n=>q(n,t)))}if(null==l&&i(t)){return e.map((n=>q(n,R.WGS84))).map((n=>H(n,R.WGS84,t)))}if(null==l){const n=z.cacheKey(r,t);void 0!==P[n]?l=P[n]:(null==(l=K(r,t,void 0))&&(l=new z),P[n]=l)}if(null==A||null==n)throw new V;return null!=o?A._project(n,e,r,t,l,o):A._project(n,e,r,t,l)}function U(n,e){const r=W([n],e);return null!=r.pending?{pending:r.pending,geometry:null}:null!=r.geometries?{pending:null,geometry:r.geometries[0]}:{pending:null,geometry:null}}function W(n,e){if(!E())for(const r of n)if(null!=r&&!M(r.spatialReference,e)&&Z(r.spatialReference)&&Z(e)&&!D(r.spatialReference,e))return t(k),{pending:_(),geometries:null};return{pending:null,geometries:n.map((n=>null==n?null:M(n.spatialReference,e)?n:Z(n.spatialReference)&&Z(e)?q(n,e):null))}}function K(n,e,r=null){if(null==n||null==e)return null;if(null==A||null==S)throw new V;const t=A._getTransformation(S,n,e,r,r?.spatialReference);return null!==t?z.fromGE(t):null}function O(n,e,r=null){if(null==A||null==S)throw new V;const t=A._getTransformationBySuitability(S,n,e,r,r?.spatialReference);if(null!==t){const n=[];for(const e of t)n.push(z.fromGE(e));return n}return[]}class V extends n{constructor(){super("projection:not-loaded","projection engine not fully loaded yet, please call load()")}}function X(){A=null,S=null,G=null,P={}}const Y={get loadPromise(){return G}};function q(n,e){try{const r=b(n,e);if(null==r)return null;"xmin"in n&&"xmin"in r&&(r.zmin=n.zmin,r.zmax=n.zmax);const t=v(r.type,n.spatialReference,e);return null!=t&&t(r),r}catch(r){if(!(r instanceof V))throw r;return null}}async function C(n,e,r){const t=n.spatialReference;return null!=t&&null!=e&&await F(t,e,null,r),q(n,e)}function D(n,e,r){return!r&&(!!M(n,e)||Z(n)&&Z(e)&&!!y(n,e,d))}async function F(n,e,t,l){if(E())return r(l);if(Array.isArray(n)){for(const{source:r,dest:o,geographicTransformation:i}of n)if(!D(r,o,i))return _(l)}else if(!D(n,e,t))return _(l);return r(l)}function H(n,e,r){return n?"x"in n?J(n,e,new m,r,0):"xmin"in n?tn(n,e,new s,r,0):"rings"in n?en(n,e,new h,r,0):"paths"in n?$(n,e,new g,r,0):"points"in n?N(n,e,new a,r,0):null:null}function I(n,e,r=e.spatialReference,t=0){return null!=r&&null!=n.spatialReference&&null!=J(n,n.spatialReference,e,r,t)}function J(n,e,r,t,l){un[0]=n.x,un[1]=n.y;const o=n.z;return un[2]=void 0!==o?o:l,j(un,e,0,un,t,0,1)?(r.x=un[0],r.y=un[1],r.spatialReference=t,void 0!==o||u(t)?(r.z=un[2],r.hasZ=!0):(r.z=void 0,r.hasZ=!1),void 0===n.m?(r.m=void 0,r.hasM=!1):(r.m=n.m,r.hasM=!0),r):null}function L(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=N(n,n.spatialReference,e,r,t)}function N(n,e,r,t,l){const{points:o,hasZ:i,hasM:s}=n,a=[],c=o.length,f=[];for(const u of o)f.push(u[0],u[1],i?u[2]:l);if(!j(f,e,0,f,t,0,c))return null;const p=i||u(t);for(let u=0;u<c;++u){const n=3*u,e=f[n],r=f[n+1];p&&s?a.push([e,r,f[n+2],o[u][3]]):p?a.push([e,r,f[n+2]]):s?a.push([e,r,o[u][2]]):a.push([e,r])}return r.points=a,r.spatialReference=t,r.hasZ=i,r.hasM=s,r}function Q(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=$(n,n.spatialReference,e,r,t)}function $(n,e,r,t,l){const{paths:o,hasZ:i,hasM:s}=n,a=[];if(!ln(o,i??!1,s??!1,e,a,t,l))return null;const c=i||u(t);return r.paths=a,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function nn(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=en(n,n.spatialReference,e,r,t)}function en(n,e,r,t,l){const{rings:o,hasZ:i,hasM:s}=n,a=[];if(!ln(o,i??!1,s??!1,e,a,t,l))return null;const c=i||u(t);return r.rings=a,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function rn(n,e,r=e.spatialReference,t=0){return null!=n.spatialReference&&null!=r&&null!=tn(n,n.spatialReference,e,r,t)}function tn(n,e,r,t,l){const{xmin:o,ymin:i,xmax:s,ymax:a,hasZ:c,hasM:f}=n,p=c?n.zmin:l;if(!w(o,i,p,e,un,t))return null;const m=c||u(t);r.xmin=un[0],r.ymin=un[1],m&&(r.zmin=un[2]);const h=c?n.zmax:l;return w(s,a,h,e,un,t)?(r.xmax=un[0],r.ymax=un[1],m&&(r.zmax=un[2]),f&&(r.mmin=n.mmin,r.mmax=n.mmax),r.spatialReference=t,r):null}function ln(n,e,r,t,l,o,i=0){const s=new Array;for(const u of n)for(const n of u)s.push(n[0],n[1],e?n[2]:i);if(!j(s,t,0,s,o,0,s.length/3))return!1;let a=0;l.length=0;const c=e||u(o);for(const u of n){const n=new Array;for(const e of u)c&&r?n.push([s[a++],s[a++],s[a++],e[3]]):c?n.push([s[a++],s[a++],s[a++]]):r?(n.push([s[a++],s[a++],e[2]]),a++):(n.push([s[a++],s[a++]]),a++);l.push(n)}return!0}function on(n){return null!=n&&null!=x(n)}const un=o();export{on as canProjectToWGS84ComparableLonLat,D as canProjectWithoutEngine,K as getTransformation,O as getTransformations,F as initializeProjection,E as isLoaded,T as isLoadedOrLoad,_ as load,b as project,rn as projectExtent,B as projectMany,L as projectMultipoint,U as projectOrLoad,W as projectOrLoadMany,I as projectPoint,nn as projectPolygon,Q as projectPolyline,C as projectWithZConversion,H as projectWithoutEngine,Y as test,q as tryProjectWithZConversion,X as unload};
