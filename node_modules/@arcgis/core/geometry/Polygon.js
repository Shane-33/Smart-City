/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import{equals as e}from"../core/arrayUtils.js";import{clone as r}from"../core/lang.js";import{property as s}from"../core/accessorSupport/decorators/property.js";import"../core/accessorSupport/ensureType.js";import{subclass as n}from"../core/accessorSupport/decorators/subclass.js";import{writer as i}from"../core/accessorSupport/decorators/writer.js";import o from"./Extent.js";import a from"./Geometry.js";import l from"./Point.js";import h from"./SpatialReference.js";import{polygonCentroid as p}from"./support/centroid.js";import{polygonContainsPoint as u}from"./support/contains.js";import{isClockwise as c}from"./support/coordsUtils.js";import{getPolygonExtent as f}from"./support/extentUtils.js";import{isSelfIntersecting as m}from"./support/intersectsBase.js";import{project as g}from"./support/webMercatorUtils.js";import{updateSupportFromPoint as y}from"./support/zmUtils.js";var d;function R(t){return!Array.isArray(t[0])}let x=d=class extends a{static fromExtent(t){const e=t.clone().normalize(),r=t.spatialReference;let s=!1,n=!1;for(const o of e)o.hasZ&&(s=!0),o.hasM&&(n=!0);const i={rings:e.map((t=>{const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(s&&t.hasZ){const r=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(r)}if(n&&t.hasM){const r=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(r)}return e})),spatialReference:r};return s&&(i.hasZ=!0),n&&(i.hasM=!0),new d(i)}constructor(...t){super(...t),this.rings=[],this.type="polygon"}normalizeCtorArgs(t,e){let r,s,n=null,i=null;return t&&!Array.isArray(t)?(n=t.rings??null,e||(t.spatialReference?e=t.spatialReference:t.rings||(e=t)),r=t.hasZ,s=t.hasM):n=t,n=n||[],e=e||h.WGS84,n.length&&null!=n[0]?.[0]&&"number"==typeof n[0][0]&&(n=[n]),i=n[0]?.[0],i&&(void 0===r&&void 0===s?(r=i.length>2,s=i.length>3):void 0===r?r=s?i.length>3:i.length>2:void 0===s&&(s=r?i.length>3:i.length>2)),{rings:n,spatialReference:e,hasZ:r,hasM:s}}get cache(){return this.commitProperty("rings"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get centroid(){const t=p(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const e=new l;return e.x=t[0],e.y=t[1],e.spatialReference=this.spatialReference,this.hasZ&&(e.z=t[2]),e}get extent(){const{spatialReference:t}=this,e=f(this);if(!e)return null;const r=new o(e);return r.spatialReference=t,r}get isSelfIntersecting(){return m(this.rings)}writeRings(t,e){e.rings=r(this.rings)}addRing(t){if(!t)return;const e=this.rings,r=e.length;if(R(t)){const s=[];for(let e=0,r=t.length;e<r;e++)s[e]=t[e].toArray();e[r]=s}else e[r]=t.concat();return this.notifyChange("rings"),this}clone(){const t=new d;return t.spatialReference=this.spatialReference,t.rings=r(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}equals(t){if(this===t)return!0;if(null==t)return!1;const r=this.spatialReference,s=t.spatialReference;if(null!=r!=(null!=s))return!1;if(null!=r&&null!=s&&!r.equals(s))return!1;if(this.rings.length!==t.rings.length)return!1;const n=([t,e,r,s],[n,i,o,a])=>t===n&&e===i&&(null==r&&null==o||r===o)&&(null==s&&null==a||s===a);for(let i=0;i<this.rings.length;i++){const r=this.rings[i],s=t.rings[i];if(!e(r,s,n))return!1}return!0}contains(t){if(!t)return!1;const e=g(t,this.spatialReference);return u(this,null!=e?e:t)}isClockwise(t){let e;return e=R(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t,c(e)}getPoint(t,e){if(!this._validateInputs(t,e))return null;const r=this.rings[t][e],s=this.hasZ,n=this.hasM;return s&&!n?new l(r[0],r[1],r[2],void 0,this.spatialReference):n&&!s?new l(r[0],r[1],void 0,r[2],this.spatialReference):s&&n?new l(r[0],r[1],r[2],r[3],this.spatialReference):new l(r[0],r[1],this.spatialReference)}insertPoint(t,e,r){return this._validateInputs(t,e,!0)?(y(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t].splice(e,0,r),this.notifyChange("rings"),this):this}removePoint(t,e){if(!this._validateInputs(t,e))return null;const r=new l(this.rings[t].splice(e,1)[0],this.spatialReference);return this.notifyChange("rings"),r}removeRing(t){if(!this._validateInputs(t,null))return null;const e=this.rings.splice(t,1)[0],r=this.spatialReference,s=e.map((t=>new l(t,r)));return this.notifyChange("rings"),s}setPoint(t,e,r){return this._validateInputs(t,e)?(y(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t][e]=r,this.notifyChange("rings"),this):this}_validateInputs(t,e,r=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const s=this.rings[t];if(r&&(e<0||e>s.length))return!1;if(!r&&(e<0||e>=s.length))return!1}return!0}toJSON(t){return this.write({},t)}};t([s({readOnly:!0})],x.prototype,"cache",null),t([s({readOnly:!0})],x.prototype,"centroid",null),t([s({readOnly:!0})],x.prototype,"extent",null),t([s({readOnly:!0})],x.prototype,"isSelfIntersecting",null),t([s({type:[[[Number]]],json:{write:{isRequired:!0}}})],x.prototype,"rings",void 0),t([i("rings")],x.prototype,"writeRings",null),x=d=t([n("esri.geometry.Polygon")],x),x.prototype.toJSON.isDefaultToJSON=!0;const j=x;export{j as default};
