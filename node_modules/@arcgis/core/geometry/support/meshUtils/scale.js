/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{s as t,f as r,i as o,g as n}from"../../../chunks/vec3.js";import{c as i,Z as s}from"../../../chunks/vec3f64.js";import{getSphericalPCPF as l}from"../../spatialReferenceEllipsoidUtils.js";import{projectPointToVector as a}from"../../projection/projectPointToVector.js";import c from"../MeshTransform.js";import{validateGeographicFlag as p,isGeographicMesh as f}from"./geographicUtils.js";import{projectToPCPF as u,projectNormalToPCPF as g,projectTangentToPCPF as m,projectFromPCPF as j,projectNormalFromPCPF as v,projectTangentFromPCPF as h}from"./projection.js";const x="esri.geometry.support.meshUtils.scale";function d(e,t,r){if(!e.vertexAttributes?.position)return;const{spatialReference:o,vertexSpace:n}=e;if(n.isRelative){p(n,x,r);const o=r?.origin??e.origin;e.transform??=new c,A(e.transform,n,t,o)}else{const n=f(o,r),i=r?.origin??e.origin;n?b(e,t,i):y(e,t,i)}}function A(e,s,l,a){const c=s.origin,p=t(R,a.x,a.y,a.z),f=r(R,p,c);e.applyLocalInverse(f,k);const u=o(i(),e.scale,l);e.scale=u,e.applyLocalInverse(f,f),r(f,f,k),e.translation=n(i(),e.translation,f)}function b(e,t,r){const o=e.spatialReference,n=l(o),i=F;a(r,i,n)||a(e.origin,i,n);const s=e.vertexAttributes.position,c=e.vertexAttributes.normal,p=e.vertexAttributes.tangent,f=new Float64Array(s.length),x=null!=c?new Float32Array(c.length):null,d=null!=p?new Float32Array(p.length):null;u(s,o,f),null!=c&&null!=x&&g(c,s,f,o,x),null!=p&&null!=d&&m(p,s,f,o,d),w(f,t,i),j(f,s,o),null!=c&&null!=x&&v(x,s,f,o,c),null!=p&&null!=d&&h(d,s,f,o,p),e.vertexAttributesChanged()}function y(t,r,o){const n=F;if(!a(o,n,t.spatialReference)){const r=t.origin;n[0]=r.x,n[1]=r.y,n[2]=r.z,e.getLogger(x).error(`Failed to project specified origin (wkid:${o.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}w(t.vertexAttributes.position,r,n),t.vertexAttributesChanged()}function w(e,t,r=s){if(e)for(let n=0;n<e.length;n+=3){for(let t=0;t<3;t++)R[t]=e[n+t]-r[t];o(R,R,t);for(let t=0;t<3;t++)e[n+t]=R[t]+r[t]}}const R=i(),k=i(),F=i();export{d as scale};
