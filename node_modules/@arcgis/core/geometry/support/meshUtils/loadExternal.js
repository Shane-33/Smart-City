/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import"../../../assets.js";import"../../../request.js";import e from"../../../core/Error.js";import"../../../core/has.js";import{whenOrAbort as t,throwIfAborted as s,allSettledValues as r,isAborted as o,createAbortError as n}from"../../../core/promiseUtils.js";import{removeFile as i,makeRelative as a}from"../../../core/urlUtils.js";import l from"../../Point.js";import"../../../views/3d/webgl-engine/lib/basicInterfaces.js";async function c(e,r,o){const{source:n}=r,{loadGLTFMesh:i}=await t(import("./loadGLTFMesh.js"),o),a=await m(n,o);s(o);const c=i(new l({x:0,y:0,z:0,spatialReference:e.spatialReference}),a.url,{resolveFile:u(a),requestFile:void 0,useTransform:!0,signal:o?.signal,expectedType:a.type});c.then((()=>a.dispose()),(()=>a.dispose()));const{vertexAttributes:f,components:p}=await c;e.vertexAttributes=f,e.components=p}function u(e){const t=i(e.url);return s=>{const r=a(s,t,t),o=r?r.replace(/^ *\.\//,""):null;return(o?e.files.get(o):null)??s}}async function m(t,s){if(Array.isArray(t)){if(!t.length)throw new e("mesh-load-external:missing-assets","There must be at least one file to load");return t[0]instanceof File?h(t):w(t,s)}return p(t)}async function f(e,t){const{parts:r,assetMimeType:o,assetName:n}=e;if(1===r.length)return new T(r[0].partUrl);const i=await e.toBlob(t);return s(t),T.fromBlob(i,v(n,o))}function p(e){return T.fromBlob(e,v(e.name,e.type))}function h(e){return j(e.map((e=>({name:e.name,mimeType:e.type,source:p(e)}))))}async function w(e,t){const i=await r(e.map((async e=>{const r=await f(e);return s(t),{name:e.assetName,mimeType:e.assetMimeType,source:r}})));if(o(t))throw i.forEach((e=>e.source.dispose())),n();return j(i)}const y=/^model\/gltf\+json$/,d=/^model\/gltf-binary$/,g=/\.gltf$/i,b=/\.glb$/i;function j(t){const s=new Map;let r,o=null;for(const{name:e,mimeType:n,source:i}of t)null===o&&(y.test(n)||g.test(e)?(o=i.url,r="gltf"):(d.test(n)||b.test(e))&&(o=i.url,r="glb")),s.set(e,i.url),i.files.forEach(((e,t)=>s.set(t,e)));if(null==o)throw new e("mesh-load-external:missing-files","Missing files to load external mesh source");return new T(o,(()=>t.forEach((({source:e})=>e.dispose()))),s,r)}class T{constructor(e,t=(()=>{}),s=new Map,r){this.url=e,this.dispose=t,this.files=s,this.type=r}static fromBlob(e,t){const s=URL.createObjectURL(e);return new T(s,(()=>URL.revokeObjectURL(s)),void 0,t)}}function v(e,t){return y.test(t)||g.test(e)?"gltf":d.test(t)||g.test(e)?"glb":void 0}export{c as loadExternal};
