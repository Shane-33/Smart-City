/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import t from"../../config.js";import e from"../../core/Error.js";import n from"../../core/Logger.js";import s from"../Polygon.js";import o from"../Polyline.js";import{getGeometryParts as r,cutParams as i,offsetMagnitude as l,updatePolyGeometry as c}from"./normalizeUtilsCommon.js";import{getInfo as f}from"./spatialReferenceUtils.js";import{geographicToWebMercator as u,webMercatorToGeographic as a}from"./webMercatorUtils.js";import{cut as p}from"../../rest/geometryService/cut.js";import{simplify as h}from"../../rest/geometryService/simplify.js";const m=n.getLogger("esri.geometry.support.normalizeUtils");function g(t){return"polygon"===t.type}function y(t){return"polygon"===t[0].type}function x(t){return"polyline"===t[0].type}function d(t){const e=[];let n=0,s=0;for(let o=0;o<t.length;o++){const r=t[o];let i=null;for(let t=0;t<r.length;t++)i=r[t],e.push(i),0===t?(n=i[0],s=n):(n=Math.min(n,i[0]),s=Math.max(s,i[0]));i&&e.push([(n+s)/2,0])}return e}function M(t,n){if(!(t instanceof o||t instanceof s)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw m.error(t),new e(t)}const i=r(t),l=[];for(const e of i){const t=[];l.push(t),t.push([e[0][0],e[0][1]]);for(let s=0;s<e.length-1;s++){const o=e[s][0],r=e[s][1],i=e[s+1][0],l=e[s+1][1],c=Math.sqrt((i-o)*(i-o)+(l-r)*(l-r)),f=(l-r)/c,u=(i-o)/c,a=c/n;if(a>1){for(let l=1;l<=a-1;l++){const e=l*n,s=u*e+o,i=f*e+r;t.push([s,i])}const e=(c+Math.floor(a-1)*n)/2,s=u*e+o,i=f*e+r;t.push([s,i])}t.push([i,l])}}return g(t)?new s({rings:l,spatialReference:t.spatialReference}):new o({paths:l,spatialReference:t.spatialReference})}function w(t,e,n){if(e){const e=M(t,1e6);t=a(e,!0)}return n&&(t=c(t,n)),t}function j(t,e,n){if(Array.isArray(t)){const s=t[0];if(s>e){const n=l(s,e);t[0]=s+n*(-2*e)}else if(s<n){const e=l(s,n);t[0]=s+e*(-2*n)}}else{const s=t.x;if(s>e){const n=l(s,e);t=t.clone().offset(n*(-2*e),0)}else if(s<n){const e=l(s,n);t=t.clone().offset(e*(-2*n),0)}}return t}function b(t,e){let n=-1;for(let s=0;s<e.cutIndexes.length;s++){const o=e.cutIndexes[s],i=e.geometries[s],c=r(i);for(let t=0;t<c.length;t++){const e=c[t];e.some((n=>{if(n[0]<180)return!0;{let n=0;for(let t=0;t<e.length;t++){const s=e[t][0];n=s>n?s:n}n=Number(n.toFixed(9));const s=-360*l(n,180);for(let o=0;o<e.length;o++){const e=i.getPoint(t,o);i.setPoint(t,o,e.clone().offset(s,0))}return!0}}))}if(o===n){if(y(t))for(const e of r(i))t[o]=t[o].addRing(e);else if(x(t))for(const e of r(i))t[o]=t[o].addPath(e)}else n=o,t[o]=i}return t}async function R(e,n,r){if(!Array.isArray(e))return R([e],n);n&&"string"!=typeof n&&m.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const a="string"==typeof n?n:n?.url??t.geometryServiceUrl;let g,y,x,d,M,v,P,L,U=0;const z=[],A=[];for(const t of e)if(null!=t)if(g||(g=t.spatialReference,y=f(g),x=g.isWebMercator,v=x?102100:4326,d=i[v].maxX,M=i[v].minX,P=i[v].plus180Line,L=i[v].minus180Line),y)if("mesh"===t.type)A.push(t);else if("point"===t.type)A.push(j(t.clone(),d,M));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((t=>j(t,d,M))),A.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,y);A.push(e.rings?new s(e):e)}else if(t.extent){const e=t.extent,n=l(e.xmin,M)*(2*d);let s=0===n?t.clone():c(t.clone(),n);e.offset(n,0),e.intersects(P)&&e.xmax!==d?(U=e.xmax>U?e.xmax:U,s=w(s,x),z.push(s),A.push("cut")):e.intersects(L)&&e.xmin!==M?(U=e.xmax*(2*d)>U?e.xmax*(2*d):U,s=w(s,x,360),z.push(s),A.push("cut")):A.push(s)}else A.push(t.clone());else A.push(t);else A.push(t);let S=l(U,d),k=-90;const C=S,I=new o;for(;S>0;){const t=360*S-180;I.addPath([[t,k],[t,-1*k]]),k*=-1,S--}if(z.length>0&&C>0){const t=b(z,await p(a,z,I,r)),n=[],s=[];for(let r=0;r<A.length;r++){const o=A[r];if("cut"!==o)s.push(o);else{const o=t.shift(),i=e[r];null!=i&&"polygon"===i.type&&i.rings&&i.rings.length>1&&o.rings.length>=i.rings.length?(n.push(o),s.push("simplify")):s.push(x?u(o):o)}}if(!n.length)return s;const o=await h(a,n,r),i=[];for(let e=0;e<s.length;e++){const t=s[e];"simplify"!==t?i.push(t):i.push(x?u(o.shift()):o.shift())}return i}const X=[];for(let t=0;t<A.length;t++){const e=A[t];if("cut"!==e)X.push(e);else{const t=z.shift();X.push(!0===x?u(t):t)}}return X}function v(t){if(!t)return null;const e=t.extent;if(!e)return null;const n=t.spatialReference&&f(t.spatialReference);if(!n)return e;const[s,o]=n.valid,r=2*o,{width:i}=e;let l,{xmin:c,xmax:u}=e;if([c,u]=[u,c],"extent"===t.type||0===i||i<=o||i>r||c<s||u>o)return e;switch(t.type){case"polygon":if(!(t.rings.length>1))return e;l=d(t.rings);break;case"polyline":if(!(t.paths.length>1))return e;l=d(t.paths);break;case"multipoint":l=t.points}const a=e.clone();for(let f=0;f<l.length;f++){let t=l[f][0];t<0?(t+=o,u=Math.max(t,u)):(t-=o,c=Math.min(t,c))}return a.xmin=c,a.xmax=u,a.width<i?(a.xmin-=o,a.xmax-=o,a):e}function P(t,e,n){const s=f(n);if(null==s)return t;const[o,r]=s.valid,i=2*r;let l=0,c=0;e>r?l=Math.ceil(Math.abs(e-r)/i):e<o&&(l=-Math.ceil(Math.abs(e-o)/i)),t>r?c=Math.ceil(Math.abs(t-r)/i):t<o&&(c=-Math.ceil(Math.abs(t-o)/i));let u=t+(l-c)*i;const a=u-e;return a>r?u-=i:a<o&&(u+=i),u}function L(t,e){const n=f(e);if(n){const[e,s]=n.valid,o=s-e;if(t<e)for(;t<e;)t+=o;if(t>s)for(;t>s;)t-=o}return t}export{P as getClosestDenormalizedXToReference,v as getDenormalizedExtent,R as normalizeCentralMeridian,L as normalizeMapX,M as straightLineDensify};
