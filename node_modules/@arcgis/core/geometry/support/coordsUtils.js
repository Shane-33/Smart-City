/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{equals as t}from"../../core/arrayUtils.js";import{Axis as n}from"./Axis.js";import{getInfo as e}from"./spatialReferenceUtils.js";function r(t){if(!t)return null;if(Array.isArray(t))return t;const n=t.hasZ,e=t.hasM;if("point"===t.type)return e&&n?[t.x,t.y,t.z,t.m]:n?[t.x,t.y,t.z]:e?[t.x,t.y,t.m]:[t.x,t.y];if("polygon"===t.type)return t.rings.slice(0);if("polyline"===t.type)return t.paths.slice(0);if("multipoint"===t.type)return t.points.slice(0);if("extent"===t.type){const n=t.clone().normalize();if(!n)return null;let e=!1,r=!1;return n.forEach((t=>{t.hasZ&&(e=!0),t.hasM&&(r=!0)})),n.map((t=>{const n=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(e&&t.hasZ){const e=.5*(t.zmax-t.zmin);for(let t=0;t<n.length;t++)n[t].push(e)}if(r&&t.hasM){const e=.5*(t.mmax-t.mmin);for(let t=0;t<n.length;t++)n[t].push(e)}return n}))}return null}function i(t,n){const e=n[0]-t[0],r=n[1]-t[1];if(t.length>2&&n.length>2){const i=t[2]-n[2];return Math.sqrt(e*e+r*r+i*i)}return Math.sqrt(e*e+r*r)}function o(t,n,e){const r=t[0]+e*(n[0]-t[0]),i=t[1]+e*(n[1]-t[1]);return t.length>2&&n.length>2?[r,i,t[2]+e*(n[2]-t[2])]:[r,i]}function s(t,n,e,r){return f(t,n,e[r],e[r+1])}function f(t,n,e,r){const[i,o]=n,[s,f]=e,[l,u]=r,c=l-s,h=u-f,p=c*c+h*h,a=(i-s)*c+(o-f)*h,y=Math.min(1,Math.max(0,a/p));return t[0]=s+c*y,t[1]=f+h*y,t}function l(t,n,e){let r,i,o,s,f=!1,l=1/0;for(e.reset();e.nextPath();)if(e.nextPoint())for(r=e.x,i=e.y;e.nextPoint();)o=e.x,s=e.y,i>n!=s>n&&t<(o-r)*(n-i)/(s-i)+r&&(f=!f),l=Math.min(l,u(t,n,r,i,o,s)),r=o,i=s;return 0===l?0:(f?1:-1)*Math.sqrt(l)}function u(t,n,e,r,i,o){let s=e,f=r,l=i-s,u=o-f;if(0!==l||0!==u){const e=((t-s)*l+(n-f)*u)/(l*l+u*u);e>1?(s=i,f=o):e>0&&(s+=l*e,f+=u*e)}return l=t-s,u=n-f,l*l+u*u}function c(t,n){return o(t,n,.5)}function h(t){const n=t.length;let e=0;for(let r=0;r<n-1;++r)e+=i(t[r],t[r+1]);return e}function p(t,n){if(n<=0)return t[0];const e=t.length;let r=0;for(let s=0;s<e-1;++s){const e=i(t[s],t[s+1]);if(n-r<e){const i=(n-r)/e;return o(t[s],t[s+1],i)}r+=e}return t[e-1]}function a(t,e=n.X,r=n.Y){let i=0;const o=t.length;let s=t[0];for(let n=0;n<o-1;n++){const o=t[n+1];i+=(o[e]-s[e])*(o[r]+s[r]),s=o}return i>=0}function y(n){const e=n.length;return e>2&&t(n[0],n[e-1])}function m(t){if("rings"in t&&(g(t),t.rings.length>0&&!a(t.rings[0])))for(const n of t.rings)n.reverse()}function g(t){if("rings"in t)for(const n of t.rings)y(n)||n.push(n[0].slice())}function x(t){if("polygon"!==t.type&&"polyline"!==t.type)return t;return M("polygon"===t.type?t.rings:t.paths,t.spatialReference),t}function M(t,n){const r=e(n);if(!r)return;const i=r.valid[0],o=r.valid[1],s=o-i;for(const e of t){let t=1/0,n=-1/0;for(const s of e){const e=z(s[0],i,o);t=Math.min(t,e),n=Math.max(n,e),s[0]=e}const r=n-t;s-r<r&&e.forEach((t=>{t[0]<0&&(t[0]+=s)}))}}function z(t,n,e){const r=e-n;return t<n?e-(n-t)%r:t>e?n+(t-n)%r:t}function v(t){if(!t||t.length<3)return 0;let n=0;const e=t.length-1;for(let r=0;r<e;r++)n+=(t[r][0]-t[r+1][0])*(t[r][1]+t[r+1][1]);return n+=(t[e][0]-t[0][0])*(t[e][1]+t[0][1]),-.5*n}function j(t,n){if(t===n)return!0;if(t.type!==n.type)return!1;if("point"===t.type||"mesh"===t.type||"extent"===t.type)return!0;if("multipoint"===t.type)return t.points.length===n.points.length;const[e,r]="polyline"===t.type?[t.paths,n.paths]:[t.rings,n.rings];return e.length===r.length&&e.every(((t,n)=>t.length===r[n].length))}export{g as closeRings,m as closeRingsAndFixWinding,l as distanceFromPointToPolygon,u as distanceToSegmentSquared,r as geometryToCoordinates,i as getLength,c as getMidpoint,h as getPathLength,p as getPointOnPath,v as getRingArea,j as hasCompatibleTopology,a as isClockwise,y as isClosed,s as projectPointOnLine,f as projectPointOnLineSeg,x as unnormalizeGeometryOnDatelineCrossing,M as unnormalizeVerticesOnDatelineCrossing,z as unnormalizedCoordinate};
